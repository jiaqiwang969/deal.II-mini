<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceGridTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GridTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GridTools Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceGridTools_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridTools_1_1Cache.html">Cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1OrientationLookupTable.html">OrientationLookupTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1OrientationLookupTable_3_011_01_4.html">OrientationLookupTable&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1OrientationLookupTable_3_012_01_4.html">OrientationLookupTable&lt; 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1OrientationLookupTable_3_013_01_4.html">OrientationLookupTable&lt; 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a995b90803c22dbe67fc6d510494b2e51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a3f53fb4be316505bd3d554a60f36b66b">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a9b55ce0c5531da349ed281e187eca71b">update_vertex_to_cell_map</a> = 0x001, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a4d46baef6b17eb7033571ef1da2341a3">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a0f9bb3e7869273e59af59d0bbba24264">update_used_vertices</a> = 0x008, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51ab902b04c2f3ce872a1c3c5f8c7f0a1b5">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b9dcac6ccefa7abfee0e3d235e9a622">update_cell_bounding_boxes_rtree</a> = 0x020, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51ac2be525d2326d9ad0fcf80d119b902bf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51ad72e91a2b48a683dcee04c0bbce9e607">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a5f2ef9bfe103e3cd81f9d695f02b3af4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aee229c003fc7a805bbf17dcdb74e6267">update_all</a> = 0xFFF
<br />
 }</td></tr>
<tr class="separator:a995b90803c22dbe67fc6d510494b2e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af34ed1fee44c7365f620b203b0c06974"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:af34ed1fee44c7365f620b203b0c06974"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af34ed1fee44c7365f620b203b0c06974">operator&lt;&lt;</a> (StreamType &amp;s, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> u)</td></tr>
<tr class="separator:af34ed1fee44c7365f620b203b0c06974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dd90fb8c8cd12d2d1215a4cc4f270d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a10dd90fb8c8cd12d2d1215a4cc4f270d">operator|</a> (const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f1, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:a10dd90fb8c8cd12d2d1215a4cc4f270d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16a1564283fb76f8dc55443b0e6ee53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ad16a1564283fb76f8dc55443b0e6ee53">operator~</a> (const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f1)</td></tr>
<tr class="separator:ad16a1564283fb76f8dc55443b0e6ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5a34086f9e813638189fc7d72d3874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aaf5a34086f9e813638189fc7d72d3874">operator|=</a> (<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;f1, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:aaf5a34086f9e813638189fc7d72d3874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564267811af347736ab43b6ce0721d49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a564267811af347736ab43b6ce0721d49">operator &amp;</a> (const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f1, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:a564267811af347736ab43b6ce0721d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b9c6e4eddef8e14827575aaf11af99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a34b9c6e4eddef8e14827575aaf11af99">operator &amp;=</a> (<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;f1, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:a34b9c6e4eddef8e14827575aaf11af99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03981bc3a24576a6cfbc0a305c723eec"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a03981bc3a24576a6cfbc0a305c723eec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a03981bc3a24576a6cfbc0a305c723eec">laplace_transform</a> (const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;new_points, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; *coefficient, const <a class="el" href="classbool.html">bool</a> solve_for_absolute_positions)</td></tr>
<tr class="separator:a03981bc3a24576a6cfbc0a305c723eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92034313ef924778e01beb3e24002dd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa92034313ef924778e01beb3e24002dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa92034313ef924778e01beb3e24002dd">copy_boundary_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> reset_boundary_ids)</td></tr>
<tr class="separator:aa92034313ef924778e01beb3e24002dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223fa99383a75568379eb5c71d5d5ac4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a223fa99383a75568379eb5c71d5d5ac4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a223fa99383a75568379eb5c71d5d5ac4">map_boundary_to_manifold_ids</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;src_boundary_ids, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;dst_manifold_ids, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;reset_boundary_ids_)</td></tr>
<tr class="separator:a223fa99383a75568379eb5c71d5d5ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e1e402f5ba79035857e25fa8eff20a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a73e1e402f5ba79035857e25fa8eff20a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a73e1e402f5ba79035857e25fa8eff20a">copy_material_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> compute_face_ids)</td></tr>
<tr class="separator:a73e1e402f5ba79035857e25fa8eff20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af37aecac8fb1dd60b114cc60a7d352"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1af37aecac8fb1dd60b114cc60a7d352"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1af37aecac8fb1dd60b114cc60a7d352">assign_co_dimensional_manifold_indicators</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::function&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>(const std::set&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;)&gt; &amp;disambiguation_function, <a class="el" href="classbool.html">bool</a> overwrite_only_flat_manifold_ids)</td></tr>
<tr class="separator:a1af37aecac8fb1dd60b114cc60a7d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3843115e3b2380ce9980335c0454a804"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a3843115e3b2380ce9980335c0454a804"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a3843115e3b2380ce9980335c0454a804">exchange_local_bounding_boxes</a> (const std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt; &amp;local_bboxes, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a3843115e3b2380ce9980335c0454a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457cb4c41d499faf229512ab30629eb2"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a457cb4c41d499faf229512ab30629eb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a457cb4c41d499faf229512ab30629eb2">build_global_description_tree</a> (const std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt; &amp;local_description, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a457cb4c41d499faf229512ab30629eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae36862c413167cf798e4b076dbc991"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1ae36862c413167cf798e4b076dbc991"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1ae36862c413167cf798e4b076dbc991">collect_coinciding_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;coinciding_vertex_groups, std::map&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;vertex_to_coinciding_vertex_group)</td></tr>
<tr class="separator:a1ae36862c413167cf798e4b076dbc991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3537ac484ba51325c7ca150ddaaf2a5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae3537ac484ba51325c7ca150ddaaf2a5"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae3537ac484ba51325c7ca150ddaaf2a5">compute_vertices_with_ghost_neighbors</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:ae3537ac484ba51325c7ca150ddaaf2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af203f92d771fec1b638c3d032a816592"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af203f92d771fec1b638c3d032a816592"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename ::<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af203f92d771fec1b638c3d032a816592">find_active_cell_around_point</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:af203f92d771fec1b638c3d032a816592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675fa3d8d6ce094fe29a59991b5d6421"><td class="memTemplParams" colspan="2">template&lt;typename CellIterator &gt; </td></tr>
<tr class="memitem:a675fa3d8d6ce094fe29a59991b5d6421"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a675fa3d8d6ce094fe29a59991b5d6421">match_periodic_face_pairs</a> (std::set&lt; std::pair&lt; CellIterator, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;pairs1, std::set&lt; std::pair&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; CellIterator &gt;::type, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;pairs2, const <a class="el" href="classint.html">int</a> direction, std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; CellIterator &gt;&gt; &amp;matched_pairs, const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CellIterator::AccessorType::space_dimension &gt; &amp;offset, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix)</td></tr>
<tr class="separator:a675fa3d8d6ce094fe29a59991b5d6421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213a31f196cd53ccbcc809e567934442"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:a213a31f196cd53ccbcc809e567934442"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a213a31f196cd53ccbcc809e567934442">collect_periodic_faces</a> (const MeshType &amp;mesh, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id, const <a class="el" href="classint.html">int</a> direction, std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;matched_pairs, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;offset, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix)</td></tr>
<tr class="separator:a213a31f196cd53ccbcc809e567934442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a75867a6e9ed89b3dcb1a18206870dc"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:a1a75867a6e9ed89b3dcb1a18206870dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1a75867a6e9ed89b3dcb1a18206870dc">collect_periodic_faces</a> (const MeshType &amp;mesh, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id1, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id2, const <a class="el" href="classint.html">int</a> direction, std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;matched_pairs, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;offset, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix)</td></tr>
<tr class="separator:a1a75867a6e9ed89b3dcb1a18206870dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132f7057487b35446876f2d84aaaf6df"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a132f7057487b35446876f2d84aaaf6df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a132f7057487b35446876f2d84aaaf6df">orthogonal_equality</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point2, const <a class="el" href="classint.html">int</a> direction, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;offset, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix)</td></tr>
<tr class="separator:a132f7057487b35446876f2d84aaaf6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062e05c51d27f3da00f2a1aa37bd3a43"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a062e05c51d27f3da00f2a1aa37bd3a43"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a062e05c51d27f3da00f2a1aa37bd3a43">cell_measure&lt; 1 &gt;</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&gt; &amp;all_vertices, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)</td></tr>
<tr class="separator:a062e05c51d27f3da00f2a1aa37bd3a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2994e9cd1a025e9fdd7cb411d68ec57"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac2994e9cd1a025e9fdd7cb411d68ec57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac2994e9cd1a025e9fdd7cb411d68ec57">cell_measure&lt; 2 &gt;</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&gt; &amp;all_vertices, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)</td></tr>
<tr class="separator:ac2994e9cd1a025e9fdd7cb411d68ec57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275c6633e25410e091b89af0756d4333"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a275c6633e25410e091b89af0756d4333"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a275c6633e25410e091b89af0756d4333">cell_measure&lt; 3 &gt;</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;all_vertices, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)</td></tr>
<tr class="separator:a275c6633e25410e091b89af0756d4333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ba100e8116931dcf4055f667762c8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a366ba100e8116931dcf4055f667762c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a366ba100e8116931dcf4055f667762c8">rotate</a> (const <a class="el" href="classdouble.html">double</a> <a class="el" href="grid__tools__nontemplates_8cc.html#a1b9d6e95246f7a6b7ecc7430631dd0b6">angle</a>, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a366ba100e8116931dcf4055f667762c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5fdacaa512a29dac48ad9b11ac159a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0a5fdacaa512a29dac48ad9b11ac159a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0a5fdacaa512a29dac48ad9b11ac159a">rotate</a> (const <a class="el" href="classdouble.html">double</a> <a class="el" href="grid__tools__nontemplates_8cc.html#a1b9d6e95246f7a6b7ecc7430631dd0b6">angle</a>, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a0a5fdacaa512a29dac48ad9b11ac159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">关于网格和单元的信息</div></td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:acd5ccc543d561cfb086b571d1f7818cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8169dc4981e90ba5d2386a87efa042"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9e8169dc4981e90ba5d2386a87efa042"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9e8169dc4981e90ba5d2386a87efa042">volume</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:a9e8169dc4981e90ba5d2386a87efa042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c293eff2ec7ce4b90ba08b35d1f2e2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a47c293eff2ec7ce4b90ba08b35d1f2e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">minimal_cell_diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:a47c293eff2ec7ce4b90ba08b35d1f2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8409fa9cb46a0070abc4da7de0f47f2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae8409fa9cb46a0070abc4da7de0f47f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae8409fa9cb46a0070abc4da7de0f47f2">maximal_cell_diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ae8409fa9cb46a0070abc4da7de0f47f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fcabb522b0dc88c2959a1712e90fc1"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a33fcabb522b0dc88c2959a1712e90fc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a33fcabb522b0dc88c2959a1712e90fc1">cell_measure</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;all_vertices, const unsigned <a class="el" href="classint.html">int</a>(&amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell])</td></tr>
<tr class="separator:a33fcabb522b0dc88c2959a1712e90fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290ae00a4f293af389264a5f8135051a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a290ae00a4f293af389264a5f8135051a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a290ae00a4f293af389264a5f8135051a">cell_measure</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;all_vertices, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;<a class="el" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>)</td></tr>
<tr class="separator:a290ae00a4f293af389264a5f8135051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0625c2914fc4add7336c3ae9c88beedd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0625c2914fc4add7336c3ae9c88beedd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0625c2914fc4add7336c3ae9c88beedd">affine_cell_approximation</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>)</td></tr>
<tr class="separator:a0625c2914fc4add7336c3ae9c88beedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0cf2feadb3374ed24f70d99e6e7740"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a9b0cf2feadb3374ed24f70d99e6e7740"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9b0cf2feadb3374ed24f70d99e6e7740">compute_aspect_ratio_of_cells</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature)</td></tr>
<tr class="separator:a9b0cf2feadb3374ed24f70d99e6e7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6477e53e65dfbcaa0b2add902f4350e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aa6477e53e65dfbcaa0b2add902f4350e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa6477e53e65dfbcaa0b2add902f4350e">compute_maximum_aspect_ratio</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature)</td></tr>
<tr class="separator:aa6477e53e65dfbcaa0b2add902f4350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ec55abefa31cf001fd29d8d4d993f1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae1ec55abefa31cf001fd29d8d4d993f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae1ec55abefa31cf001fd29d8d4d993f1">compute_bounding_box</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:ae1ec55abefa31cf001fd29d8d4d993f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350e00a4c5194b3007de4ea4bb13930b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a350e00a4c5194b3007de4ea4bb13930b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a350e00a4c5194b3007de4ea4bb13930b">project_to_object</a> (const Iterator &amp;object, const <a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt; &amp;trial_point)</td></tr>
<tr class="separator:a350e00a4c5194b3007de4ea4bb13930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06527a9436669439941b304ac073e85"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af06527a9436669439941b304ac073e85"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt;, <a class="el" href="structSubCellData.html">SubCellData</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af06527a9436669439941b304ac073e85">get_coarse_mesh_description</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:af06527a9436669439941b304ac073e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">支持创建网格的函数</div></td></tr>
<tr class="memitem:aa502b615730af32271d9da4206939a81"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa502b615730af32271d9da4206939a81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa502b615730af32271d9da4206939a81">delete_unused_vertices</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:aa502b615730af32271d9da4206939a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb09f2e9812f04661f9ca79e598e197"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2fb09f2e9812f04661f9ca79e598e197"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2fb09f2e9812f04661f9ca79e598e197">delete_duplicated_vertices</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;all_vertices, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;considered_vertices, const <a class="el" href="classdouble.html">double</a> tol=1e-12)</td></tr>
<tr class="separator:a2fb09f2e9812f04661f9ca79e598e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e0f86b3a9310f1952cfe29e1fe7bd4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a26e0f86b3a9310f1952cfe29e1fe7bd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a26e0f86b3a9310f1952cfe29e1fe7bd4">invert_all_negative_measure_cells</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;all_vertices, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells)</td></tr>
<tr class="separator:a26e0f86b3a9310f1952cfe29e1fe7bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5f04ca06ef2667c468296f538716e7"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a8d5f04ca06ef2667c468296f538716e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8d5f04ca06ef2667c468296f538716e7">consistently_order_cells</a> (std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells)</td></tr>
<tr class="separator:a8d5f04ca06ef2667c468296f538716e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">旋转、拉伸和其他变换网格的方法</div></td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Transformation , int spacedim&gt; </td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform</a> (const Transformation &amp;transformation, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b953611883979e3f920f800bd855df3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4b953611883979e3f920f800bd855df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">shift</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;shift_vector, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a4b953611883979e3f920f800bd855df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910bb99ec34eac082da97c08e7dd17c3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a910bb99ec34eac082da97c08e7dd17c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a910bb99ec34eac082da97c08e7dd17c3">rotate</a> (const <a class="el" href="classdouble.html">double</a> <a class="el" href="grid__tools__nontemplates_8cc.html#a1b9d6e95246f7a6b7ecc7430631dd0b6">angle</a>, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a910bb99ec34eac082da97c08e7dd17c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a580cbf329f016024a2e6b9d7eb9eed69">rotate</a> (const <a class="el" href="classdouble.html">double</a> <a class="el" href="grid__tools__nontemplates_8cc.html#a1b9d6e95246f7a6b7ecc7430631dd0b6">angle</a>, const unsigned <a class="el" href="classint.html">int</a> axis, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, 3 &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">laplace_transform</a> (const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;new_points, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; *coefficient=nullptr, const <a class="el" href="classbool.html">bool</a> solve_for_absolute_positions=false)</td></tr>
<tr class="separator:a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1baa65a240caf7a5033f47b07b17f86f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1baa65a240caf7a5033f47b07b17f86f"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1baa65a240caf7a5033f47b07b17f86f">get_all_vertices_at_boundary</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:a1baa65a240caf7a5033f47b07b17f86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a> (const <a class="el" href="classdouble.html">double</a> scaling_factor, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a0967563badadd81f77f62622dd8bc2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e8aecd2cf74d3476e0daa11a00248b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac4e8aecd2cf74d3476e0daa11a00248b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">distort_random</a> (const <a class="el" href="classdouble.html">double</a> factor, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classbool.html">bool</a> keep_boundary=true, const unsigned <a class="el" href="classint.html">int</a> seed=boost::random::mt19937::default_seed)</td></tr>
<tr class="separator:ac4e8aecd2cf74d3476e0daa11a00248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b77b07123012706fbadf91d8f022b3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a62b77b07123012706fbadf91d8f022b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a62b77b07123012706fbadf91d8f022b3">remove_hanging_nodes</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> isotropic=false, const unsigned <a class="el" href="classint.html">int</a> max_iterations=100)</td></tr>
<tr class="separator:a62b77b07123012706fbadf91d8f022b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40336842aa2faac805746dc10c7c604f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a40336842aa2faac805746dc10c7c604f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a40336842aa2faac805746dc10c7c604f">remove_anisotropy</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> max_ratio=1.6180339887, const unsigned <a class="el" href="classint.html">int</a> max_iterations=5)</td></tr>
<tr class="separator:a40336842aa2faac805746dc10c7c604f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f129213c63c92a6ed84c6f2a906048b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3f129213c63c92a6ed84c6f2a906048b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">regularize_corner_cells</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> limit_angle_fraction=.75)</td></tr>
<tr class="separator:a3f129213c63c92a6ed84c6f2a906048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">寻找三角形的单元和顶点</div></td></tr>
<tr class="memitem:a8e8bb9211264d2106758ac4d7184117e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8e8bb9211264d2106758ac4d7184117e"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">compute_point_locations</a> (const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;cache, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;points, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell_hint=typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator())</td></tr>
<tr class="separator:a8e8bb9211264d2106758ac4d7184117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a845642f4d205352931267b58055d62"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5a845642f4d205352931267b58055d62"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a5a845642f4d205352931267b58055d62">compute_point_locations_try_all</a> (const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;cache, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;points, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell_hint=typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator())</td></tr>
<tr class="separator:a5a845642f4d205352931267b58055d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6eff31d194dd4beafc9eb6a22c5e27"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afe6eff31d194dd4beafc9eb6a22c5e27"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#afe6eff31d194dd4beafc9eb6a22c5e27">distributed_compute_point_locations</a> (const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim, spacedim &gt; &amp;cache, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;local_points, const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;global_bboxes, const <a class="el" href="classdouble.html">double</a> tolerance=1e-10)</td></tr>
<tr class="separator:afe6eff31d194dd4beafc9eb6a22c5e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30077cfce9e6234e386fbd4286bc2dd7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a30077cfce9e6234e386fbd4286bc2dd7"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a30077cfce9e6234e386fbd4286bc2dd7">extract_used_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;container, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:a30077cfce9e6234e386fbd4286bc2dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f49d6a42c3dbabc53a86571e874cc3f"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a1f49d6a42c3dbabc53a86571e874cc3f"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">find_closest_vertex</a> (const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:a1f49d6a42c3dbabc53a86571e874cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07919e120e98a6a0139ffe8c9f4a2a8b"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a07919e120e98a6a0139ffe8c9f4a2a8b"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a07919e120e98a6a0139ffe8c9f4a2a8b">find_closest_vertex</a> (const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={})</td></tr>
<tr class="separator:a07919e120e98a6a0139ffe8c9f4a2a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f7b02080d7740cdb0fe73f3917af36"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a84f7b02080d7740cdb0fe73f3917af36"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a84f7b02080d7740cdb0fe73f3917af36">find_closest_vertex</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={})</td></tr>
<tr class="separator:a84f7b02080d7740cdb0fe73f3917af36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb822f0e3068e48640ecc981ee6c1e6"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:addb822f0e3068e48640ecc981ee6c1e6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#addb822f0e3068e48640ecc981ee6c1e6">find_cells_adjacent_to_vertex</a> (const MeshType&lt; dim, spacedim &gt; &amp;container, const unsigned <a class="el" href="classint.html">int</a> vertex_index)</td></tr>
<tr class="separator:addb822f0e3068e48640ecc981ee6c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e10aeb1c8e76110a84b6945eac3aaf0"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a2e10aeb1c8e76110a84b6945eac3aaf0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={}, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10)</td></tr>
<tr class="separator:a2e10aeb1c8e76110a84b6945eac3aaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df2272fe8a72156bc2628aa07c5123e"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a9df2272fe8a72156bc2628aa07c5123e"><td class="memTemplItemLeft" align="right" valign="top">MeshType&lt; dim, spacedim &gt;::active_cell_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9df2272fe8a72156bc2628aa07c5123e">find_active_cell_around_point</a> (const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={}, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10)</td></tr>
<tr class="separator:a9df2272fe8a72156bc2628aa07c5123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b6a71ae04417bd4b1a3d6d237557f1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad9b6a71ae04417bd4b1a3d6d237557f1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ad9b6a71ae04417bd4b1a3d6d237557f1">find_active_cell_around_point</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10)</td></tr>
<tr class="separator:ad9b6a71ae04417bd4b1a3d6d237557f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f673ed723568e41c72a3634e4d12db"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a59f673ed723568e41c72a3634e4d12db"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a59f673ed723568e41c72a3634e4d12db">find_active_cell_around_point</a> (const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell_hint=typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator(), const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={}, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10)</td></tr>
<tr class="separator:a59f673ed723568e41c72a3634e4d12db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2881f45ff9aa67db94aeb46437797cf4"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a2881f45ff9aa67db94aeb46437797cf4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2881f45ff9aa67db94aeb46437797cf4">find_active_cell_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; std::set&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;<a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">vertex_to_cell_map</a>, const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt;&gt; &amp;vertex_to_cell_centers, const typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell_hint=typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator(), const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={}, const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;used_vertices_rtree=<a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt;{}, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10, const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; *relevant_cell_bounding_boxes_rtree=nullptr)</td></tr>
<tr class="separator:a2881f45ff9aa67db94aeb46437797cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef086f558e9e1c6148e3fa8c62e7a066"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:aef086f558e9e1c6148e3fa8c62e7a066"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aef086f558e9e1c6148e3fa8c62e7a066">find_all_active_cells_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classdouble.html">double</a> tolerance, const std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;first_cell)</td></tr>
<tr class="separator:aef086f558e9e1c6148e3fa8c62e7a066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7daaed7cdd68d2b8f70d2dde1df3061"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:af7daaed7cdd68d2b8f70d2dde1df3061"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af7daaed7cdd68d2b8f70d2dde1df3061">find_all_active_cells_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classdouble.html">double</a> tolerance=1e-10, const std::vector&lt; bool &gt; &amp;marked_vertices={})</td></tr>
<tr class="separator:af7daaed7cdd68d2b8f70d2dde1df3061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c182c1901bb0d09046271809f918c6"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:ab5c182c1901bb0d09046271809f918c6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ab5c182c1901bb0d09046271809f918c6">get_active_child_cells</a> (const typename MeshType::cell_iterator &amp;cell)</td></tr>
<tr class="separator:ab5c182c1901bb0d09046271809f918c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a30ccceb7c9216efc44dd4af561e0bea0">get_active_neighbors</a> (const typename MeshType::active_cell_iterator &amp;cell, std::vector&lt; typename MeshType::active_cell_iterator &gt; &amp;active_neighbors)</td></tr>
<tr class="separator:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51acc74a2c56fc9cab517235be235cdc"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a51acc74a2c56fc9cab517235be235cdc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">compute_active_cell_halo_layer</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate)</td></tr>
<tr class="separator:a51acc74a2c56fc9cab517235be235cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e89706e7e925b16d42d288c462e9d8"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a98e89706e7e925b16d42d288c462e9d8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a98e89706e7e925b16d42d288c462e9d8">compute_cell_halo_layer_on_level</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::cell_iterator &amp;)&gt; &amp;predicate, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</td></tr>
<tr class="separator:a98e89706e7e925b16d42d288c462e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0674004143aed7f492a3ae7bcb2e3d"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a6d0674004143aed7f492a3ae7bcb2e3d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a6d0674004143aed7f492a3ae7bcb2e3d">compute_ghost_cell_halo_layer</a> (const MeshType &amp;mesh)</td></tr>
<tr class="separator:a6d0674004143aed7f492a3ae7bcb2e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599f59fd9beccda86d7980c30a9b1f6a"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a599f59fd9beccda86d7980c30a9b1f6a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a599f59fd9beccda86d7980c30a9b1f6a">compute_active_cell_layer_within_distance</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate, const <a class="el" href="classdouble.html">double</a> layer_thickness)</td></tr>
<tr class="separator:a599f59fd9beccda86d7980c30a9b1f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21d10102639460701c67f7e79afc06f"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:aa21d10102639460701c67f7e79afc06f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa21d10102639460701c67f7e79afc06f">compute_ghost_cell_layer_within_distance</a> (const MeshType &amp;mesh, const <a class="el" href="classdouble.html">double</a> layer_thickness)</td></tr>
<tr class="separator:aa21d10102639460701c67f7e79afc06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0374dd9eae73c3c2badaa479e8ba8d55"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a0374dd9eae73c3c2badaa479e8ba8d55"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt;, <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0374dd9eae73c3c2badaa479e8ba8d55">compute_bounding_box</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate)</td></tr>
<tr class="separator:a0374dd9eae73c3c2badaa479e8ba8d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08438d4ad901817b7b638ce733fd664d"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a08438d4ad901817b7b638ce733fd664d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; MeshType::space_dimension &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a08438d4ad901817b7b638ce733fd664d">compute_mesh_predicate_bounding_box</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate, const unsigned <a class="el" href="classint.html">int</a> refinement_level=0, const <a class="el" href="classbool.html">bool</a> allow_merge=false, const unsigned <a class="el" href="classint.html">int</a> max_boxes=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a08438d4ad901817b7b638ce733fd664d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84063935e67e3a3bb5afadc7b00599ac"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a84063935e67e3a3bb5afadc7b00599ac"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a84063935e67e3a3bb5afadc7b00599ac">guess_point_owner</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;global_bboxes, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;points)</td></tr>
<tr class="separator:a84063935e67e3a3bb5afadc7b00599ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327cb9de55959193994a994047592ec9"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a327cb9de55959193994a994047592ec9"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a327cb9de55959193994a994047592ec9">guess_point_owner</a> (const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;covering_rtree, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;points)</td></tr>
<tr class="separator:a327cb9de55959193994a994047592ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7e2ca8ecd26a472e5225ba91a58acb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9b7e2ca8ecd26a472e5225ba91a58acb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">vertex_to_cell_map</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a9b7e2ca8ecd26a472e5225ba91a58acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eddc6b744c7c83d9bc020dfa509e19"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a79eddc6b744c7c83d9bc020dfa509e19"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">vertex_to_cell_centers_directions</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh, const std::vector&lt; std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;vertex_to_cells)</td></tr>
<tr class="separator:a79eddc6b744c7c83d9bc020dfa509e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9ac4e5783a4c13911c576064b255be"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2d9ac4e5783a4c13911c576064b255be"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2d9ac4e5783a4c13911c576064b255be">find_closest_vertex_of_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;position, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:a2d9ac4e5783a4c13911c576064b255be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1ec4049da3c61cb29eb294199e7e53"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:adf1ec4049da3c61cb29eb294199e7e53"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a4fbb80cf1f559474b7f3044eaf08a078">types::global_vertex_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#adf1ec4049da3c61cb29eb294199e7e53">compute_local_to_global_vertex_index_map</a> (const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:adf1ec4049da3c61cb29eb294199e7e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed82bbc9838a9123bf567014ae9990dd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aed82bbc9838a9123bf567014ae9990dd"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aed82bbc9838a9123bf567014ae9990dd">get_longest_direction</a> (typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator cell)</td></tr>
<tr class="separator:aed82bbc9838a9123bf567014ae9990dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">三角形的分区和子域</div></td></tr>
<tr class="memitem:a002fd376a184234ccbf5eca8f8fd7012"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a002fd376a184234ccbf5eca8f8fd7012"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a002fd376a184234ccbf5eca8f8fd7012">get_face_connectivity_of_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:a002fd376a184234ccbf5eca8f8fd7012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54e2fb68484ddaedaab56de13323169"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab54e2fb68484ddaedaab56de13323169"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ab54e2fb68484ddaedaab56de13323169">get_vertex_connectivity_of_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:ab54e2fb68484ddaedaab56de13323169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec0e25e2e5b5c9f359516d85ef29950"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acec0e25e2e5b5c9f359516d85ef29950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acec0e25e2e5b5c9f359516d85ef29950">get_vertex_connectivity_of_cells_on_level</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:acec0e25e2e5b5c9f359516d85ef29950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eba8e3b388258eda37a2724579dd1d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a99eba8e3b388258eda37a2724579dd1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a99eba8e3b388258eda37a2724579dd1d">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a>)</td></tr>
<tr class="separator:a99eba8e3b388258eda37a2724579dd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72956e32f5a1091a6c8731b545e7fcbf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a72956e32f5a1091a6c8731b545e7fcbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a72956e32f5a1091a6c8731b545e7fcbf">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;cell_weights, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a>)</td></tr>
<tr class="separator:a72956e32f5a1091a6c8731b545e7fcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c475677bc29b764e9fa5978d4d41f77"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3c475677bc29b764e9fa5978d4d41f77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a3c475677bc29b764e9fa5978d4d41f77">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;cell_connection_graph, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a>)</td></tr>
<tr class="separator:a3c475677bc29b764e9fa5978d4d41f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af499f992ff3d4716f7f15c55d68ade02"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af499f992ff3d4716f7f15c55d68ade02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af499f992ff3d4716f7f15c55d68ade02">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;cell_weights, const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;cell_connection_graph, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a>)</td></tr>
<tr class="separator:af499f992ff3d4716f7f15c55d68ade02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1951822ebc7a80fb21aea5d4cd6dac6c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1951822ebc7a80fb21aea5d4cd6dac6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1951822ebc7a80fb21aea5d4cd6dac6c">partition_triangulation_zorder</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classbool.html">bool</a> group_siblings=true)</td></tr>
<tr class="separator:a1951822ebc7a80fb21aea5d4cd6dac6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d37431a097d36fb7152c41e0352b5e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a70d37431a097d36fb7152c41e0352b5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a70d37431a097d36fb7152c41e0352b5e">partition_multigrid_levels</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a70d37431a097d36fb7152c41e0352b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41d959ae1723a898b616c3320241ffe"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac41d959ae1723a898b616c3320241ffe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac41d959ae1723a898b616c3320241ffe">get_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const std::vector&lt; <a class="el" href="classCellId.html">CellId</a> &gt; &amp;cell_ids)</td></tr>
<tr class="separator:ac41d959ae1723a898b616c3320241ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae0cb61bdd7e17c6b1589bdd16891e561">get_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;subdomain)</td></tr>
<tr class="separator:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c212a30784bec20b1ae13fad3fd579c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8c212a30784bec20b1ae13fad3fd579c"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">count_cells_with_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:a8c212a30784bec20b1ae13fad3fd579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b3f1dcc53c868171f1bb0a3793a96e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a33b3f1dcc53c868171f1bb0a3793a96e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a33b3f1dcc53c868171f1bb0a3793a96e">get_locally_owned_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a33b3f1dcc53c868171f1bb0a3793a96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">比较不同的网格</div></td></tr>
<tr class="memitem:a32a5016c746ad756046ecff264dfa60d"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:a32a5016c746ad756046ecff264dfa60d"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; typename MeshType::cell_iterator, typename MeshType::cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a32a5016c746ad756046ecff264dfa60d">get_finest_common_cells</a> (const MeshType &amp;mesh_1, const MeshType &amp;mesh_2)</td></tr>
<tr class="separator:a32a5016c746ad756046ecff264dfa60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aae387b14cb19f14e3dbd3e0e1a3e3ba2">have_same_coarse_mesh</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh_2)</td></tr>
<tr class="separator:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75c70b1760c88a852413a1a9fae107"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:abb75c70b1760c88a852413a1a9fae107"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#abb75c70b1760c88a852413a1a9fae107">have_same_coarse_mesh</a> (const MeshType &amp;mesh_1, const MeshType &amp;mesh_2)</td></tr>
<tr class="separator:abb75c70b1760c88a852413a1a9fae107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理扭曲的单元格</div></td></tr>
<tr class="memitem:a1c7bb95bc2bbb09d6f02651d7be1527d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1c7bb95bc2bbb09d6f02651d7be1527d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1c7bb95bc2bbb09d6f02651d7be1527d">fix_up_distorted_child_cells</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList &amp;distorted_cells, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</td></tr>
<tr class="separator:a1c7bb95bc2bbb09d6f02651d7be1527d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">提取和创建单元格斑块 这些函数提取和创建围绕单个单元格的单元格斑块，并从中创建三角图。</div></td></tr>
<tr class="memitem:aaec69b92488f0dd0d61ff66445327f0d"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:aaec69b92488f0dd0d61ff66445327f0d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">get_patch_around_cell</a> (const typename MeshType::active_cell_iterator &amp;cell)</td></tr>
<tr class="separator:aaec69b92488f0dd0d61ff66445327f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb9de754873e0401df4a51bacf0556c"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a1cb9de754873e0401df4a51bacf0556c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Container::cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1cb9de754873e0401df4a51bacf0556c">get_cells_at_coarsest_common_level</a> (const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;patch_cells)</td></tr>
<tr class="separator:a1cb9de754873e0401df4a51bacf0556c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3b216d4efc9d4add312c055a5ec95f"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:aca3b216d4efc9d4add312c055a5ec95f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aca3b216d4efc9d4add312c055a5ec95f">build_triangulation_from_patch</a> (const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;patch, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt; &amp;local_triangulation, std::map&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt;::active_cell_iterator, typename Container::active_cell_iterator &gt; &amp;patch_to_global_tria_map)</td></tr>
<tr class="separator:aca3b216d4efc9d4add312c055a5ec95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90221d4afe481ab23792286fe21e71dd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a90221d4afe481ab23792286fe21e71dd"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a90221d4afe481ab23792286fe21e71dd">get_dof_to_support_patch_map</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a90221d4afe481ab23792286fe21e71dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理周期性域的问题</div></td></tr>
<tr class="memitem:ac2a1903382c6cff07b33d456a641f6d9"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:ac2a1903382c6cff07b33d456a641f6d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality</a> (std::bitset&lt; 3 &gt; &amp;orientation, const FaceIterator &amp;face1, const FaceIterator &amp;face2, const <a class="el" href="classint.html">int</a> direction, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;offset=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:ac2a1903382c6cff07b33d456a641f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace05eb85711971f65123e569fead988c"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:ace05eb85711971f65123e569fead988c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ace05eb85711971f65123e569fead988c">orthogonal_equality</a> (const FaceIterator &amp;face1, const FaceIterator &amp;face2, const <a class="el" href="classint.html">int</a> direction, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;offset=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:ace05eb85711971f65123e569fead988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>这个命名空间是工作在三角形上的算法的集合，比如移动或旋转三角形，但也可以找到包含给定点的单元。更多信息请参见各个函数的描述。 </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a995b90803c22dbe67fc6d510494b2e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995b90803c22dbe67fc6d510494b2e51">&#9670;&nbsp;</a></span>CacheUpdateFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">GridTools::CacheUpdateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给予Cache类的枚举类型，用于选择要更新的信息。 你可以用位法或 <code><a class="el" href="namespaceGridTools.html#a10dd90fb8c8cd12d2d1215a4cc4f270d">operator|(CacheUpdateFlags,CacheUpdateFlags)</a></code> 串联选择一个以上的标志。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a3f53fb4be316505bd3d554a60f36b66b"></a>update_nothing&#160;</td><td class="fielddoc"><p>更新无。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a9b55ce0c5531da349ed281e187eca71b"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>更新Vertex_to_cell_map，如 <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>. 所返回的。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a4d46baef6b17eb7033571ef1da2341a3"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>更新由 <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a> 返回的Vertex_to_cell_centers_directions。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a0f9bb3e7869273e59af59d0bbba24264"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>更新已用顶点的映射。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51ab902b04c2f3ce872a1c3c5f8c7f0a1b5"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>更新一个已使用顶点的RTree。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b9dcac6ccefa7abfee0e3d235e9a622"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>更新单元格包围盒的RT树。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51ac2be525d2326d9ad0fcf80d119b902bf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>更新覆盖的rtree对象，初始化为界线盒和无符号int对。边界框用于描述网格的哪一部分包含本地拥有的单元，通过对的第二个元素的排序过程。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51ad72e91a2b48a683dcee04c0bbce9e607"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>更新本地拥有的单元格边界盒的RTree。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a5f2ef9bfe103e3cd81f9d695f02b3af4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>更新顶点到邻居子域 </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aee229c003fc7a805bbf17dcdb74e6267"></a>update_all&#160;</td><td class="fielddoc"><p>更新所有对象。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00034">34</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acd5ccc543d561cfb086b571d1f7818cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5ccc543d561cfb086b571d1f7818cb">&#9670;&nbsp;</a></span>diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个三角结构的直径。直径的计算只使用顶点，也就是说，如果由于高阶映射的原因，直径应该大于边界顶点之间的最大距离，那么这个函数将不会捕捉到这个。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00081">81</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a9e8169dc4981e90ba5d2386a87efa042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8169dc4981e90ba5d2386a87efa042">&#9670;&nbsp;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;dim&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.template&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;dim,&#160;spacedim&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算三角形的体积（即二维度量）。我们使用积分 \(\sum_K \int_K 1 \; dx\) 来计算这个度量，其中 \(K\) 是给定三角结构的单元。该积分通过正交来逼近，为此我们需要映射参数。 如果三角形是一个嵌入到高维空间中的二维空间，那么返回的值就是二维度量。例如，对于三维空间中的二维三角形，返回的值是所描述的曲面的面积。这显然是有意义的，因为如果dim &lt; spacedim，那么dim-dimensional triangulation的spacedim-dimensional measure将总是零。 这个函数也适用于 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 类型的对象，在这种情况下，这个函数是一个集体操作。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>三角化。 </td></tr>
    <tr><td class="paramname">mapping</td><td>一个可选的参数，用于表示在描述单元格是由直线还是曲线面所包围时应该使用的映射。默认情况下使用 \(Q_1\) 映射，它对应于单元格的直线边界。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>三角形所描述的域的dim-dimensional度量，如上所述。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00137">137</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a47c293eff2ec7ce4b90ba08b35d1f2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c293eff2ec7ce4b90ba08b35d1f2e2">&#9670;&nbsp;</a></span>minimal_cell_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::minimal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;dim&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.template&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;dim,&#160;spacedim&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个三角形的最小活动单元的直径近似值。参见 <a class="el" href="step_24.html">step-24</a> 中关于这个函数的使用实例。 请注意，即使你传递了一个非琐碎的映射，返回的值也只是使用三角结构的顶点信息来计算的，可能是通过映射来转换的。虽然这在大多数情况下是准确的，但当三角结构包含非常扭曲的单元时，它可能无法给出正确的结果。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04309">4309</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae8409fa9cb46a0070abc4da7de0f47f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8409fa9cb46a0070abc4da7de0f47f2">&#9670;&nbsp;</a></span>maximal_cell_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::maximal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;dim&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.template&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;dim,&#160;spacedim&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个三角形的最大活动单元的直径近似值。 请注意，即使你向这个函数传递了一个非琐碎的映射，返回的值也只是使用三角结构的顶点信息来计算的，可能会被映射转化。虽然这在大多数情况下是准确的，但当三角结构包含非常扭曲的单元时，它可能无法给出正确的结果。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04336">4336</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a33fcabb522b0dc88c2959a1712e90fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fcabb522b0dc88c2959a1712e90fc1">&#9670;&nbsp;</a></span>cell_measure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::cell_measure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>(&amp;)&#160;</td>
          <td class="paramname"><em>vertex_indices</em>[GeometryInfo&lt; dim &gt;::vertices_per_cell]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个顶点列表（通常使用 <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices</a>) 获得）作为第一个参数，以及一个表征单个单元的顶点索引列表作为第二个参数，返回这个单元的度量（面积、体积）。如果这是一个真实的单元格，那么你可以使用 <code>cell-&gt;measure()</code> 得到同样的结果，但这个函数也适用于不存在的单元格，只是你通过从列表中命名它的顶点来编造它。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>使用更通用的函数，该函数需要一个ArrayView来代替。</dd></dl>

</div>
</div>
<a id="a290ae00a4f293af389264a5f8135051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290ae00a4f293af389264a5f8135051a">&#9670;&nbsp;</a></span>cell_measure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::cell_measure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个顶点列表（通常使用 <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices()</a>) 获得）作为第一个参数，以及一个表征单个单元的顶点索引列表作为第二个参数，返回该单元的度量（面积、体积）。如果这是一个真实的单元格，那么你可以用 <code>cell-&gt;measure()</code> 得到同样的结果，但这个函数也适用于不存在的单元格，只是你通过从列表中命名它的顶点来编造它。 参数 <code>vertex_indices</code> 被期望有 <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">GeometryInfo&lt;dim&gt;::vertices_per_cell</a> 项。一个 std::vector 可以隐式转换为ArrayView，所以它可以直接传递。更多信息请参见ArrayView类。 </p><dl class="section note"><dt>Note</dt><dd>这个函数只对二维度为零的对象实现。 </dd></dl>

</div>
</div>
<a id="a0625c2914fc4add7336c3ae9c88beedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0625c2914fc4add7336c3ae9c88beedd">&#9670;&nbsp;</a></span>affine_cell_approximation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; GridTools::affine_cell_approximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数通过对代表四边形或六面体单元的 \(p_\text{real} = A p_\text{unit} + b \) 顶点进行最小二乘法拟合，计算出从单位坐标到实坐标形式的仿生近似图，其维度为<code>spacedim</code>。结果是以矩阵<em>A</em>作为第一个参数，向量<em>b</em>描述平面到原点的距离，以一对方式返回。 对于任何有效的网格单元，其几何形状不是退化的，这个操作的结果是唯一的仿生映射，即使在双/三线或高阶映射的实际转换可能是单数的情况下。如果从单元到实际单元的转换确实是仿生的，例如在一维或二维/三维的笛卡尔和仿生（平行四边形）网格中，其结果是精确的。 这种近似是函数 <a class="el" href="classTriaAccessor.html#a3eb24d5074a9a7bf216bd82f5d0dc618">TriaAccessor::real_to_unit_cell_affine_approximation()</a> 功能的基础。 对于单元格的精确变换，使用 <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00288">288</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a9b0cf2feadb3374ed24f70d99e6e7740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0cf2feadb3374ed24f70d99e6e7740">&#9670;&nbsp;</a></span>compute_aspect_ratio_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; GridTools::compute_aspect_ratio_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算所有本地拥有的活动单元的长宽比度量，并填充一个每个单元有一个条目的向量，给定一个 <code>triangulation</code> 和 <code>mapping</code>. ，返回的向量的大小等于活动单元的数量。对于非本地拥有的单元，该向量包含零。单元的长宽比定义为Jacobian的最大奇异值与最小奇异值之比，取通过 <code>quadrature</code>. 指定的正交规则的所有正交点的最大值。 例如，对于尺寸为 \(a\) 和 \(b\) 的2D矩形元素的特殊情况（ \(a \geq b\) ），这个函数返回通常的长宽比定义 \(a/b\) 。上述使用奇异值的定义是对任意变形元素的一种概括。这个函数旨在用于 \(d=2,3\) 空间维度，但它也可以用于 \(d=1\) 返回值为1。 </p><dl class="section note"><dt>Note</dt><dd>颠倒的元素不会抛出一个异常。相反，在倒置元素的情况下，一个inf的值被写入向量。 </dd>
<dd>
确保使用足够的正交点，以便在变形元素的情况下精确计算纵横比。 </dd>
<dd>
在并行计算中，返回值将有n_active_cells的长度，但长宽比只计算本地拥有的、分别放置在索引 <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">CellAccessor::active_cell_index()</a>, 的单元。所有其他的值都被设置为0。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00312">312</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aa6477e53e65dfbcaa0b2add902f4350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6477e53e65dfbcaa0b2add902f4350e">&#9670;&nbsp;</a></span>compute_maximum_aspect_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::compute_maximum_aspect_ratio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过取所有单元的最大值来计算最大长宽比。 </p><dl class="section note"><dt>Note</dt><dd>当与支持MPI的Triangulation并行运行时，这是一个集体调用，其返回值是所有处理器的最大值。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00378">378</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae1ec55abefa31cf001fd29d8d4d993f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ec55abefa31cf001fd29d8d4d993f1">&#9670;&nbsp;</a></span>compute_bounding_box() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt; GridTools::compute_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算包含整个三角形的最小的盒子。 如果输入的三角形是一个 <code><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></code>, ，那么每个处理器将计算一个包围所有本地拥有的、幽灵的和人工的单元的包围盒。在一个没有弯曲边界的域的情况下，这些边界盒在处理器之间都是一致的，因为人工和鬼魂单元所占据的区域的联合等于其他处理器拥有的单元所占据的区域的联合。 然而，如果域有弯曲的边界，情况就不再是这样了。 返回的边界盒可能适合于当前的处理器，但与其他处理器上计算的边界盒不同。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00394">394</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a350e00a4c5194b3007de4ea4bb13930b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350e00a4c5194b3007de4ea4bb13930b">&#9670;&nbsp;</a></span>project_to_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;Iterator::AccessorType::space_dimension&gt; GridTools::project_to_object </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>trial_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回几何对象 <code>object</code> 上最接近给定点 <code>trial_point</code>. 的点。例如，如果 <code>object</code> 是一条一维线或边，那么返回的点将是连接顶点的几何线上的一个点，因为与该对象相关的流形看到它（即，如果该几何线生活在高维空间，它可能是弯曲的）。如果迭代器指向高维空间中的四边形，那么返回的点位于相关流形所看到的四边形顶点的凸壳内。 </p><dl class="section note"><dt>Note</dt><dd>这种投影通常不是很好解决，因为对象上可能有多个点使距离最小化。这个函数中使用的算法是稳健的（而且输出保证在给定的 <code>object</code>) 上，但如果物体具有高曲率，可能只提供几个正确的数字。如果你的流形支持它，那么专门的函数 <a class="el" href="classManifold.html#a29c25e5d735160e0d846aab01d918e86">Manifold::project_to_manifold()</a> 可能表现得更好。 </dd></dl>

</div>
</div>
<a id="af06527a9436669439941b304ac073e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06527a9436669439941b304ac073e85">&#9670;&nbsp;</a></span>get_coarse_mesh_description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt;, <a class="el" href="structSubCellData.html">SubCellData</a> &gt; GridTools::get_coarse_mesh_description </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回定义三角网格的粗略网格的数组。这个函数是 <a class="el" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">Triangulation::create_triangulation()</a>. 的逆函数，返回值是一个包含顶点向量、单元向量和SubCellData结构的元组。后者包含关于面和线的额外信息。 这个函数在需要解构三角图或以某种方式操作顶点编号的情况下非常有用：一个例子是 <a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00534">534</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aa502b615730af32271d9da4206939a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa502b615730af32271d9da4206939a81">&#9670;&nbsp;</a></span>delete_unused_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_unused_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>删除不被任何单元格引用的顶点。这个函数被所有 <code>GridIn::read_*</code> 函数调用，以消除输入文件中列出的但不被输入文件中的单元所使用的顶点。虽然这些顶点从一开始就不应该出现在输入文件中，但有时会出现，最常见的是当一些单元格被手工删除而不想更新顶点列表时，因为它们可能很冗长。 这个函数被所有 <code>GridIn::read_*</code> 函数调用，因为三角形类要求它们只用已使用的顶点来调用。 因为顶点是由该类逐字复制的，所以我们必须事先消除未使用的顶点。 在维度为1的情况下没有实现。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00626">626</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a2fb09f2e9812f04661f9ca79e598e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb09f2e9812f04661f9ca79e598e197">&#9670;&nbsp;</a></span>delete_duplicated_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_duplicated_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>considered_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>移除重复的顶点，例如由于输入了结构化的网格而导致的。如果这些顶点没有被移除，这些顶点所包围的面会成为边界的一部分，即使它们在网格的内部。 这个函数被一些 <code>GridIn::read_*</code> 函数所调用。只有索引在 <code>considered_vertices</code> 中的顶点才会被测试是否相等。这加快了算法的速度，对于最坏的超立方体几何形状 \(O(N^{3/2})\) 的二维和 \(O(N^{5/3})\) 的三维，算法是相当慢的。 然而，如果你希望考虑所有顶点，只需传递一个空矢量。在这种情况下，该函数会将所有顶点填入 <code>considered_vertices</code> 。 如果两个顶点在每个坐标方向上的差异小于 <code>tol</code>. ，则认为它们是相等的。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00731">731</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a26e0f86b3a9310f1952cfe29e1fe7bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e0f86b3a9310f1952cfe29e1fe7bd4">&#9670;&nbsp;</a></span>invert_all_negative_measure_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::invert_all_negative_measure_cells </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>由网格生成器生成的网格可能有一个单元的方向，这个方向是deal.II要求的方向的倒数。 在2D和3D中，这个函数检查所有单元是否有负的或正的量度/体积。在前一种情况下，所有的单元格都是倒置的。在1d中，它没有任何作用。 当所有单元格中只有一个子集的体积为负时，单元格的反转也可能起作用。然而，由负向和正向单元混合组成的网格很可能被打破。因此，如果单元格的方向不一致，就会抛出一个异常。 </p><dl class="section note"><dt>Note</dt><dd>这个函数应该在 <a class="el" href="namespaceGridTools.html#a8d5f04ca06ef2667c468296f538716e7">GridTools::consistently_order_cells()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all_vertices</td><td>网格的顶点前调用。 </td></tr>
    <tr><td class="paramname">cells</td><td>描述网格拓扑结构的CellData对象的阵列。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l00863">863</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a8d5f04ca06ef2667c468296f538716e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5f04ca06ef2667c468296f538716e7">&#9670;&nbsp;</a></span>consistently_order_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::consistently_order_cells </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个描述网格的CellData对象的向量，重新排列其顶点，使所有线条的方向一致。 关于方向的期望和这个函数的讨论可以在 <a class="el" href="group__reordering.html">重新排序模块 </a> 中找到。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cells</td><td>描述网格拓扑结构的CellData对象的数组。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l01921">1921</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a212e99cf0d923cebfa04f1d23fa60b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212e99cf0d923cebfa04f1d23fa60b04">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Transformation , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::transform </td>
          <td>(</td>
          <td class="paramtype">const Transformation &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过对所有顶点应用作为第一个参数提供的函数对象来变换给定的三角网格的顶点。 作为参数给出的变换被用于变换每个顶点。 其各自的类型必须提供类似函数的语法，即谓词要么是一个具有<code>operator()</code>类型的对象，要么是一个指向函数的指针。在这两种情况下，参数和返回值都必须是<code><a class="el" href="classPoint.html">Point</a> &lt;spacedim&gt;</code>. 类型。 </p><dl class="section note"><dt>Note</dt><dd>与该函数一起使用的有意义的变换应该有一个具有正行列式的雅各布系数。例如，旋转、剪切、拉伸或缩放都满足这一点（尽管没有要求使用的变换实际上是线性的，因为所有这些例子都是）。另一方面，反射或反转有一个雅各布式的负行列式。目前的函数没有办法断定雅各布的正行列式，但是如果你碰巧使用了这样的变换，其结果将是一个单元格体积为负的三角结构。 </dd>
<dd>
如果你使用的是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> ，即使你的 "全局
"网格没有悬空节点，你的局部三角结构也会有悬空节点。如果你调用当前的函数，这将导致悬空节点在幽灵单元中的错误定位问题。所有本地拥有的单元的顶点将是正确的，但一些幽灵单元的顶点可能不是。这意味着像KellyErrorEstimator这样的计算可能会给出错误的答案。 </dd>
<dd>
这个函数一般来说与附加在三角形上的流形不兼容。例如，为了在网格转换后细化网格（使用流形），你必须确保原始流形对转换后的几何体仍然有效。这在一般情况下是不成立的，在这种情况下，有必要清除流形，并为转换后的几何体附加一个新的流形。 如果你想根据附加到三角形上的原始流形描述进行细化，你应该先进行细化，随后停用所有流形，最后再调用transform()函数。其结果是一个具有正确转换顶点的三角形，但在其他方面是直边元素。建议采用以下程序 <div class="fragment"><div class="line">...</div><div class="line">triangulation.refine_global(n_refinements);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">Transformation&lt;dim&gt; transformation;</div><div class="line"><a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(transformation, triangulation);</div><div class="line">...</div></div><!-- fragment --> 这个函数在 <a class="el" href="step_38.html">step-38</a> 的 "扩展的可能性
"部分中使用。它也在 <a class="el" href="step_49.html">step-49</a> 和 <a class="el" href="step_53.html">step-53</a> 中使用。 </dd></dl>

</div>
</div>
<a id="a4b953611883979e3f920f800bd855df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b953611883979e3f920f800bd855df3">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过给定的移位矢量对三角形的每个顶点进行移位。这个函数使用了上面的transform()函数，所以那里所说的对三角形的要求也适用于这个函数。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02022">2022</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a910bb99ec34eac082da97c08e7dd17c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910bb99ec34eac082da97c08e7dd17c3">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的二维三角结构的所有顶点围绕坐标系的原点逆时针旋转给定的角度（用弧度而不是度数给定）。这个函数使用了上面的transform()函数，所以那里所说的对三角形的要求也适用于这个函数。 </p><dl class="section note"><dt>Note</dt><dd>这个函数只支持dim=2的情况。 </dd></dl>

</div>
</div>
<a id="a580cbf329f016024a2e6b9d7eb9eed69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580cbf329f016024a2e6b9d7eb9eed69">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定 <code>triangulation</code> 的所有顶点以逆时针方向围绕给定索引的轴旋转。否则就像上面的函数一样。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>以弧度为单位，将三角函数旋转的角度。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>围绕坐标轴的索引，保持该坐标的固定（0=x轴，1=y轴，2=z轴）。 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">triangulation</td><td>要旋转的三角测量对象。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>对dim=1、2和3实施。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02031">2031</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">&#9670;&nbsp;</a></span>laplace_transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::laplace_transform </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>coefficient</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>solve_for_absolute_positions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的三角剖分平滑地转换到一个不同的域，通常，三角剖分边界的每个顶点都被映射到 <code>new_points</code> 地图中的相应点。 方向 \(u_d(\mathbf x)\) 的未知位移场 \(d\) 由受规定约束的最小化问题 </p><p class="formulaDsp">
\[ \min\, \int \frac{1}{2} c(\mathbf x) \mathbf \nabla u_d(\mathbf x) \cdot \mathbf \nabla u_d(\mathbf x) \,\rm d x \]
</p>
<p>获得。最小化器是通过解决位移场的dim分量的拉普拉斯方程得到的，该位移场将当前域映射成由 <code>new_points</code> 描述的域。使用线性有限元，每个方向上有四个高斯正交点。因此， <code>new_points</code> 中指定的顶点位置与 <code>tria</code> 中的当前值之间的差值代表该位移场在域边界的规定值，或者更准确地说，在 <code>new_points</code> 提供的所有位置（可能是在边界的一部分，甚至在域的内部）。然后，该函数在每个无约束的顶点上评估这个位移场，并使用它将映射的顶点放在位移场定位的地方。因为拉普拉斯方程的解是平滑的，这保证了从旧域到新域的平滑映射。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_points</td><td>要放置现有顶点的子集的位置。通常，这将是一个从边界上所有节点的顶点指数到其新位置的映射，从而完全指定了映射域的几何形状。然而，如果有必要，它也可以包括内部的点，而且它不需要包括所有的边界顶点（尽管你会失去对映射域的确切形状的控制）。 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>Triangulation对象。这个对象被就地改变，即之前的顶点位置被覆盖。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficient</td><td>拉普拉斯问题的可选系数。 较大的值使单元格不容易变形（有效地增加其刚度）。该系数是在三角形的旧的、未变形的配置的坐标系中作为输入进行评估的，也就是说，在应用变换之前。 如果提供这个函数，只有在所有的系数都是正数的情况下才能期望得到合理的结果。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solve_for_absolute_positions</td><td>如果设置为 <code>true</code> ，则最小化问题是针对最终顶点位置而非其位移制定的。这两个公式对于同质问题是等价的（默认值为 <code>coefficient</code>), ），但在其他情况下，它们会导致非常不同的网格运动。由于在大多数情况下，我们会在位移公式中使用一个非恒定系数，这个参数的默认值是 <code>false</code> 。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>这个功能目前还没有在1d情况下实现。 </dd></dl>

</div>
</div>
<a id="a1baa65a240caf7a5033f47b07b17f86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1baa65a240caf7a5033f47b07b17f86f">&#9670;&nbsp;</a></span>get_all_vertices_at_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; GridTools::get_all_vertices_at_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个 std::map 具有位于边界的所有顶点的面 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classTriangulation.html">Triangulation</a></td><td>对象。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02185">2185</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a0967563badadd81f77f62622dd8bc2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0967563badadd81f77f62622dd8bc2cd">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scaling_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>按给定的系数缩放整个三角图。为了保持三角形的方向，该因子必须是正的。 这个函数使用了上面的transform()函数，所以对三角形的要求也适用于这个函数。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02042">2042</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ac4e8aecd2cf74d3476e0daa11a00248b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e8aecd2cf74d3476e0daa11a00248b">&#9670;&nbsp;</a></span>distort_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::distort_random </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_boundary</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>seed</em> = <code>boost::random::mt19937::default_seed</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过随机移动网格中的所有顶点来扭曲给定的三角结构。 每个顶点的移动方向是随机的，而移位矢量的长度为 <code>factor</code> 乘以与此顶点相邻的活动边的最小长度。 注意， <code>factor</code> 显然应该远低于<code>0.5</code>。 如果 <code>keep_boundary</code> 被设置为 <code>true</code> （这是默认的），那么边界顶点不会被移动。 <code>seed</code> 用于随机引擎的初始化。它的默认值用以前版本的deal.II中的相同状态来初始化引擎。</p>
<p>Distort a triangulation in some random way. </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02217">2217</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a62b77b07123012706fbadf91d8f022b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b77b07123012706fbadf91d8f022b3">&#9670;&nbsp;</a></span>remove_hanging_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::remove_hanging_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从网格中移除悬挂的节点。如果 <code>isotropic</code> 参数设置为 <code>false</code> （默认值），该函数会检测到有悬空节点的单元格，并在去除悬空节点的方向上细化邻域。 如果 <code>isotropic</code> 参数设置为 <code>true</code>, ，则在每个方向上进行邻居细化。 为了去除所有悬空节点，这个过程必须重复进行：这可能需要大量的迭代。 为了避免这种情况，我们提供了一个最大的迭代数（ <code>max_iterations</code>) ）。 考虑以下网格。 </p><div class="image">
<img src="remove_hanging_nodes-hanging.png" alt="remove_hanging_nodes-hanging.png"/>
<div class="caption">
<code>isotropic</code> == <code>false</code> 将返回。  html remove_hanging_nodes-aniso.png <code>isotropic</code> == <code>true</code> 会返回。  html remove_hanging_nodes-isotro.png [in,out] tria Triangulation来细化。 [in] isotropic 如果为真，则在每个方向上细化单元，否则（默认值）则在删除悬挂节点的方向上细化单元。 [in] max_iterations 在每一步中，只有最接近悬挂节点的单元被精炼。该代码可能需要大量的迭代来移除所有悬空节点。 <code>max_iterations</code> 是允许的最大迭代数。如果 <code>max_iterations</code> == numbers::invalid_unsigned_int 这个函数继续精炼，直到没有悬空节点。</div></div>
 <dl class="section note"><dt>Note</dt><dd>在并行代码的情况下，该函数应与 <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a>. 相结合。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05084">5084</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a40336842aa2faac805746dc10c7c604f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40336842aa2faac805746dc10c7c604f">&#9670;&nbsp;</a></span>remove_anisotropy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::remove_anisotropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>max_ratio</em> = <code>1.6180339887</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>各向异性地细化一个网格，使得到的网格由尺寸间最大比率小于 <code>max_ratio</code>. 的单元组成，这个过程需要一个可能不会终止的算法。因此，可以通过 <code>max_iterations</code> 参数设置一个最大的迭代次数。 从这样的一个单元格开始。 </p><div class="image">
<img src="remove_anisotropy-coarse.png" alt="remove_anisotropy-coarse.png"/>
<div class="caption">
这个函数将返回。  html remove_anisotropy-refined.png [in,out] tria 要细化的三角图。 [in] max_ratio 每个单元的尺寸之间的比率允许的最大值。 [in] max_iterations 允许的最大迭代次数。</div></div>
 <dl class="section note"><dt>Note</dt><dd>如果是并行代码，该函数应与 <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a> 和 <a class="el" href="namespaceGridTools.html#a62b77b07123012706fbadf91d8f022b3">GridTools::remove_hanging_nodes</a>. 相结合。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05117">5117</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a3f129213c63c92a6ed84c6f2a906048b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f129213c63c92a6ed84c6f2a906048b">&#9670;&nbsp;</a></span>regularize_corner_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::regularize_corner_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>limit_angle_fraction</em> = <code>.75</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>分析网格的边界单元，如果发现有一个单元位于角的位置（边界上有昏暗的相邻面），并且其二维角度分数超过 <code>limit_angle_fraction</code>, ，则全局细化一次，并且用角不再违反给定角度分数的子单元替换该单元的子单元。 如果不存在边界上有两个相邻面的边界单元，那么三角形就不会被触动。如果我们确实有边界上有dim相邻面的单元，那么将根据参数 <code>limit_angle_fraction</code>. 检查dim-dimensional实体角和dim*pi/2之间的分数，如果它更高，网格将被细化一次，并且违规单元的子单元将被替换成一些尊重极限的单元。 在这个过程之后，三角形被压平，所有的Manifold对象都被恢复到原来的三角形中。 以下的网格就是一个例子，它是将一个SphericalManifold附加到使用 <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>: 生成的网格上而得到的。 </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div></div><!-- fragment --> <div class="image">
<img src="regularize_mesh_01.png" alt="regularize_mesh_01.png"/>
</div>
 <p>四个原本是正方形的角的单元在计算过程中会给你带来一些麻烦，因为从参考单元到这些单元的变换的贾可宾会归零，影响有限元估计的误差常数。 那些单元格的角非常接近180度，也就是说，角分值非常接近1。 同样的代码，加入对regularize_corner_cells的调用。 </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div><div class="line"><a class="code" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a>(tria);</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div></div><!-- fragment --><p> 生成的网格在Mapping的jacobian方面有更好的表现。 </p>
<div class="image">
<img src="regularize_mesh_02.png" alt="regularize_mesh_02.png"/>
</div>
 <p>这个网格与 <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>. 得到的网格非常相似。然而，使用 <a class="el" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a> 可以自由选择何时应用正则化，也就是说，原则上可以先细化几次，然后再调用regularize_corner_cells函数。 </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line"><a class="code" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a>(tria);</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div></div><!-- fragment --><p> 这就产生了下面的网格。 </p>
<div class="image">
<img src="regularize_mesh_03.png" alt="regularize_mesh_03.png"/>
</div>
 <p>这个函数目前只在dim = 2的情况下实现，如果在dim = 3的情况下调用，会产生一个异常。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>正则化的三角图。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit_angle_fraction</td><td>网格中的角元素允许的最大角度或实体角度的比率。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05146">5146</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a8e8bb9211264d2106758ac4d7184117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8bb9211264d2106758ac4d7184117e">&#9670;&nbsp;</a></span>compute_point_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::compute_point_locations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim,&#160;spacedim&gt;::active_cell_iterator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个三角形的 <code>cache</code> 和一个 <code>points</code>, 的列表，在 <code>points</code>, 的每个元素上调用 <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">find_active_cell_around_point()</a> 并返回 <code>cells</code>, 参考位置 <code>qpoints</code>, 和一个从局部到全局索引的映射 <code>maps</code> 到 <code>points</code> 。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">缓存</td><td>三角形的 <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">点</td><td>点的向量。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_hint</td><td>(可选) 可能包含 <code>points</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>的第一个点的单元格迭代器 包含以下信息。</dd></dl>
<ul>
<li><code>cells</code> : 所有包含至少一个 <code>points</code> 的单元格的向量。</li>
<li><code>qpoints</code> : 一个点的向量。 <code>qpoints</code>[i] 包含落在单元格内的所有点的参考位置 <code>cells</code>[i] 。</li>
<li><code>indices</code> : 一个整数向量，包含 <code>qpoints</code> 中的局部编号，和 <code>points</code> 中的全局索引之间的映射。 如果 <code>points</code>[a] 和 <code>points</code>[b] 是落在 <code>cells</code>[c], 中的唯一两个点，那么 <code>qpoints</code>[c][0] 和 <code>qpoints</code>[c][1] 是 <code>points</code>[a] 和 <code>points</code>[b] 在 <code>cells</code>[c], 和 <code>indices</code>[c][0] 的参考位置。 ]=a， <code>indices</code>[c][1] =b。函数 Mapping::transform_unit_to_real(qpoints[c][0]) 返回 <code>points</code>[a]. 。算法建立了一个 <code>points</code> 的rtree，对它们进行空间排序，然后尝试调用find_active_cell_around_point（）。 <dl class="section note"><dt>Note</dt><dd>这个函数没有在二维一的情况下实现（<code>spacedim != dim</code>）。 </dd>
<dd>
如果一个点在网格内没有找到，或者位于一个 <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>, 的人工单元内，这个点会被默默地忽略掉。如果你想推断哪些点的搜索失败了，请使用函数compute_point_locations_try_all()，该函数也会返回一个索引的向量，表示搜索失败的点。 </dd>
<dd>
这个函数的实际返回类型，即上面提到的 <code>return_type</code>, 的类型是 <div class="fragment"><div class="line">std::tuple&lt;</div><div class="line">std::vector&lt;</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim, spacedim&gt;::active_cell_iterator</a>&gt;,</div><div class="line">std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div><div class="line">std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;</div></div><!-- fragment --> 在线文档中对该类型进行了缩写，以提高本页面的可读性。 </dd>
<dd>
这个函数通过利用 <a class="el" href="classGridTools_1_1Cache.html#aca2782d6e93b5a0033c046b57904c67f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>, 来优化搜索，该函数要么返回一个缓存的rtree，要么建立并存储一个。如果该函数只在少数几个点上调用一次，建立一个rtree可能会妨碍性能。 </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05461">5461</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a5a845642f4d205352931267b58055d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a845642f4d205352931267b58055d62">&#9670;&nbsp;</a></span>compute_point_locations_try_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::compute_point_locations_try_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim,&#160;spacedim&gt;::active_cell_iterator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数与 <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>, 类似，但是compute_point_locations()默默地忽略了所有find_active_cell_around_point()失败的点，这个函数也返回一个包含find_active_cell_around_point()失败的点的索引的向量。 </p><dl class="section return"><dt>Returns</dt><dd>一个包含四个元素的元组；前三个元素在 <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>. 中有记录。 <code>return_type</code> 的最后一个元素包含了既没有在网格内发现也没有位于人工单元内的点的索引。 <code>return_type</code> 等于以下元组类型。 <div class="fragment"><div class="line">std::tuple&lt;</div><div class="line">  std::vector&lt;</div><div class="line">     <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim,spacedim&gt;::active_cell_iterator</a>&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">&gt;</div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>这个函数在二维一的情况下没有实现（<code>spacedim != dim</code>）。 </dd>
<dd>
这个函数通过使用 <a class="el" href="classGridTools_1_1Cache.html#aca2782d6e93b5a0033c046b57904c67f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>, 来优化搜索，该函数要么返回一个缓存的rtree，要么建立并存储一个。如果该函数只在少数几个点上调用一次，建立一个rtree可能会妨碍性能。 更详细的文档见 <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>. 。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05490">5490</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="afe6eff31d194dd4beafc9eb6a22c5e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6eff31d194dd4beafc9eb6a22c5e27">&#9670;&nbsp;</a></span>distributed_compute_point_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::distributed_compute_point_locations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_bboxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个 <code>cache</code> 和每个进程的 <code>local_points</code> 列表，找到位于网格本地拥有部分的点并计算它们的正交规则。 分布式计算点位置是一个类似于 <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> 的函数，但对 <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> 对象起作用，而且，与它的序列版本不同，也适用于分布式三角测量（见 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">缓存一个</td><td><a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> 对象 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_points是当前进程拥有的点的阵列。</td><td>每个进程可以有一个不同的点阵列，这个阵列可以是空的，不包含在三角形的本地拥有的部分内 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bboxes</td><td>一个边界盒的向量；它描述了每个进程的网格的本地拥有部分。global_boxes[rk]中包含了描述网格的哪一部分被等级为rk的进程局部拥有的界线盒。局部描述可以从 <a class="el" href="namespaceGridTools.html#a08438d4ad901817b7b638ce733fd664d">GridTools::compute_mesh_predicate_bounding_box</a>; 中获得，然后全局描述可以通过 <a class="el" href="namespaceGridTools.html#a3843115e3b2380ce9980335c0454a804">GridTools::exchange_local_bounding_boxes</a> 或 <a class="el" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a> 获得 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">容差</td><td>以单元格坐标计算的容差。根据问题的不同，可能需要调整公差，以便能够确定一个单元。浮点运算意味着，一般来说，一个点不会完全位于一个顶点、边缘或面。在任何一种情况下，都无法预测这个函数会返回哪个与顶点或边/面相邻的单元。 因此，调用这个函数的算法需要考虑到，返回的单元格将只包含近似的点。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个包含正交信息的元组 输出元组的元素是。</dd></dl>
<ul>
<li>cells : 所有包含至少一个点的单元格的向量。</li>
<li>qpoints : 一个点的向量；包含在 <code>qpoints</code>[i] 中的所有点的参考位置，这些点位于单元格 <code>cells</code>[i] 中。</li>
<li>maps : 一个整数向量，包含qpoints中的编号（元组的前一个元素）与拥有这些点的过程的局部点向量之间的映射。</li>
<li>points : 一个点的向量。 <code>points</code>[i][j] 是实空间中对应于 <code>qpoints</code>[i][j] 的点。注意 <code>points</code> 是位于网格本地所有部分的点；因此这些可以是 <code>local_points</code> 的副本或从其他进程收到的点，即其他进程的本地_点</li>
<li>owners : 一个向量的向量； <code>owners</code>[i][j] 包含拥有point[i][j]的进程的等级（元组的前一个元素）。 该函数使用三角形的mpi通信器：由于这个原因，如果三角形不是从 <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> 派生的，它会抛出一个断言错误。 在一个串行执行中，元组的前三个元素与 <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> 中的相同。 注意：这个函数是一个集体操作。 <dl class="section note"><dt>Note</dt><dd>这个函数的实际返回类型，即上面提到的 <code>return_type</code>, 的类型是 <div class="fragment"><div class="line">std::tuple&lt;</div><div class="line">std::vector&lt;</div><div class="line">  <span class="keyword">typename</span> Triangulation&lt;dim, spacedim&gt;::active_cell_iterator&gt;,</div><div class="line">std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div><div class="line">std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div><div class="line">std::vector&lt;std::vector&lt;Point&lt;spacedim&gt;&gt;&gt;,</div><div class="line">std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;</div></div><!-- fragment --> 在线文档中对该类型进行了缩写，以提高本页面的可读性。 </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05658">5658</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a30077cfce9e6234e386fbd4286bc2dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30077cfce9e6234e386fbd4286bc2dd7">&#9670;&nbsp;</a></span>extract_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; GridTools::extract_used_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;dim&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.template&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;dim,&#160;spacedim&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个地图`顶点索引</p>
<p>-&gt; <a class="el" href="classPoint.html">Point&lt;spacedim&gt;</a><code>，包含给定的</code>容器'的使用顶点。返回的地图的键（即上面一对的第一个元素）是三角形中的全局索引，而每一对的值是对应顶点的物理位置。使用的顶点是通过在所有单元中循环得到的，并通过（可选）<code>mapping</code>参数查询每个单元的顶点在哪里。 在序列Triangulation对象和 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 对象中，返回的地图大小等于 <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a> （而不是 <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a>). 注意，在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象中，只返回本地拥有的单元和幽灵单元中的顶点，因为所有其他顶点的真实位置可能不知道（例如，对于使用MappingQEulerian的分布计算）。 如果你使用默认的`mapping'，返回的地图满足以下等价关系。 </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> used_vertices = <a class="code" href="namespaceGridTools.html#a30077cfce9e6234e386fbd4286bc2dd7">extract_used_vertices</a>(tria);</div><div class="line"><span class="keyword">auto</span> all_vertices = tria.<a class="code" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;id_and_v : used_vertices)</div><div class="line">all_vertices[id_and_v.first] == id_and_v.second; <span class="comment">// true</span></div></div><!-- fragment --><p> 注意，对于改变顶点位置的映射，如MappingQEulerian，则不满足上述规定。 MeshType概念 。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>要提取顶点的容器。 </td></tr>
    <tr><td class="paramname">mapping</td><td>用来计算点的位置的映射。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06210">6210</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a1f49d6a42c3dbabc53a86571e874cc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f49d6a42c3dbabc53a86571e874cc3f">&#9670;&nbsp;</a></span>find_closest_vertex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在作为第一个参数传递的顶点映射中，查找并返回离给定点最近的顶点的索引。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>索引-&gt;顶点的地图，如 <a class="el" href="namespaceGridTools.html#a30077cfce9e6234e386fbd4286bc2dd7">GridTools::extract_used_vertices()</a>. </td></tr>
    <tr><td class="paramname">p</td><td>目标点。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>最接近目标点<code>p</code>的顶点的索引。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06229">6229</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a07919e120e98a6a0139ffe8c9f4a2a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07919e120e98a6a0139ffe8c9f4a2a8b">&#9670;&nbsp;</a></span>find_closest_vertex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>查找并返回给定网格中最接近给定点的已使用顶点（或标记顶点）的索引。 这个函数使用存储在三角结构中的顶点位置。这通常是足够的，除非你使用一个移动顶点的Mapping（例如，MappingQEulerian）。在这种情况下，你应该用相同的名字和额外的Mapping参数来调用这个函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>一个满足 MeshType概念  要求的类型的变量。 </td></tr>
    <tr><td class="paramname">p</td><td>我们想找到最接近的顶点的点。 </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>表示 <code>mesh</code> 的哪些顶点将在搜索中被视为潜在的最近顶点的一个布尔数组。当收到一个非空的 <code>marked_vertices</code>, 时，该函数将只在 <code>marked_vertices</code> 中搜索最接近的顶点。 这个数组的大小应该等于 <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> 对给定网格的三角结构返回的值（而不是 <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>). 返回的值） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>找到的最接近顶点的索引。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02440">2440</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a84f7b02080d7740cdb0fe73f3917af36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f7b02080d7740cdb0fe73f3917af36">&#9670;&nbsp;</a></span>find_closest_vertex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的网格中找到并返回最接近给定点的已使用顶点（或标记顶点）的索引。使用给定的映射来计算顶点的实际位置。 如果Mapping不修改网格顶点的位置（例如，MappingQEulerian），那么这个函数等同于同名的函数，并且没有<code>mapping</code>参数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>用于计算顶点位置的映射 </td></tr>
    <tr><td class="paramname">mesh</td><td>一个满足 MeshType概念  要求的类型的变量。 </td></tr>
    <tr><td class="paramname">p</td><td>我们想找到最近的顶点的点。 </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>表示 <code>mesh</code> 的哪些顶点将在搜索中被视为潜在的最近顶点的一个布尔数组。当收到一个非空的 <code>marked_vertices</code>, 时，该函数将只在 <code>marked_vertices</code> 中搜索最接近的顶点。 这个数组的大小应该等于 <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> 对给定网格的三角结构返回的值（而不是 <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>). 返回的值） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>找到的最接近顶点的索引。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02506">2506</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="addb822f0e3068e48640ecc981ee6c1e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb822f0e3068e48640ecc981ee6c1e6">&#9670;&nbsp;</a></span>find_cells_adjacent_to_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &gt; GridTools::find_cells_adjacent_to_vertex </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>找到并返回一个迭代器的向量，这些迭代器围绕着给定顶点的索引 <code>vertex_index</code>. 对于局部细化网格，顶点本身可能不是返回的所有相邻单元的顶点。然而，它将始终是一个单元的顶点，或者是位于面或边上的一个悬挂节点。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">容器</td><td>一个满足 MeshType概念  要求的类型的变量。 </td></tr>
    <tr><td class="paramname">vertex_index</td><td>我们试图找到相邻单元的顶点的索引。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>与给定顶点相邻的单元格的一个向量。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>目前还不完全清楚该函数是否对各向异性的细化网格做出正确的处理。它需要对这种情况进行检查。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02568">2568</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a2e10aeb1c8e76110a84b6945eac3aaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e10aeb1c8e76110a84b6945eac3aaf0">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>查找围绕给定点的活动非人工单元 <code>p</code>. 返回类型是一对活动单元的迭代器以及该点的单元坐标。 这个函数使用的算法是首先寻找最接近给定点的顶点，见 <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>. 其次，在网格中找到这个顶点的所有相邻单元，见 <a class="el" href="namespaceGridTools.html#addb822f0e3068e48640ecc981ee6c1e6">GridTools::find_cells_adjacent_to_vertex()</a>. 最后，对于每个单元，函数测试点是否在里面。这个检查是使用给定的 <code>mapping</code> 参数来确定单元的边界是直的还是弯的。 如果一个点位于两个或多个单元的边界上，那么该算法将试图确定细化程度最高的那个单元。 <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">如果请求的点不在本地拥有的单元或幽灵单元中，那么这个函数将返回（无效的）MeshType&lt;dim,  spacedim&gt;::end()</a> 迭代器。这种情况可以类似于各种 <code>std::find()</code> 和 <code><a class="el" href="namespaceUtilities.html#aaa0f9cd449850bf25160131cc4bc5668">std::lower_bound()</a></code> 函数的处理方式。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">映射</td><td>用于确定给定点是否在给定单元内的映射。 </td></tr>
    <tr><td class="paramname">mesh</td><td>一个满足 MeshType概念  要求的类型的变量。 </td></tr>
    <tr><td class="paramname">p</td><td>我们想找到周围单元的点。 </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>一个`bool'数组，表示顶点数组中的某个条目是否应该被视为（而其他的必须被忽略）可能是离指定点最近的顶点。在指定一个非默认的 <code>marked_vertices</code>, 时，find_closest_vertex()只会在 <code>marked_vertices</code> 中搜索最近的顶点。 这个数组的大小应该等于三角形的n_vertices()（而不是n_used_vertices()）。使用 <code>marked_vertices</code> 的动机是为了减少顶点的搜索空间，如果人们对感兴趣的点可能接近的顶点集合有先验的了解。 </td></tr>
    <tr><td class="paramname">容差</td><td>以单元格坐标为单位的容差。根据问题的不同，可能有必要调整公差，以便能够识别一个单元。浮点运算意味着，一般来说，一个点不会完全位于一个顶点、边缘或面。在任何一种情况下，都无法预测这个函数会返回哪个与顶点或边/面相邻的单元。 因此，调用这个函数的算法需要考虑到，返回的单元格将只包含点的近似值。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一对进入网格的迭代器，指向周围的单元格，以及该点的单元格坐标。由于数字上的舍入，这个局部位置可能位于实际单元格之外。因此，这个函数返回的点应该被投影到单元格上，使用 <a class="el" href="structGeometryInfo.html#aaae0fe397acba1d1079cbfa917b7046c">GeometryInfo::project_to_unit_cell()</a>. 这不是由算法自动执行的。返回的单元格可以是本地拥有的单元格或幽灵单元格（但不是人造单元格）。即使给定的点是本地拥有的单元格的一个顶点，返回的单元格也可能是一个幽灵单元。 背后的原因是，这是保证所有参与平行三角形计算的处理器都同意哪个单元包含一个点的唯一方法。例如，如果两个处理器聚集在一个顶点，并且用这个顶点调用该函数，那么一个处理器将返回一个本地拥有的单元，另一个则返回一个幽灵单元。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00436">436</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a9df2272fe8a72156bc2628aa07c5123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df2272fe8a72156bc2628aa07c5123e">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType&lt; dim, spacedim &gt;::active_cell_iterator GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的一个版本，假定边界是直的，因此只是用MappingQ1作为映射参数调用上述函数。 </p><dl class="section return"><dt>Returns</dt><dd>一个进入网格的迭代器，指向周围的单元。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00412">412</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="ad9b6a71ae04417bd4b1a3d6d237557f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b6a71ae04417bd4b1a3d6d237557f1">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>另一个版本，我们在一个给定的单元上使用该映射，该映射对应于该单元的活动有限元索引。 这显然只对hp-problems有用，因为所有其他DoF处理程序的活动有限元索引总是零。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01258">1258</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a59f673ed723568e41c72a3634e4d12db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f673ed723568e41c72a3634e4d12db">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim,&#160;spacedim&gt;::active_cell_iterator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在一个点周围寻找一个活跃的非人工单元在计算成本上可能是非常昂贵的。这个函数旨在通过使用空间树来加速几何体的搜索，提供上述函数的快速版本。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>包含三角形空间树信息的对象，见 <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>. </td></tr>
    <tr><td class="paramname">p</td><td>我们要为其寻找周围的单元。 </td></tr>
    <tr><td class="paramname">cell_hint</td><td>给出几何搜索的提示，如果有关于该点可能位于哪个单元的先验知识，这将是有益的。一个典型的用例是，这个搜索必须针对一个相互靠近的点的阵列，并且前一个点的相邻单元是阵列中下一个点的良好提示。 </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>见上文。 </td></tr>
    <tr><td class="paramname">tolerance</td><td>见上文。 下面的代码示例显示了如何使用这个函数。 <div class="fragment"><div class="line"><a class="code" href="classGridTools_1_1Cache.html">GridTools::Cache&lt;dim, dim&gt;</a> cache(triangulation, mapping);</div><div class="line"><span class="keyword">auto</span> cell_hint = <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation&lt;dim, dim&gt;::active_cell_iterator</a>();</div><div class="line">std::vector&lt;bool&gt; marked_vertices = {};</div><div class="line"><span class="keywordtype">double</span> tolerance = 1.e-10;</div><div class="line"></div><div class="line">std::vector&lt;Point&lt;dim&gt;&gt; points; <span class="comment">// a vector of many points</span></div><div class="line">...</div><div class="line"></div><div class="line">for(<span class="keyword">auto</span> p : points)</div><div class="line">{</div><div class="line"><span class="keyword">auto</span> cell_and_ref_point = <a class="code" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>(</div><div class="line">  cache, p, cell_hint, marked_vertices, tolerance);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (cell_and_ref_point.first != triangulation.<a class="code" href="classTriangulation.html#afdbd22694fb7591e822577a8f8a90de9">end</a>())</div><div class="line">  {</div><div class="line">   <span class="comment">// use current cell as hint for the next point</span></div><div class="line">   cell_hint = cell_and_ref_point.first;</div><div class="line">   <span class="comment">// do something with cell_and_ref_point</span></div><div class="line">   ...</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line"> {</div><div class="line">    <span class="comment">// The function did not find a locally owned or ghost cell in which</span></div><div class="line">    <span class="comment">// the point is located. We ought to handle this somehow here.</span></div><div class="line"> }</div><div class="line">...</div><div class="line">}</div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06246">6246</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a2881f45ff9aa67db94aeb46437797cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2881f45ff9aa67db94aeb46437797cf4">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::set&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_cell_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_cell_centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;MeshType&lt;dim,&#160;spacedim&gt;::active_cell_iterator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>used_vertices_rtree</em> = <code><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;std::pair&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;,&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&gt;&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; *&#160;</td>
          <td class="paramname"><em>relevant_cell_bounding_boxes_rtree</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>前一个函数的一个版本，利用顶点和单元格之间已经存在的映射（使用函数 <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a>), 构建一个顶点_到单元格_中心的映射（通过 <a class="el" href="namespaceGridTools.html#a79eddc6b744c7c83d9bc020dfa509e19">GridTools::vertex_to_cell_centers_directions()</a>), 获得，也可以选择从三角结构的使用顶点构建的RTree。 </p><dl class="section note"><dt>Note</dt><dd>所有这些结构都可以从一个 <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> 对象中查询到。但是请注意，在这种情况下，MeshType必须是Triangulation，所以在这种情况下，直接调用上面的函数，参数为`cache'可能更合适。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02782">2782</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aef086f558e9e1c6148e3fa8c62e7a066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef086f558e9e1c6148e3fa8c62e7a066">&#9670;&nbsp;</a></span>find_all_active_cells_around_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; GridTools::find_all_active_cells_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相比，这个函数以单位坐标的方式识别一个给定的容忍度<code>tolerance</code>的点周围所有活跃的非人工单元。给定一个参考坐标为参数 <code>first_cell</code>, 的第一个单元，例如通过上面的一个函数得到的，所有相应的具有单位坐标点的邻近单元也被确定。 这个函数对不连续函数空间很有用，例如，对于给定的点<code>p</code>位于一个顶点、边缘或面的情况，几个单元可能持有独立的解的值，在用户代码中以某种方式组合。 这个函数的使用方法如下 </p><div class="fragment"><div class="line"><span class="keyword">auto</span> first_pair = <a class="code" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>(...);</div><div class="line"><span class="keyword">auto</span> all_cells  = <a class="code" href="namespaceGridTools.html#aef086f558e9e1c6148e3fa8c62e7a066">GridTools::find_all_active_cells_around_point</a>(</div><div class="line">                           mapping, mesh, p, tolerance, first_pair);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00599">599</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="af7daaed7cdd68d2b8f70d2dde1df3061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7daaed7cdd68d2b8f70d2dde1df3061">&#9670;&nbsp;</a></span>find_all_active_cells_around_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt; GridTools::find_all_active_cells_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>前一个函数的变体，在内部调用其中一个函数find_active_cell_around_point()来获得第一个单元，随后通过调用上面的函数find_all_active_cells_around_point()来增加所有其他活跃的非人工单元。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00571">571</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="ab5c182c1901bb0d09046271809f918c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c182c1901bb0d09046271809f918c6">&#9670;&nbsp;</a></span>get_active_child_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType::active_cell_iterator&gt; GridTools::get_active_child_cells </td>
          <td>(</td>
          <td class="paramtype">const typename MeshType::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定单元格的所有活跃的后代的列表。例如，如果当前单元格曾经被精炼过，但是它的子代没有任何进一步的精炼，那么返回的列表将包含它的所有子代。 如果当前单元格已经被激活，那么返回的列表是空的（因为该单元格没有可能被激活的子代）。 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>一个满足 MeshType概念  要求的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>指向Mesh的一个单元的迭代器。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>给定单元格的活动子孙列表。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>因为在C++中MeshType模板参数不能从函数调用中推导出来，所以你必须在函数名称后面指定它，例如 <div class="fragment"><div class="line">GridTools::get_active_child_cells&lt;DoFHandler&lt;dim&gt; &gt; (cell)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a30ccceb7c9216efc44dd4af561e0bea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ccceb7c9216efc44dd4af561e0bea0">&#9670;&nbsp;</a></span>get_active_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_active_neighbors </td>
          <td>(</td>
          <td class="paramtype">const typename MeshType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename MeshType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取给定单元格 <code>cell</code> 周围的活动单元，并在向量 <code>active_neighbors</code>. 中返回这些邻居，这些邻居具体是指单元格的<em>face</em>邻居，如果该邻居被进一步细化，则是其与该面交界的活动子女。另一方面，返回的邻居不包括那些位于，例如，与一个顶点对角线相对但本身不是面的邻居的单元。在3D中，它也不包括与当前单元格的一条边相邻，但不是面的邻居的单元格）。 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>一个满足 MeshType概念  要求的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>一个指向Mesh中某一单元的迭代器。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">active_neighbors</td><td>指向给定单元格的活跃子孙的列表。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>因为在C++中，MeshType模板参数不能从函数调用中推导出来，你必须在函数名称后指定它，例如 <div class="fragment"><div class="line">GridTools::get_active_neighbors&lt;DoFHandler&lt;dim&gt;&gt;(cell, active_neighbors)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a51acc74a2c56fc9cab517235be235cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51acc74a2c56fc9cab517235be235cdc">&#9670;&nbsp;</a></span>compute_active_cell_halo_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_active_cell_halo_layer </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取并返回 <code>mesh</code> 中的子域（活动单元的集合）周围的活动单元层（即那些与子域共享一组顶点但不属于子域的单元）。在这里，"子域
"恰好包括 <code>谓词返回</code> <code>true</code>. 的所有单元。 一个自定义谓词的例子是检查一个给定的材料id </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span></div><div class="line">pred_mat_id(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> &amp; cell)</div><div class="line">{</div><div class="line"><span class="keywordflow">return</span> cell-&gt;material_id() ==  1;</div><div class="line">}</div></div><!-- fragment --><p> 然后我们可以通过以下调用提取这个材料周围的细胞层。 </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(tria, pred_mat_id&lt;dim&gt;);</div></div><!-- fragment --><p> 经常有用的谓词可以在命名空间IteratorFilters中找到。例如，可以提取所有具有给定材料ID的细胞周围的细胞层。 </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(</div><div class="line">tria, <a class="code" href="classIteratorFilters_1_1MaterialIdEqualTo.html">IteratorFilters::MaterialIdEqualTo</a>(1, <span class="keyword">true</span>));</div></div><!-- fragment --><p> 或者在具有hp-capabilities的DoFHandler的一组活动FE指数的所有单元周围提取一层单元。 </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a51acc74a2c56fc9cab517235be235cdc">GridTools::compute_active_cell_halo_layer</a>(</div><div class="line">hp_dof_handler, <a class="code" href="classIteratorFilters_1_1ActiveFEIndexEqualTo.html">IteratorFilters::ActiveFEIndexEqualTo</a>({1,2}, <span class="keyword">true</span>));</div></div><!-- fragment --><p> 注意，在最后两个例子中，我们确保谓词只对本地拥有的单元返回真。这意味着光环层将不包含任何人工单元。 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>一个满足 MeshType概念  要求的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>一个网格（即Triangulation或DoFHandler类型的对象）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">谓词</td><td>一个函数（或带有operator()的类型对象），定义要提取晕层的子域。它是一个接收活动单元并返回一个布尔值的函数。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个与所指子域至少有一个共同顶点的活动单元的列表。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00738">738</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a98e89706e7e925b16d42d288c462e9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e89706e7e925b16d42d288c462e9d8">&#9670;&nbsp;</a></span>compute_cell_halo_layer_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::cell_iterator &gt; GridTools::compute_cell_halo_layer_on_level </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取并返回 <code>mesh</code> 指定层次上的子域（单元格集合）周围的单元格层（即该层次上与子域共享一组共同顶点但不属于子域的那些单元格）。在这里，"子域
"恰好由 <code>predicate</code> 返回 <code>true</code>. 的所有单元组成。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00775">775</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a6d0674004143aed7f492a3ae7bcb2e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0674004143aed7f492a3ae7bcb2e3d">&#9670;&nbsp;</a></span>compute_ghost_cell_halo_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_ghost_cell_halo_layer </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取并返回幽灵单元，这些单元是所有本地拥有的单元周围的活动单元层。这与 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 最为相关，它将返回一个处理器上所有幽灵单元的子集，但对于 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 来说，这将返回所有的幽灵单元。 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>一个满足 MeshType概念  要求的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>一个网格（即Triangulation或DoFHandler类型的对象）。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个幽灵单元的列表。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00856">856</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a599f59fd9beccda86d7980c30a9b1f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599f59fd9beccda86d7980c30a9b1f6a">&#9670;&nbsp;</a></span>compute_active_cell_layer_within_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_active_cell_layer_within_distance </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>layer_thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l00878">878</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="aa21d10102639460701c67f7e79afc06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21d10102639460701c67f7e79afc06f">&#9670;&nbsp;</a></span>compute_ghost_cell_layer_within_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::active_cell_iterator &gt; GridTools::compute_ghost_cell_layer_within_distance </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>layer_thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提取并返回一组幽灵单元，这些单元在所有本地拥有的单元周围的 <code>layer_thickness</code> 内。 这与 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 最相关，它将返回一个进程中所有幽灵单元的子集，但对于 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 这将返回所有的幽灵单元。 对于 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 类来说，所有不属于当前处理器的单元格都可以被认为是幽灵单元格；特别是，它们不仅仅是在本地拥有的单元格周围形成一个单层。 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>一个满足 MeshType概念  要求的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>一个网格（即Triangulation或DoFHandler类型的对象）。 </td></tr>
    <tr><td class="paramname">layer_thickness</td><td>指定函数从本地拥有的单元中搜索活动单元的几何距离。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>在给定的几何距离 <code>layer_thickness内的鬼魂单元子集与当前进程的本地拥有的单元。</code> 参见compute_ghost_cell_halo_layer() 和 <a class="el" href="namespaceGridTools.html#a599f59fd9beccda86d7980c30a9b1f6a">compute_active_cell_layer_within_distance()</a>。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01022">1022</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a0374dd9eae73c3c2badaa479e8ba8d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0374dd9eae73c3c2badaa479e8ba8d55">&#9670;&nbsp;</a></span>compute_bounding_box() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt;, <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt; &gt; GridTools::compute_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算并返回一个通过左下角和右上角的一对点定义的包围盒，该包围盒围绕着 <code>mesh</code>. 的一个子域。这里，"子域 "恰好由 <code>predicate</code> 返回 <code>true</code>. 的所有活动单元组成。 关于 <code>predicate</code> 如何工作的描述，见compute_active_cell_halo_layer（）。 </p><dl class="section note"><dt>Note</dt><dd>这个函数是在BoundingBox类被发明之前写的。 因此，它返回一对点，而不是人们期望的BoundingBox对象。然而，BoundingBox有一个从点对转换的构造函数，所以这个函数的结果仍然可以被分配给一个BoundingBox对象。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01058">1058</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a08438d4ad901817b7b638ce733fd664d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08438d4ad901817b7b638ce733fd664d">&#9670;&nbsp;</a></span>compute_mesh_predicate_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; MeshType::space_dimension &gt; &gt; GridTools::compute_mesh_predicate_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>refinement_level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_merge</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_boxes</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个边界框的集合，使所有给定谓词为真的活动单元都完全被包围在至少一个边界框中。请注意，这个包围只保证包含所有这些活动单元，但它不一定是精确的，也就是说，它可以包括比它们的联合体更大的区域。 对于一个给定的细化级别中包含 <code>predicate</code> 为真的活动单元的每个单元，该函数创建一个 <code>predicate</code> 为真的子单元的边界盒。 这导致了对 <code>predicate</code> 为真的所有活动单元的覆盖；参数 <code>allow_merge</code> 和 <code>max_boxes</code> 用于减少计算成本的单元数量，覆盖更大的n维体积。 控制该算法的参数是。</p>
<ul>
<li><code>predicate</code> : 要包围的单元格的属性，例如 <a class="el" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a> 。 该谓词仅在活动单元格上进行测试。</li>
<li><code>refinement_level</code> : 它定义了创建初始边界盒的级别。细化应该被设置为粗略的细化级别。如果 <code>refinement_level</code> 高于三角形的层数，将为每个活动单元创建一个比 <code>refinement_level</code>; 更粗的包围盒，将产生一个异常。</li>
<li><code>allow_merge</code> : 这个标志允许盒子合并，默认为假。该算法的成本为O(N^2)，其中N是由细化级别创建的边界盒的数量；由于这个原因，如果该标志被设置为真，请确保明智地选择一个足够粗的 <code>refinement_level</code>.</li>
<li><code>max_boxes</code> : 要计算的边界盒的最大数量。如果创建了更多的盒子，那么小的盒子就会与相邻的盒子合并。默认情况下，在合并了可以表示为一个的盒子后，不再合并更多的盒子。详见 <a class="el" href="classBoundingBox.html#a2ee80a34bb8b1d1b6727959e8ef992ad">BoundingBox::get_neighbor_type</a> （）函数。 注意只有相邻的单元格会被合并（见边界盒类中的 <code>get_neighbor_type</code> 函数）：如果边界盒的目标数量max_boxes不能通过合并相邻的单元格来达到，则会抛出一个异常。 下面的图片描述了一个算法的例子， <code>refinement_level</code> = 2, <code>allow_merge</code> = true and <code>max_boxes</code> = 1。带有属性谓词的单元格是红色的，包围盒的区域略带橙色。 <div class="image">
<img src="bounding_box_predicate.png" alt="bounding_box_predicate.png"/>
</div>
</li>
<li>1.在黑色中我们可以看到当前级别的单元格。</li>
<li>2. 对于每个包含红色区域的单元格，都会创建一个边界框：默认情况下，这些框会被返回。</li>
</ul>
<p>因为 <code>allow_merge</code> = true，所以在不改变封面的情况下减少了包围盒的数量。 如果 <code>max_boxes</code> 被保留为默认值或大于1，这两个盒子将被返回。</p>
<p>因为 <code>max_boxes</code> =1，最小的边界盒被合并到较大的边界盒。 注意，明智地选择参数是很重要的。例如， <code>allow_merge</code> =false和 <code>refinement_level</code> =1会返回非常相同的边界框，但计算成本只有一小部分。 这个函数没有考虑到单元格的曲率，因此它不适合处理弯曲的几何图形：映射被假定为线性。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03052">3052</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a84063935e67e3a3bb5afadc7b00599ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84063935e67e3a3bb5afadc7b00599ac">&#9670;&nbsp;</a></span>guess_point_owner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::guess_point_owner </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_bboxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个点阵列，使用使用 <a class="el" href="namespaceGridTools.html#a08438d4ad901817b7b638ce733fd664d">GridTools::compute_mesh_predicate_bounding_box</a> 获得的全局边界盒描述来猜测，对于每个点，哪个进程可能拥有它。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bboxes</td><td>描述每个进程拥有属性的网格部分的边界盒的矢量。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>要测试的点的阵列。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个包含以下信息的元组。</dd></dl>
<ul>
<li>一个以进程的等级为标志的向量。对于每个等级，它包含一个它可能拥有的点的索引的向量。</li>
<li>从 <code>unsigned int</code> 中的点的索引 <code>points</code> 到所有者的等级的地图。</li>
<li>从 <code>points</code> 中的点的索引 <code>unsigned int</code> 到被猜测的所有者的行列的地图。 <dl class="section note"><dt>Note</dt><dd>这个函数的实际返回类型，即上面提到的 <code>return_type</code>, 的类型是 <div class="fragment"><div class="line">std::tuple&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div><div class="line">         std::map&lt; unsigned int, unsigned int&gt;,</div><div class="line">         std::map&lt; unsigned int, std::vector&lt;unsigned int&gt;&gt;&gt;</div></div><!-- fragment --> 在线文档中对该类型进行了缩写，以提高本页面的可读性。 </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03199">3199</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a327cb9de55959193994a994047592ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327cb9de55959193994a994047592ec9">&#9670;&nbsp;</a></span>guess_point_owner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::guess_point_owner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>covering_rtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个覆盖的rtree（见 <a class="el" href="classGridTools_1_1Cache.html#a376c8ecad23b1c000c6c36feae17b386">GridTools::Cache::get_covering_rtree()</a>), ）和一个点的数组，找到一个进程的超集，这个超集可以单独拥有包含这些点的单元。 进一步的细节见 <a class="el" href="namespaceGridTools.html#a84063935e67e3a3bb5afadc7b00599ac">GridTools::guess_point_owner</a>; 这里只报告不同的输入/输出类型。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">covering_rtree</td><td>RTRee，它使我们能够识别并行计算中哪些进程可能拥有围绕给定点的单元。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>要考虑的点的一个向量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个包含以下信息的元组。</dd></dl>
<ul>
<li>一个以处理器等级为索引的地图。对于每个等级，它包含一个它可能拥有的点的索引向量。</li>
<li>从 <code>unsigned int</code> 中的点的索引 <code>points</code> 到所有者的等级的地图；这些是找到单一可能所有者的点。</li>
<li>从 <code>unsigned int</code> 中的点的索引 <code>points</code> 到猜测的所有者行列的地图；这些是发现有多个可能的所有者的点。 <dl class="section note"><dt>Note</dt><dd>这个函数的实际返回类型，即上面提到的 <code>return_type</code>, 的类型是 <div class="fragment"><div class="line">std::tuple&lt;std::map&lt;unsigned int, std::vector&lt;unsigned int&gt;&gt;,</div><div class="line">         std::map&lt;unsigned int, unsigned int&gt;,</div><div class="line">         std::map&lt;unsigned int, std::vector&lt;unsigned int&gt;&gt;&gt;</div></div><!-- fragment --> 在线文档中对该类型进行了缩写，以提高本页面的可读性。 </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03247">3247</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a9b7e2ca8ecd26a472e5225ba91a58acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7e2ca8ecd26a472e5225ba91a58acb">&#9670;&nbsp;</a></span>vertex_to_cell_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &gt; GridTools::vertex_to_cell_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回所有顶点的相邻单元。如果一个顶点也是一个悬空的节点，也会返回相关的粗略单元。顶点是按顶点索引排序的。这是由函数 <code>cell-&gt;vertex_index()</code> 返回的数字。注意，只使用由 <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation&lt;dim,spacedim&gt;::get_used_vertices()</a> 返回的数组中标记的索引。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03297">3297</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a79eddc6b744c7c83d9bc020dfa509e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eddc6b744c7c83d9bc020dfa509e19">&#9670;&nbsp;</a></span>vertex_to_cell_centers_directions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt; GridTools::vertex_to_cell_centers_directions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为 <a class="el" href="namespaceGridTools.html#a9b7e2ca8ecd26a472e5225ba91a58acb">GridTools::vertex_to_cell_map()</a> 输出的每个顶点-单元组合返回一个归一化张量的向量（期望作为此函数的输入参数）。每个张量代表一个从顶点到各自单元中心的几何向量。 如果输入向量的大小不等于三角形的顶点数量，将抛出一个断言。 result[v][c]是顶点索引v的单位张量，表示第c个单元的中心相对于顶点v的方向。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02696">2696</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a2d9ac4e5783a4c13911c576064b255be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9ac4e5783a4c13911c576064b255be">&#9670;&nbsp;</a></span>find_closest_vertex_of_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::find_closest_vertex_of_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;dim&gt;()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.template&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;dim,&#160;spacedim&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回最接近给定位置的单元格 <code>cell</code> 的局部顶点索引 <code>position</code>. 顶点的位置从（可选） <code>mapping</code> 参数中提取，以保证在底层映射修改顶点位置时返回正确答案。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02970">2970</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="adf1ec4049da3c61cb29eb294199e7e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1ec4049da3c61cb29eb294199e7e53">&#9670;&nbsp;</a></span>compute_local_to_global_vertex_index_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a4fbb80cf1f559474b7f3044eaf08a078">types::global_vertex_index</a> &gt; GridTools::compute_local_to_global_vertex_index_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为与本地拥有的活动单元相关的每个顶点和悬挂节点计算一个全局唯一的索引。作为本地拥有的单元格的悬挂节点的幽灵单元格的顶点有一个全局索引。 然而，不<em>touch</em>一个活动单元的其他顶点在这个处理器上没有全局索引。 地图的键是顶点的本地索引，值是全局索引。这些索引在细化或粗化后需要重新计算，并且可能是不同的。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03346">3346</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aed82bbc9838a9123bf567014ae9990dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed82bbc9838a9123bf567014ae9990dd">&#9670;&nbsp;</a></span>get_longest_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classdouble.html">double</a> &gt; GridTools::get_longest_direction </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个 <code>cell</code>. 的每个坐标方向上的外延之间的比率中的最高值 此外，返回相对于最高伸长率的尺寸。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell一个指向单元格的迭代器。</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个 std::pair&lt;unsigned  int, double&gt;，这样 <code>first</code> 值是最高伸长率的尺寸， <code>second</code> 值是 <code>cell</code>. 尺寸中的比率。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l05052">5052</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a002fd376a184234ccbf5eca8f8fd7012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002fd376a184234ccbf5eca8f8fd7012">&#9670;&nbsp;</a></span>get_face_connectivity_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_face_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>产生一个稀疏模式，其中非零条目表示两个单元格通过一个共同的面连接。稀疏模式的对角线条目也被设定。 行和列指的是使用单元格迭代器按自然顺序遍历的单元格。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03699">3699</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ab54e2fb68484ddaedaab56de13323169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54e2fb68484ddaedaab56de13323169">&#9670;&nbsp;</a></span>get_vertex_connectivity_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_vertex_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>产生一个稀疏度模式，其中非零条目表示两个单元格通过一个共同的顶点连接。稀疏模式的对角线条目也被设定。 行和列指的是使用单元格迭代器按自然顺序遍历的单元格。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03733">3733</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="acec0e25e2e5b5c9f359516d85ef29950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec0e25e2e5b5c9f359516d85ef29950">&#9670;&nbsp;</a></span>get_vertex_connectivity_of_cells_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_vertex_connectivity_of_cells_on_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为一个给定的水平网格产生一个稀疏模式，其中非零条目表示两个单元通过一个共同的顶点连接。稀疏模式的对角线条目也被设置。 行和列指的是使用单元格迭代器按自然顺序遍历的单元格。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03762">3762</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a99eba8e3b388258eda37a2724579dd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99eba8e3b388258eda37a2724579dd1d">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用图形分割器来分割构成整个域的活动单元。调用此函数后，所有活动单元的子域id的值将在0和 <code>n_partitions-1</code>. 之间，你可以通过使用<code>cell- &gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code>. 使用第三个参数来选择METIS或ZOLTAN提供的分区算法。METIS是默认的分区器。 如果deal.II没有与ZOLTAN或METIS一起安装，当选择相应的分区方法时，这个函数将产生一个错误，除非 <code>n_partitions</code> 是一个。 即，你可以写一个程序，使其在单处理器单分区的情况下运行，而不安装软件包，只有在需要多分区时才需要安装。 </p><dl class="section note"><dt>Note</dt><dd>如果 <code>cell_weight</code> 信号已被附加到 <code>triangulation</code>, ，那么这将被使用并传递给分区器。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03798">3798</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a72956e32f5a1091a6c8731b545e7fcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72956e32f5a1091a6c8731b545e7fcbf">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数执行的操作与上面的函数相同，只是它考虑到了一组特定的 <code>cell_weights</code>, ，它允许分区器平衡图形，同时考虑到每个单元所花费的计算努力。 </p><dl class="section note"><dt>Note</dt><dd>如果 <code>cell_weights</code> 向量为空，则不考虑加权。如果不是，那么这个向量的大小必须等于三角形中有效单元的数量。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03849">3849</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a3c475677bc29b764e9fa5978d4d41f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c475677bc29b764e9fa5978d4d41f77">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_connection_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数与前一个函数的作用相同，即使用分区算法将一个三角形划分为由 <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code> 标志确定的若干子域。 与前一个函数不同的是第二个参数，一个代表单元格之间连接模式的稀疏模式。 虽然上面的函数通过考虑哪些单元彼此相邻而直接从三角图中建立，但这个函数可以采用更精细的连接图。稀疏模式的大小需要是 \(N\times N\) ，其中 \(N\) 是三角形中活动单元的数量。如果稀疏模式在位置 \((i,j)\) 处包含一个条目，那么这意味着单元格 \(i\) 和 \(j\) （按照主动单元格迭代器遍历的顺序）将被视为连接；然后分区算法将尝试以这样的方式划分域：（i）子域的大小大致相等，以及（ii）最小数量的连接被破坏。 这个函数主要适用于单元格之间存在仅在三角形中不存在的连接的情况（否则前面的函数将是更简单的用法）。这种连接可能包括域的边界的某些部分通过对称边界条件或积分进行耦合（例如，域中裂缝两边的摩擦接触），或者如果使用的数值方案不仅连接紧邻的单元，而且连接更大的邻近单元（例如，在求解积分方程时）。 此外，在默认的稀疏模式不完全足够的情况下，这个函数可能是有用的。这种情况可能会发生，因为默认情况下只是考虑面的邻居，而不是由边或顶点连接的相邻单元。虽然在使用连续有限元时，后者夫妇在邻接图中通常仍是紧密相连的，分区算法在这种情况下通常不会切断重要的连接。然而，如果网格中存在许多单元的顶点（分别比2D和3D中常见的4个或6个多得多）聚集在一起，那么就会有大量的单元跨顶点连接，但在仅使用面邻关系构建的连接图中却有几度的距离。在这样的情况下，分区算法有时可能会做出错误的决定，你可能想建立自己的连接图。 </p><dl class="section note"><dt>Note</dt><dd>如果 <code>cell_weight</code> 信号已被附加到 <code>triangulation</code>, ，那么这将被使用并传递给分区器。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03891">3891</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="af499f992ff3d4716f7f15c55d68ade02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af499f992ff3d4716f7f15c55d68ade02">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_connection_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数执行的操作与上面的函数相同，只是它考虑到了一组特定的 <code>cell_weights</code>, ，它允许分区器平衡图形，同时考虑到每个单元上所花费的计算努力。 </p><dl class="section note"><dt>Note</dt><dd>如果 <code>cell_weights</code> 向量为空，则不考虑加权。如果不是，那么这个向量的大小必须等于三角形中有效单元的数量。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l03944">3944</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a1951822ebc7a80fb21aea5d4cd6dac6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1951822ebc7a80fb21aea5d4cd6dac6c">&#9670;&nbsp;</a></span>partition_triangulation_zorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation_zorder </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>group_siblings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果标志 <code>group_siblings</code> 被设置为 "true"（此函数的默认行为），则使用与p4est库中相同的分区方案生成构成整个域的活动单元的分区。 调用此函数后，所有活动单元的子域id的值将在0和 <code>n_partitions-1</code>. 之间。你可以通过使用<code>cell- &gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code>. 来访问一个单元的子域id。 </p><dl class="section note"><dt>Note</dt><dd>如果标志 <code>group_siblings</code> 被设置为false，一个单元的子域可能会被放在不同的处理器上，即使它们都处于活动状态，这是p4est的一个假设。通过放宽这一点，我们可以创建拥有单个单元的分区（也适用于精炼网格）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04025">4025</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a70d37431a097d36fb7152c41e0352b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d37431a097d36fb7152c41e0352b5e">&#9670;&nbsp;</a></span>partition_multigrid_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_multigrid_levels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过使用 "最年轻的孩子
"规则分配级别子域id来划分多网格层次结构的单元，也就是说，层次结构中的每个单元都由在森林中拥有其最左边孩子的处理器拥有，活跃的单元具有相同的子域id和级别子域id。你可以通过使用<code>cell- &gt;level_subdomain_id()</code>. 注意：这个函数假定活动单元已经被分区。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04130">4130</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ac41d959ae1723a898b616c3320241ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41d959ae1723a898b616c3320241ffe">&#9670;&nbsp;</a></span>get_subdomain_association() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; GridTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classCellId.html">CellId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数允许询问由CellId对象识别的单元格的所属子域，该对象在当前进程中不一定存在。 </p><dl class="section note"><dt>Note</dt><dd>这个函数还没有为 <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>. 实现。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04158">4158</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae0cb61bdd7e17c6b1589bdd16891e561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cb61bdd7e17c6b1589bdd16891e561">&#9670;&nbsp;</a></span>get_subdomain_association() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于每个活动单元，在输出数组中返回它属于哪个子域（由<code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code>函数给出）。在调用此函数时，输出数组应该已经有了合适的大小。 这个函数返回每个单元格与一个子域的关联。如果你要寻找每个 <em>DoF与一个子域的关联，请使用</em> <code><a class="el" href="namespaceDoFTools.html#a0429b3117b2ab1f5a1fd0d55de26ad81">DoFTools::get_subdomain_association</a></code> 函数。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04252">4252</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a8c212a30784bec20b1ae13fad3fd579c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c212a30784bec20b1ae13fad3fd579c">&#9670;&nbsp;</a></span>count_cells_with_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::count_cells_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算有多少个单元与给定的 <code>subdomain</code> 索引唯一相关。 如果没有具有给定 <code>子域索引的单元格，该函数可能返回0。这种情况可能发生，例如，如果你试图将一个粗略的网格划分为更多的分区（每个处理器一个），而不是网格中的单元。</code> 这个函数返回与一个子域相关的单元数。 如果你正在寻找 <em>DoF与这个子域的关联，请使用</em> <code><a class="el" href="namespaceDoFTools.html#ac704c6d311cd0f289d625427e03708ac">DoFTools::count_dofs_with_subdomain_association</a></code> 函数。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04266">4266</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a33b3f1dcc53c868171f1bb0a3793a96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b3f1dcc53c868171f1bb0a3793a96e">&#9670;&nbsp;</a></span>get_locally_owned_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; GridTools::get_locally_owned_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于一个三角形，返回一个掩码，代表哪些顶点被当前进程 "拥有" ，就像我们谈论本地拥有的单元或自由度一样（见 <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a> 和 <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">GlossLocallyOwnedDof</a> ）。 为了这个函数的目的，我们对本地拥有的顶点定义如下：一个顶点是由与该顶点相邻的所有单元的所有者中具有最小的子域id（相当于该处理器的MPI等级）的那个处理器所拥有。换句话说，位于三角形分区内部的顶点由这个分区的所有者拥有；对于位于两个或多个分区之间边界的顶点，所有者是所有相邻子域中拥有最小子域id的处理器。 对于顺序三角计算（相对于，例如 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>), 每个用户顶点当然是由当前处理器拥有的，即函数返回 <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation::get_used_vertices()</a>. 对于并行三角计算，返回的掩码是 <a class="el" href="classTriangulation.html#ac0e5de61b90fd6b9ee1bf02bfc355085">Triangulation::get_used_vertices()</a> 返回的一个子集。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>该函数评估哪些顶点是本地拥有的三角结构。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>顶点的子集，如上所述。返回的数组长度等于Triangulation.n_vertices()，因此，可能大于 <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>. 。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04282">4282</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a32a5016c746ad756046ecff264dfa60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a5016c746ad756046ecff264dfa60d">&#9670;&nbsp;</a></span>get_finest_common_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; std::pair&lt; typename MeshType::cell_iterator, typename MeshType::cell_iterator &gt; &gt; GridTools::get_finest_common_cells </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出两个基于相同粗略网格的网格（即Triangulation或DoFHandler类型的对象），这个函数找出一组在这两个网格之间匹配的单元，其中最多只有一个网格在这个单元上更精细。换句话说，它找到了两个网格共同的最小单元，并且这些单元一起完全覆盖了该领域。 这个函数很有用，例如，在随时间变化的或非线性的应用中，我们必须对一个网格（例如，前一个时间步骤或非线性迭代的网格）上定义的解决方案与另一个网格（下一个时间步骤，下一个非线性迭代）的形状函数进行积分。例如，如果新的网格更细，那么就必须在粗的网格（Mesh_1）上获得解决方案，并将其内插到Mesh_2的相应单元中。反之，如果新的网格更粗，我们就必须用细网格形状函数的线性组合来表达粗网格的形状函数。无论哪种情况，我们都需要循环计算两个三角形中共同的最细的单元。这个函数返回一个与两个网格中的单元匹配的迭代器对的列表，可以用来达到这个目的。 请注意，这些迭代器的列表不一定是有序的，也不一定与作为参数的一个或两个网格中的单元格被遍历的顺序相一致。 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>一个满足 MeshType概念  要求的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>这个函数只能与 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 一起使用，当两个网格都使用相同的三角法时，因为在分布式三角法中，并非所有的单元都存储在本地，所以产生的列表可能不会覆盖整个域。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01106">1106</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="aae387b14cb19f14e3dbd3e0e1a3e3ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae387b14cb19f14e3dbd3e0e1a3e3ba2">&#9670;&nbsp;</a></span>have_same_coarse_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果两个三角形是基于相同的粗略网格，则返回true。 这是通过检查它们在最粗层次上是否有相同数量的单元来确定的，然后再检查它们是否有相同的顶点。 这两个网格可能有不同的细化历史，超出了粗略的网格。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01211">1211</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="abb75c70b1760c88a852413a1a9fae107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb75c70b1760c88a852413a1a9fae107">&#9670;&nbsp;</a></span>have_same_coarse_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，但对DoFHandler类型的参数工作。 提供这个函数是为了允许对所有类型的代表三角形的容器或建立在三角形上的类调用have_same_coarse_mesh。 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>一个满足 MeshType概念  要求的类型。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01247">1247</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a1c7bb95bc2bbb09d6f02651d7be1527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7bb95bc2bbb09d6f02651d7be1527d">&#9670;&nbsp;</a></span>fix_up_distorted_child_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList GridTools::fix_up_distorted_child_cells </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList &amp;&#160;</td>
          <td class="paramname"><em>distorted_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个三角网格和一个单元格的列表，这些单元格的子节点由于网格细化而变得扭曲，尝试通过移动中心节点来修复这些单元格。 该函数返回一个子节点变形的单元格列表，这些单元格由于某种原因不能被修复。因此，返回的列表是输入参数的一个子集。 关于扭曲的单元格的概念的定义，见 <a class="el" href="DEALGlossary.html#GlossDistorted">词汇表条目</a> 。 传递给当前函数的第一个参数通常是 <a class="el" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">Triangulation::execute_coarsening_and_refinement</a> 函数抛出的异常。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04802">4802</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aaec69b92488f0dd0d61ff66445327f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec69b92488f0dd0d61ff66445327f0d">&#9670;&nbsp;</a></span>get_patch_around_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename MeshType::active_cell_iterator &gt; GridTools::get_patch_around_cell </td>
          <td>(</td>
          <td class="paramtype">const typename MeshType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数返回给定活动单元的所有活动邻居单元的列表。 这里，邻居被定义为与给定的单元至少有一部分共同的面，但不是边缘（在3D）或顶点邻居（在2D和3D）。 返回列表中的第一个元素是作为参数提供的单元格。 其余的是邻居。该函数在给定的单元格的所有面上循环，并检查该面是否不在域的边界上。然后，如果邻居单元没有任何子单元（也就是说，它与当前单元处于相同的细化水平，或者更粗），那么这个邻居单元将被添加到单元列表中。否则，如果邻接单元是细化的，因此有孩子，那么这个函数就会在当前面的所有子面中循环，将这些子面后面的邻接单元添加到要返回的列表中。 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>一个满足 MeshType概念  要求的类型。 在C++中，编译器不能从函数调用中确定 <code>MeshType</code> 。你需要把它作为一个明确的模板参数跟在函数名后面指定。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>指向网格中某一单元的迭代器。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>构成给定单元周围补丁的活动单元的列表 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>补丁通常用于定义误差估计器，需要解决网格中每个单元周围的补丁上的局部问题。这也需要操作与补丁的单元相关的自由度。为此，在命名空间DoFTools中有更多的函数在处理补丁。 </dd>
<dd>
在并行分布式计算的背景下，只有在本地拥有的单元上调用这个函数才有意义。这是因为本地拥有的单元的邻居要么是本地拥有的单元，要么是幽灵单元。对于这两种情况，我们知道这些单元实际上是完整的、平行的三角形的真实单元。我们还可以查询这些单元的自由度。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01389">1389</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a1cb9de754873e0401df4a51bacf0556c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb9de754873e0401df4a51bacf0556c">&#9670;&nbsp;</a></span>get_cells_at_coarsest_common_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename Container::cell_iterator &gt; GridTools::get_cells_at_coarsest_common_level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数接收一个活动单元的向量（以下命名为 <code>patch_cells）作为输入参数，并返回一个它们的父单元的向量，其细化程度为最粗的公共水平。换句话说，找到那个生活在同一细化水平的细胞集合，使输入向量中的所有细胞都是该集合中的细胞的子代，或者本身就在该集合中。</code> </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">容器</td><td>在C++中，编译器不能从函数调用中确定 <code>Container</code> 的类型。你需要把它作为一个明确的模板参数在函数名后面指定。这个类型必须满足网状容器的要求（见 ConceptMeshType ）。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch_cells</td><td>一个活动单元的向量，本函数为其找到最粗的公共层的父单元。这个单元格向量通常是调用函数的结果 <a class="el" href="namespaceGridTools.html#aaec69b92488f0dd0d61ff66445327f0d">GridTools::get_patch_around_cell()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>具有输入单元格的最粗共同细化水平的单元格列表。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01436">1436</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="aca3b216d4efc9d4add312c055a5ec95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3b216d4efc9d4add312c055a5ec95f">&#9670;&nbsp;</a></span>build_triangulation_from_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::build_triangulation_from_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt;::active_cell_iterator, typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_to_global_tria_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01482">1482</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a90221d4afe481ab23792286fe21e71dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90221d4afe481ab23792286fe21e71dd">&#9670;&nbsp;</a></span>get_dof_to_support_patch_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &gt; GridTools::get_dof_to_support_patch_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数通过DoFHandler定义的自由度运行，并为每个自由度构建一个active_cell_iterators的向量，代表该自由度下相关基元的支持单元。这个函数最初是为实现局部投影而设计的，例如Clement插值，结合其他局部修补函数，如 <a class="el" href="namespaceGridTools.html#aca3b216d4efc9d4add312c055a5ec95f">GridTools::build_triangulation_from_patch</a>. DoFHandler的建立在Triangulation之上或 parallel:distributed::<a class="el" href="classTriangulation.html">Triangulation</a> ，都得到支持和适当处理。 其结果是代表与自由度相关的基元支持的单元补丁。 例如，使用FE_Q有限元，我们得到了接触自由度的标准单元补丁，然后添加其他单元来处理可能的悬挂节点约束。 使用FE_DGQ有限元，自由度在逻辑上被认为是单元的 "内部"，所以补丁将只由自由度所在的单个单元组成。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>DoFHandler可以建立在三角或 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 有限元上，其自由度在逻辑上与顶点、直线、四边形或六边形相关。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>从局部相关单元上的自由度的global_dof_index到包含 <a class="el" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">DoFHandler::active_cell_iterators</a> 在该自由度的基函数支持中的单元的向量的映射。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01699">1699</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="ac2a1903382c6cff07b33d456a641f6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a1903382c6cff07b33d456a641f6d9">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,&#160;FaceIterator::AccessorType::space_dimension&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对面的正交平等测试。 <code>face1</code> 和 <code>face2</code> 被认为是相等的，如果其顶点之间可以通过正交平等关系实现一对一的匹配。 这里，两个顶点<code>v_1</code>和<code>v_2</code>被认为是相等的，如果 \(M\cdot v_1 + offset - v_2\) 与单位方向的单位向量 <code>direction</code>. 平行，如果参数 <code>matrix</code> 是对spacedim x spacedim矩阵的引用， \(M\) 被设置为 <code>matrix</code>, ，否则 \(M\) 为身份矩阵。 如果匹配成功， <code>face1</code> 相对于 <code>face2</code> 的_相对方向被返回到比特集 <code>orientation</code>, 中，其中 </p><div class="fragment"><div class="line">orientation[0]</div><div class="line"></div><div class="line">-&gt; face_orientation</div><div class="line">orientation[1]</div><div class="line"></div><div class="line">-&gt; face_flip</div><div class="line">orientation[2]</div><div class="line"></div><div class="line">-&gt; face_rotation</div></div><!-- fragment --><p> 在2D中，<code>face_orientation</code>总是<code>true</code>，<code>face_rotation</code>总是<code>false</code>，而face_flip具有<code>line_flip</code>的含义。更确切地说，在3D中。 <code>face_orientation</code>: <code>真</code>如果 <code>face1</code> 和 <code>face2</code> 有相同的方向。否则， <code>face1</code> 的顶点指数与 <code>face2</code> 的顶点指数以下列方式匹配。 </p><div class="fragment"><div class="line">face1:           face2:</div><div class="line"></div><div class="line">1</div><div class="line"></div><div class="line">- 3            2</div><div class="line"></div><div class="line">- 3</div><div class="line">|   |    &lt;--&gt;    |   |</div><div class="line">0</div><div class="line"></div><div class="line">- 2            0</div><div class="line"></div><div class="line">- 1</div></div><!-- fragment --><p> <code>face_flip</code>: <code>真</code>如果匹配的顶点旋转了180度。 </p><div class="fragment"><div class="line">face1:           face2:</div><div class="line"></div><div class="line">1</div><div class="line"></div><div class="line">- 0            2</div><div class="line"></div><div class="line">- 3</div><div class="line">|   |    &lt;--&gt;    |   |</div><div class="line">3</div><div class="line"></div><div class="line">- 2            0</div><div class="line"></div><div class="line">- 1</div></div><!-- fragment --><p> <code>face_rotation</code>: <code>真</code>如果匹配的顶点逆时针旋转90度。 </p><div class="fragment"><div class="line">face1:           face2:</div><div class="line"></div><div class="line">0</div><div class="line"></div><div class="line">- 2            2</div><div class="line"></div><div class="line">- 3</div><div class="line">|   |    &lt;--&gt;    |   |</div><div class="line">1</div><div class="line"></div><div class="line">- 3            0</div><div class="line"></div><div class="line">- 1</div></div><!-- fragment --><p> 以及任何的组合... 关于该主题的更多信息可以在 <a class="el" href="DEALGlossary.html#GlossFaceOrientation">词汇表 </a> 文章中找到。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02414">2414</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="ace05eb85711971f65123e569fead988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace05eb85711971f65123e569fead988c">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,&#160;FaceIterator::AccessorType::space_dimension&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上述函数相同，但不返回实际方向 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02467">2467</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="af34ed1fee44c7365f620b203b0c06974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34ed1fee44c7365f620b203b0c06974">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamType&amp; GridTools::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>输出操作符，将集合标志作为一组或的文本值输出。 <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00108">108</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a10dd90fb8c8cd12d2d1215a4cc4f270d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dd90fb8c8cd12d2d1215a4cc4f270d">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> GridTools::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局运算符，它返回一个对象，其中所有的位都被设置为第一或第二个参数中的设置。这个操作符的存在是因为如果它不存在，那么bit-or <code>操作符|</code>的结果将是一个整数，当我们试图将其分配给CacheUpdateFlags类型的对象时，又会引发编译器警告。 <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00127">127</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="ad16a1564283fb76f8dc55443b0e6ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16a1564283fb76f8dc55443b0e6ee53">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> GridTools::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局操作符，它返回一个对象，其中所有的位都被设置了，而在参数中没有设置。这个操作符的存在是因为如果它不存在，那么位负的<code>操作符~</code>的结果将是一个整数，当我们试图将其分配给CacheUpdateFlags类型的对象时，会引发编译器警告。 <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00139">139</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="aaf5a34086f9e813638189fc7d72d3874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5a34086f9e813638189fc7d72d3874">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&amp; GridTools::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局操作符，将第二个参数的位也设置在第一个参数中。 <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00153">153</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a564267811af347736ab43b6ce0721d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564267811af347736ab43b6ce0721d49">&#9670;&nbsp;</a></span>operator &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> GridTools::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局操作符，它返回一个对象，其中所有位都被设置在第一个和第二个参数中。这个操作符的存在是因为如果它不存在，那么位和<code>操作符&amp;</code>的结果将是一个整数，当我们试图将其分配给CacheUpdateFlags类型的对象时，会引发编译器警告。 <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00165">165</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a34b9c6e4eddef8e14827575aaf11af99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b9c6e4eddef8e14827575aaf11af99">&#9670;&nbsp;</a></span>operator &=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&amp; GridTools::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局操作符，如果第一个参数中的所有位没有在第二个参数中设置，则将其清除。 <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00179">179</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a03981bc3a24576a6cfbc0a305c723eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03981bc3a24576a6cfbc0a305c723eec">&#9670;&nbsp;</a></span>laplace_transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::laplace_transform </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>coefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>solve_for_absolute_positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l02086">2086</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="aa92034313ef924778e01beb3e24002dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92034313ef924778e01beb3e24002dd">&#9670;&nbsp;</a></span>copy_boundary_to_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::copy_boundary_to_manifold_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reset_boundary_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04844">4844</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a223fa99383a75568379eb5c71d5d5ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223fa99383a75568379eb5c71d5d5ac4">&#9670;&nbsp;</a></span>map_boundary_to_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::map_boundary_to_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_manifold_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reset_boundary_ids_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04869">4869</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a73e1e402f5ba79035857e25fa8eff20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e1e402f5ba79035857e25fa8eff20a">&#9670;&nbsp;</a></span>copy_material_to_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::copy_material_to_manifold_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_face_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04936">4936</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a1af37aecac8fb1dd60b114cc60a7d352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af37aecac8fb1dd60b114cc60a7d352">&#9670;&nbsp;</a></span>assign_co_dimensional_manifold_indicators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::assign_co_dimensional_manifold_indicators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>(const std::set&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>disambiguation_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>overwrite_only_flat_manifold_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l04964">4964</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a3843115e3b2380ce9980335c0454a804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3843115e3b2380ce9980335c0454a804">&#9670;&nbsp;</a></span>exchange_local_bounding_boxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classBoundingBox.html">BoundingBox</a>&lt;spacedim&gt; &gt; &gt; GridTools::exchange_local_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_bboxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06274">6274</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a457cb4c41d499faf229512ab30629eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457cb4c41d499faf229512ab30629eb2">&#9670;&nbsp;</a></span>build_global_description_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;std::pair&lt;<a class="el" href="classBoundingBox.html">BoundingBox</a>&lt;spacedim&gt;, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; GridTools::build_global_description_tree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06370">6370</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="a1ae36862c413167cf798e4b076dbc991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae36862c413167cf798e4b076dbc991">&#9670;&nbsp;</a></span>collect_coinciding_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_coinciding_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coinciding_vertex_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_coinciding_vertex_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06433">6433</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="ae3537ac484ba51325c7ca150ddaaf2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3537ac484ba51325c7ca150ddaaf2a5">&#9670;&nbsp;</a></span>compute_vertices_with_ghost_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&gt; &gt; GridTools::compute_vertices_with_ghost_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools_8cc_source.html#l06556">6556</a> of file <a class="el" href="grid__tools_8cc_source.html">grid_tools.cc</a>.</p>

</div>
</div>
<a id="af203f92d771fec1b638c3d032a816592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af203f92d771fec1b638c3d032a816592">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename ::<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>另一个版本，我们在一个给定的单元上使用该映射，该映射对应于该单元的活动有限元索引。 这显然只对hp-problems有用，因为所有其他DoF处理程序的活动有限元索引总是零。 </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l01258">1258</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a675fa3d8d6ce094fe29a59991b5d6421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675fa3d8d6ce094fe29a59991b5d6421">&#9670;&nbsp;</a></span>match_periodic_face_pairs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CellIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::match_periodic_face_pairs </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; std::pair&lt; CellIterator, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; std::pair&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; CellIterator &gt;::type, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; CellIterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, CellIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02014">2014</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a213a31f196cd53ccbcc809e567934442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213a31f196cd53ccbcc809e567934442">&#9670;&nbsp;</a></span>collect_periodic_faces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02108">2108</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a1a75867a6e9ed89b3dcb1a18206870dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a75867a6e9ed89b3dcb1a18206870dc">&#9670;&nbsp;</a></span>collect_periodic_faces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02189">2189</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a132f7057487b35446876f2d84aaaf6df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132f7057487b35446876f2d84aaaf6df">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__dof__handlers_8cc_source.html#l02278">2278</a> of file <a class="el" href="grid__tools__dof__handlers_8cc_source.html">grid_tools_dof_handlers.cc</a>.</p>

</div>
</div>
<a id="a062e05c51d27f3da00f2a1aa37bd3a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062e05c51d27f3da00f2a1aa37bd3a43">&#9670;&nbsp;</a></span>cell_measure< 1 >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="namespaceGridTools.html#a33fcabb522b0dc88c2959a1712e90fc1">GridTools::cell_measure</a>&lt; 1 &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00032">32</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
<a id="ac2994e9cd1a025e9fdd7cb411d68ec57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2994e9cd1a025e9fdd7cb411d68ec57">&#9670;&nbsp;</a></span>cell_measure< 2 >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="namespaceGridTools.html#a33fcabb522b0dc88c2959a1712e90fc1">GridTools::cell_measure</a>&lt; 2 &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00045">45</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
<a id="a275c6633e25410e091b89af0756d4333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275c6633e25410e091b89af0756d4333">&#9670;&nbsp;</a></span>cell_measure< 3 >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="namespaceGridTools.html#a33fcabb522b0dc88c2959a1712e90fc1">GridTools::cell_measure</a>&lt; 3 &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00119">119</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
<a id="a366ba100e8116931dcf4055f667762c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366ba100e8116931dcf4055f667762c8">&#9670;&nbsp;</a></span>rotate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00427">427</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
<a id="a0a5fdacaa512a29dac48ad9b11ac159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5fdacaa512a29dac48ad9b11ac159a">&#9670;&nbsp;</a></span>rotate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="grid__tools__nontemplates_8cc_source.html#l00436">436</a> of file <a class="el" href="grid__tools__nontemplates_8cc_source.html">grid_tools_nontemplates.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
