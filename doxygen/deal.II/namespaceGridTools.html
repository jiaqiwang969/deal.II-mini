<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceGridTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GridTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GridTools Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceGridTools_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridTools_1_1Cache.html">Cache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1CellDataTransferBuffer.html">CellDataTransferBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGridTools_1_1MarchingCubeAlgorithm.html">MarchingCubeAlgorithm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a995b90803c22dbe67fc6d510494b2e51"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> { <br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a3f53fb4be316505bd3d554a60f36b66b">update_nothing</a> = 0x000, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a9b55ce0c5531da349ed281e187eca71b">update_vertex_to_cell_map</a> = 0x001, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a4d46baef6b17eb7033571ef1da2341a3">update_vertex_to_cell_centers_directions</a>, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a0f9bb3e7869273e59af59d0bbba24264">update_used_vertices</a> = 0x008, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51ab902b04c2f3ce872a1c3c5f8c7f0a1b5">update_used_vertices_rtree</a> = 0x010, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a8b9dcac6ccefa7abfee0e3d235e9a622">update_cell_bounding_boxes_rtree</a> = 0x020, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51ac2be525d2326d9ad0fcf80d119b902bf">update_covering_rtree</a> = 0x040, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51ad72e91a2b48a683dcee04c0bbce9e607">update_locally_owned_cell_bounding_boxes_rtree</a> = 0x080, 
<br />
&#160;&#160;<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51a5f2ef9bfe103e3cd81f9d695f02b3af4">update_vertex_to_neighbor_subdomain</a> = 0x100, 
<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51aee229c003fc7a805bbf17dcdb74e6267">update_all</a> = 0xFFF
<br />
 }</td></tr>
<tr class="separator:a995b90803c22dbe67fc6d510494b2e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9565dbf2f8e45fee28e40806870e2c98"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename MeshType &gt; </td></tr>
<tr class="memitem:a9565dbf2f8e45fee28e40806870e2c98"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9565dbf2f8e45fee28e40806870e2c98">exchange_cell_data_to_ghosts</a> (const MeshType &amp;mesh, const std::function&lt; std_cxx17::optional&lt; DataType &gt;(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;pack, const std::function&lt; void(const typename MeshType::active_cell_iterator &amp;, const DataType &amp;)&gt; &amp;unpack, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;cell_filter=<a class="el" href="structalways__return.html">always_return</a>&lt; typename MeshType::active_cell_iterator, <a class="el" href="classbool.html">bool</a> &gt;{true})</td></tr>
<tr class="separator:a9565dbf2f8e45fee28e40806870e2c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf50b74d325f8e814bd03ef7654f880c"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename MeshType &gt; </td></tr>
<tr class="memitem:aaf50b74d325f8e814bd03ef7654f880c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aaf50b74d325f8e814bd03ef7654f880c">exchange_cell_data_to_level_ghosts</a> (const MeshType &amp;mesh, const std::function&lt; std_cxx17::optional&lt; DataType &gt;(const typename MeshType::level_cell_iterator &amp;)&gt; &amp;pack, const std::function&lt; void(const typename MeshType::level_cell_iterator &amp;, const DataType &amp;)&gt; &amp;unpack, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::level_cell_iterator &amp;)&gt; &amp;cell_filter=<a class="el" href="structalways__return.html">always_return</a>&lt; typename MeshType::level_cell_iterator, <a class="el" href="classbool.html">bool</a> &gt;{ true})</td></tr>
<tr class="separator:aaf50b74d325f8e814bd03ef7654f880c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3843115e3b2380ce9980335c0454a804"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a3843115e3b2380ce9980335c0454a804"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a3843115e3b2380ce9980335c0454a804">exchange_local_bounding_boxes</a> (const std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt; &amp;local_bboxes, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a3843115e3b2380ce9980335c0454a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457cb4c41d499faf229512ab30629eb2"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a457cb4c41d499faf229512ab30629eb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a457cb4c41d499faf229512ab30629eb2">build_global_description_tree</a> (const std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt; &amp;local_description, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a457cb4c41d499faf229512ab30629eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae36862c413167cf798e4b076dbc991"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1ae36862c413167cf798e4b076dbc991"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1ae36862c413167cf798e4b076dbc991">collect_coinciding_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;coinciding_vertex_groups, std::map&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;vertex_to_coinciding_vertex_group)</td></tr>
<tr class="separator:a1ae36862c413167cf798e4b076dbc991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3537ac484ba51325c7ca150ddaaf2a5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae3537ac484ba51325c7ca150ddaaf2a5"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae3537ac484ba51325c7ca150ddaaf2a5">compute_vertices_with_ghost_neighbors</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:ae3537ac484ba51325c7ca150ddaaf2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34ed1fee44c7365f620b203b0c06974"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:af34ed1fee44c7365f620b203b0c06974"><td class="memTemplItemLeft" align="right" valign="top">StreamType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af34ed1fee44c7365f620b203b0c06974">operator&lt;&lt;</a> (StreamType &amp;s, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> u)</td></tr>
<tr class="separator:af34ed1fee44c7365f620b203b0c06974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dd90fb8c8cd12d2d1215a4cc4f270d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a10dd90fb8c8cd12d2d1215a4cc4f270d">operator|</a> (const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f1, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:a10dd90fb8c8cd12d2d1215a4cc4f270d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16a1564283fb76f8dc55443b0e6ee53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ad16a1564283fb76f8dc55443b0e6ee53">operator~</a> (const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f1)</td></tr>
<tr class="separator:ad16a1564283fb76f8dc55443b0e6ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5a34086f9e813638189fc7d72d3874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aaf5a34086f9e813638189fc7d72d3874">operator|=</a> (<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;f1, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:aaf5a34086f9e813638189fc7d72d3874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564267811af347736ab43b6ce0721d49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a564267811af347736ab43b6ce0721d49">operator &amp;</a> (const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f1, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:a564267811af347736ab43b6ce0721d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b9c6e4eddef8e14827575aaf11af99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a34b9c6e4eddef8e14827575aaf11af99">operator &amp;=</a> (<a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;f1, const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> f2)</td></tr>
<tr class="separator:a34b9c6e4eddef8e14827575aaf11af99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about meshes and cells</div></td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acd5ccc543d561cfb086b571d1f7818cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:acd5ccc543d561cfb086b571d1f7818cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8169dc4981e90ba5d2386a87efa042"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9e8169dc4981e90ba5d2386a87efa042"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9e8169dc4981e90ba5d2386a87efa042">volume</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:a9e8169dc4981e90ba5d2386a87efa042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c293eff2ec7ce4b90ba08b35d1f2e2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a47c293eff2ec7ce4b90ba08b35d1f2e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">minimal_cell_diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:a47c293eff2ec7ce4b90ba08b35d1f2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8409fa9cb46a0070abc4da7de0f47f2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae8409fa9cb46a0070abc4da7de0f47f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae8409fa9cb46a0070abc4da7de0f47f2">maximal_cell_diameter</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ae8409fa9cb46a0070abc4da7de0f47f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33fcabb522b0dc88c2959a1712e90fc1"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a33fcabb522b0dc88c2959a1712e90fc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a33fcabb522b0dc88c2959a1712e90fc1">cell_measure</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;all_vertices, const unsigned <a class="el" href="classint.html">int</a>(&amp;vertex_indices)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell])</td></tr>
<tr class="separator:a33fcabb522b0dc88c2959a1712e90fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290ae00a4f293af389264a5f8135051a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a290ae00a4f293af389264a5f8135051a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a290ae00a4f293af389264a5f8135051a">cell_measure</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;all_vertices, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;vertex_indices)</td></tr>
<tr class="separator:a290ae00a4f293af389264a5f8135051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb82daccf66f77170be7e1f6dcc360f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1fb82daccf66f77170be7e1f6dcc360f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1fb82daccf66f77170be7e1f6dcc360f">affine_cell_approximation</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>)</td></tr>
<tr class="separator:a1fb82daccf66f77170be7e1f6dcc360f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce56c4b1243683d716027b8d497250a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:abce56c4b1243683d716027b8d497250a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#abce56c4b1243683d716027b8d497250a">compute_aspect_ratio_of_cells</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature)</td></tr>
<tr class="separator:abce56c4b1243683d716027b8d497250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6477e53e65dfbcaa0b2add902f4350e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aa6477e53e65dfbcaa0b2add902f4350e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa6477e53e65dfbcaa0b2add902f4350e">compute_maximum_aspect_ratio</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature)</td></tr>
<tr class="separator:aa6477e53e65dfbcaa0b2add902f4350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e86bcbb9bfbf045da4b3922506ed7b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a95e86bcbb9bfbf045da4b3922506ed7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a95e86bcbb9bfbf045da4b3922506ed7b">compute_bounding_box</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a95e86bcbb9bfbf045da4b3922506ed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350e00a4c5194b3007de4ea4bb13930b"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a350e00a4c5194b3007de4ea4bb13930b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a350e00a4c5194b3007de4ea4bb13930b">project_to_object</a> (const Iterator &amp;object, const <a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt; &amp;trial_point)</td></tr>
<tr class="separator:a350e00a4c5194b3007de4ea4bb13930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1118c2c0a54f980218460af5601562cf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1118c2c0a54f980218460af5601562cf"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt; &gt;, <a class="el" href="structSubCellData.html">SubCellData</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1118c2c0a54f980218460af5601562cf">get_coarse_mesh_description</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:a1118c2c0a54f980218460af5601562cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions supporting the creation of meshes</div></td></tr>
<tr class="memitem:aa502b615730af32271d9da4206939a81"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa502b615730af32271d9da4206939a81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aa502b615730af32271d9da4206939a81">delete_unused_vertices</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata)</td></tr>
<tr class="separator:aa502b615730af32271d9da4206939a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb09f2e9812f04661f9ca79e598e197"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2fb09f2e9812f04661f9ca79e598e197"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2fb09f2e9812f04661f9ca79e598e197">delete_duplicated_vertices</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;all_vertices, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;considered_vertices, const <a class="el" href="classdouble.html">double</a> tol=1e-12)</td></tr>
<tr class="separator:a2fb09f2e9812f04661f9ca79e598e197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e0f86b3a9310f1952cfe29e1fe7bd4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a26e0f86b3a9310f1952cfe29e1fe7bd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a26e0f86b3a9310f1952cfe29e1fe7bd4">invert_all_negative_measure_cells</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;all_vertices, std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells)</td></tr>
<tr class="separator:a26e0f86b3a9310f1952cfe29e1fe7bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5f04ca06ef2667c468296f538716e7"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a8d5f04ca06ef2667c468296f538716e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8d5f04ca06ef2667c468296f538716e7">consistently_order_cells</a> (std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells)</td></tr>
<tr class="separator:a8d5f04ca06ef2667c468296f538716e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rotating, stretching and otherwise transforming meshes</div></td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Transformation , int spacedim&gt; </td></tr>
<tr class="memitem:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform</a> (const Transformation &amp;transformation, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a212e99cf0d923cebfa04f1d23fa60b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b953611883979e3f920f800bd855df3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4b953611883979e3f920f800bd855df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">shift</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;shift_vector, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a4b953611883979e3f920f800bd855df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910bb99ec34eac082da97c08e7dd17c3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a910bb99ec34eac082da97c08e7dd17c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a910bb99ec34eac082da97c08e7dd17c3">rotate</a> (const <a class="el" href="classdouble.html">double</a> angle, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a910bb99ec34eac082da97c08e7dd17c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a580cbf329f016024a2e6b9d7eb9eed69">rotate</a> (const <a class="el" href="classdouble.html">double</a> angle, const unsigned <a class="el" href="classint.html">int</a> axis, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, 3 &gt; &amp;triangulation)</td></tr>
<tr class="separator:a580cbf329f016024a2e6b9d7eb9eed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">laplace_transform</a> (const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;new_points, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; *coefficient=nullptr, const <a class="el" href="classbool.html">bool</a> solve_for_absolute_positions=false)</td></tr>
<tr class="separator:a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960178fc39f3b8bd68d62f5687bcbab0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a960178fc39f3b8bd68d62f5687bcbab0"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a960178fc39f3b8bd68d62f5687bcbab0">get_all_vertices_at_boundary</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:a960178fc39f3b8bd68d62f5687bcbab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0967563badadd81f77f62622dd8bc2cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">scale</a> (const <a class="el" href="classdouble.html">double</a> scaling_factor, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a0967563badadd81f77f62622dd8bc2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e8aecd2cf74d3476e0daa11a00248b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac4e8aecd2cf74d3476e0daa11a00248b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">distort_random</a> (const <a class="el" href="classdouble.html">double</a> factor, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="classbool.html">bool</a> keep_boundary=true, const unsigned <a class="el" href="classint.html">int</a> seed=boost::random::mt19937::default_seed)</td></tr>
<tr class="separator:ac4e8aecd2cf74d3476e0daa11a00248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b77b07123012706fbadf91d8f022b3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a62b77b07123012706fbadf91d8f022b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a62b77b07123012706fbadf91d8f022b3">remove_hanging_nodes</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> isotropic=false, const unsigned <a class="el" href="classint.html">int</a> max_iterations=100)</td></tr>
<tr class="separator:a62b77b07123012706fbadf91d8f022b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40336842aa2faac805746dc10c7c604f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a40336842aa2faac805746dc10c7c604f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a40336842aa2faac805746dc10c7c604f">remove_anisotropy</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> max_ratio=1.6180339887, const unsigned <a class="el" href="classint.html">int</a> max_iterations=5)</td></tr>
<tr class="separator:a40336842aa2faac805746dc10c7c604f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f129213c63c92a6ed84c6f2a906048b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3f129213c63c92a6ed84c6f2a906048b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">regularize_corner_cells</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> limit_angle_fraction=.75)</td></tr>
<tr class="separator:a3f129213c63c92a6ed84c6f2a906048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finding cells and vertices of a triangulation</div></td></tr>
<tr class="memitem:a8e8bb9211264d2106758ac4d7184117e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8e8bb9211264d2106758ac4d7184117e"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">compute_point_locations</a> (const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;cache, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;points, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell_hint=typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator())</td></tr>
<tr class="separator:a8e8bb9211264d2106758ac4d7184117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a845642f4d205352931267b58055d62"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5a845642f4d205352931267b58055d62"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a5a845642f4d205352931267b58055d62">compute_point_locations_try_all</a> (const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;cache, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;points, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell_hint=typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator())</td></tr>
<tr class="separator:a5a845642f4d205352931267b58055d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6eff31d194dd4beafc9eb6a22c5e27"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afe6eff31d194dd4beafc9eb6a22c5e27"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#afe6eff31d194dd4beafc9eb6a22c5e27">distributed_compute_point_locations</a> (const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim, spacedim &gt; &amp;cache, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;local_points, const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;global_bboxes, const <a class="el" href="classdouble.html">double</a> tolerance=1e-10)</td></tr>
<tr class="separator:afe6eff31d194dd4beafc9eb6a22c5e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770c9eab75f60a58420c9e4c6573d2ee"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a770c9eab75f60a58420c9e4c6573d2ee"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a770c9eab75f60a58420c9e4c6573d2ee">extract_used_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;container, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:a770c9eab75f60a58420c9e4c6573d2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f49d6a42c3dbabc53a86571e874cc3f"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a1f49d6a42c3dbabc53a86571e874cc3f"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">find_closest_vertex</a> (const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:a1f49d6a42c3dbabc53a86571e874cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07919e120e98a6a0139ffe8c9f4a2a8b"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a07919e120e98a6a0139ffe8c9f4a2a8b"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a07919e120e98a6a0139ffe8c9f4a2a8b">find_closest_vertex</a> (const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={})</td></tr>
<tr class="separator:a07919e120e98a6a0139ffe8c9f4a2a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f7b02080d7740cdb0fe73f3917af36"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a84f7b02080d7740cdb0fe73f3917af36"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a84f7b02080d7740cdb0fe73f3917af36">find_closest_vertex</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={})</td></tr>
<tr class="separator:a84f7b02080d7740cdb0fe73f3917af36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4111b7e10cb9b10f5f0d1d03654152e1"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a4111b7e10cb9b10f5f0d1d03654152e1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a4111b7e10cb9b10f5f0d1d03654152e1">find_cells_adjacent_to_vertex</a> (const MeshType&lt; dim, spacedim &gt; &amp;container, const unsigned <a class="el" href="classint.html">int</a> vertex_index)</td></tr>
<tr class="separator:a4111b7e10cb9b10f5f0d1d03654152e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81430f37dc42f63e1cf0d3e62dc0a414"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a81430f37dc42f63e1cf0d3e62dc0a414"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">find_active_cell_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={}, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10)</td></tr>
<tr class="separator:a81430f37dc42f63e1cf0d3e62dc0a414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ddac4773100d2e94724821ca57eef5"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:ad2ddac4773100d2e94724821ca57eef5"><td class="memTemplItemLeft" align="right" valign="top">MeshType&lt; dim, spacedim &gt;::active_cell_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ad2ddac4773100d2e94724821ca57eef5">find_active_cell_around_point</a> (const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={}, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10)</td></tr>
<tr class="separator:ad2ddac4773100d2e94724821ca57eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b6a71ae04417bd4b1a3d6d237557f1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad9b6a71ae04417bd4b1a3d6d237557f1"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ad9b6a71ae04417bd4b1a3d6d237557f1">find_active_cell_around_point</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10)</td></tr>
<tr class="separator:ad9b6a71ae04417bd4b1a3d6d237557f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7644b2db63dcc544874c1497c6de1a9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac7644b2db63dcc544874c1497c6de1a9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac7644b2db63dcc544874c1497c6de1a9">find_active_cell_around_point</a> (const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell_hint=typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator(), const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={}, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10)</td></tr>
<tr class="separator:ac7644b2db63dcc544874c1497c6de1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b35baf43f7ee073ac67431a8141df62"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a6b35baf43f7ee073ac67431a8141df62"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a6b35baf43f7ee073ac67431a8141df62">find_active_cell_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const std::vector&lt; std::set&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;<a class="el" href="namespaceGridTools.html#a149baff9d70416e8c51b00ee88fc46ea">vertex_to_cell_map</a>, const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt;&gt; &amp;vertex_to_cell_centers, const typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell_hint=typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator(), const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;marked_vertices={}, const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;used_vertices_rtree=<a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt;{}, const <a class="el" href="classdouble.html">double</a> tolerance=1.e-10, const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; *relevant_cell_bounding_boxes_rtree=nullptr)</td></tr>
<tr class="separator:a6b35baf43f7ee073ac67431a8141df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b45332283155be607e74d696dfd765c"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a2b45332283155be607e74d696dfd765c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2b45332283155be607e74d696dfd765c">find_all_active_cells_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classdouble.html">double</a> tolerance, const std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;first_cell)</td></tr>
<tr class="separator:a2b45332283155be607e74d696dfd765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6398d5b0c3c1c353ddbe8d04ee30958b"><td class="memTemplParams" colspan="2">template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </td></tr>
<tr class="memitem:a6398d5b0c3c1c353ddbe8d04ee30958b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a6398d5b0c3c1c353ddbe8d04ee30958b">find_all_active_cells_around_point</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const MeshType&lt; dim, spacedim &gt; &amp;mesh, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classdouble.html">double</a> tolerance=1e-10, const std::vector&lt; bool &gt; &amp;marked_vertices={})</td></tr>
<tr class="separator:a6398d5b0c3c1c353ddbe8d04ee30958b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c182c1901bb0d09046271809f918c6"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:ab5c182c1901bb0d09046271809f918c6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ab5c182c1901bb0d09046271809f918c6">get_active_child_cells</a> (const typename MeshType::cell_iterator &amp;cell)</td></tr>
<tr class="separator:ab5c182c1901bb0d09046271809f918c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a30ccceb7c9216efc44dd4af561e0bea0">get_active_neighbors</a> (const typename MeshType::active_cell_iterator &amp;cell, std::vector&lt; typename MeshType::active_cell_iterator &gt; &amp;active_neighbors)</td></tr>
<tr class="separator:a30ccceb7c9216efc44dd4af561e0bea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d79ac1398633149f15b69831815d8c1"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a7d79ac1398633149f15b69831815d8c1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a7d79ac1398633149f15b69831815d8c1">compute_active_cell_halo_layer</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate)</td></tr>
<tr class="separator:a7d79ac1398633149f15b69831815d8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3558d912b1294f2179dee890bbe8cb6"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:af3558d912b1294f2179dee890bbe8cb6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af3558d912b1294f2179dee890bbe8cb6">compute_cell_halo_layer_on_level</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::cell_iterator &amp;)&gt; &amp;predicate, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:af3558d912b1294f2179dee890bbe8cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0117c7410775202cf35260713f88d691"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a0117c7410775202cf35260713f88d691"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0117c7410775202cf35260713f88d691">compute_ghost_cell_halo_layer</a> (const MeshType &amp;mesh)</td></tr>
<tr class="separator:a0117c7410775202cf35260713f88d691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737b9675dbefbeff9d9c819edbe92868"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a737b9675dbefbeff9d9c819edbe92868"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a737b9675dbefbeff9d9c819edbe92868">compute_active_cell_layer_within_distance</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate, const <a class="el" href="classdouble.html">double</a> layer_thickness)</td></tr>
<tr class="separator:a737b9675dbefbeff9d9c819edbe92868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5f1dbc790083cb886c86b0a779776d"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a6d5f1dbc790083cb886c86b0a779776d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a6d5f1dbc790083cb886c86b0a779776d">compute_ghost_cell_layer_within_distance</a> (const MeshType &amp;mesh, const <a class="el" href="classdouble.html">double</a> layer_thickness)</td></tr>
<tr class="separator:a6d5f1dbc790083cb886c86b0a779776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663a467b31abdb8036b4986002f551c8"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:a663a467b31abdb8036b4986002f551c8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt;, <a class="el" href="classPoint.html">Point</a>&lt; MeshType::space_dimension &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a663a467b31abdb8036b4986002f551c8">compute_bounding_box</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate)</td></tr>
<tr class="separator:a663a467b31abdb8036b4986002f551c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ed37fb4458b7a7c782afdb9d0d2664"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:ab6ed37fb4458b7a7c782afdb9d0d2664"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; MeshType::space_dimension &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ab6ed37fb4458b7a7c782afdb9d0d2664">compute_mesh_predicate_bounding_box</a> (const MeshType &amp;mesh, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;predicate, const unsigned <a class="el" href="classint.html">int</a> refinement_level=0, const <a class="el" href="classbool.html">bool</a> allow_merge=false, const unsigned <a class="el" href="classint.html">int</a> max_boxes=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:ab6ed37fb4458b7a7c782afdb9d0d2664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84063935e67e3a3bb5afadc7b00599ac"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a84063935e67e3a3bb5afadc7b00599ac"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a84063935e67e3a3bb5afadc7b00599ac">guess_point_owner</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;global_bboxes, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;points)</td></tr>
<tr class="separator:a84063935e67e3a3bb5afadc7b00599ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327cb9de55959193994a994047592ec9"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a327cb9de55959193994a994047592ec9"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a327cb9de55959193994a994047592ec9">guess_point_owner</a> (const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;covering_rtree, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;points)</td></tr>
<tr class="separator:a327cb9de55959193994a994047592ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149baff9d70416e8c51b00ee88fc46ea"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a149baff9d70416e8c51b00ee88fc46ea"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a149baff9d70416e8c51b00ee88fc46ea">vertex_to_cell_map</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a149baff9d70416e8c51b00ee88fc46ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963b408048697e309a808098c361b476"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a963b408048697e309a808098c361b476"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a963b408048697e309a808098c361b476">vertex_to_cell_centers_directions</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh, const std::vector&lt; std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;vertex_to_cells)</td></tr>
<tr class="separator:a963b408048697e309a808098c361b476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9ac4e5783a4c13911c576064b255be"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2d9ac4e5783a4c13911c576064b255be"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a2d9ac4e5783a4c13911c576064b255be">find_closest_vertex_of_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;position, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:a2d9ac4e5783a4c13911c576064b255be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbda577beb1addbcd2e5ed867fdfc3c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a0dbda577beb1addbcd2e5ed867fdfc3c"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a4fbb80cf1f559474b7f3044eaf08a078">types::global_vertex_index</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0dbda577beb1addbcd2e5ed867fdfc3c">compute_local_to_global_vertex_index_map</a> (const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a0dbda577beb1addbcd2e5ed867fdfc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e99800a9a49575a928623f68deab7b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a64e99800a9a49575a928623f68deab7b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a64e99800a9a49575a928623f68deab7b">get_longest_direction</a> (typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator cell)</td></tr>
<tr class="separator:a64e99800a9a49575a928623f68deab7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Partitions and subdomains of triangulations</div></td></tr>
<tr class="memitem:a002fd376a184234ccbf5eca8f8fd7012"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a002fd376a184234ccbf5eca8f8fd7012"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a002fd376a184234ccbf5eca8f8fd7012">get_face_connectivity_of_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:a002fd376a184234ccbf5eca8f8fd7012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54e2fb68484ddaedaab56de13323169"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab54e2fb68484ddaedaab56de13323169"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ab54e2fb68484ddaedaab56de13323169">get_vertex_connectivity_of_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:ab54e2fb68484ddaedaab56de13323169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec0e25e2e5b5c9f359516d85ef29950"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acec0e25e2e5b5c9f359516d85ef29950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#acec0e25e2e5b5c9f359516d85ef29950">get_vertex_connectivity_of_cells_on_level</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const unsigned <a class="el" href="classint.html">int</a> level, <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;connectivity)</td></tr>
<tr class="separator:acec0e25e2e5b5c9f359516d85ef29950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eba8e3b388258eda37a2724579dd1d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a99eba8e3b388258eda37a2724579dd1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a99eba8e3b388258eda37a2724579dd1d">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a>)</td></tr>
<tr class="separator:a99eba8e3b388258eda37a2724579dd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72956e32f5a1091a6c8731b545e7fcbf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a72956e32f5a1091a6c8731b545e7fcbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a72956e32f5a1091a6c8731b545e7fcbf">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;cell_weights, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a>)</td></tr>
<tr class="separator:a72956e32f5a1091a6c8731b545e7fcbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c475677bc29b764e9fa5978d4d41f77"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3c475677bc29b764e9fa5978d4d41f77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a3c475677bc29b764e9fa5978d4d41f77">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;cell_connection_graph, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a>)</td></tr>
<tr class="separator:a3c475677bc29b764e9fa5978d4d41f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af499f992ff3d4716f7f15c55d68ade02"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:af499f992ff3d4716f7f15c55d68ade02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#af499f992ff3d4716f7f15c55d68ade02">partition_triangulation</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;cell_weights, const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;cell_connection_graph, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a> partitioner=<a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a>)</td></tr>
<tr class="separator:af499f992ff3d4716f7f15c55d68ade02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1951822ebc7a80fb21aea5d4cd6dac6c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1951822ebc7a80fb21aea5d4cd6dac6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1951822ebc7a80fb21aea5d4cd6dac6c">partition_triangulation_zorder</a> (const unsigned <a class="el" href="classint.html">int</a> n_partitions, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="classbool.html">bool</a> group_siblings=true)</td></tr>
<tr class="separator:a1951822ebc7a80fb21aea5d4cd6dac6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d37431a097d36fb7152c41e0352b5e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a70d37431a097d36fb7152c41e0352b5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a70d37431a097d36fb7152c41e0352b5e">partition_multigrid_levels</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a70d37431a097d36fb7152c41e0352b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74728f76ec58b9956ca0a8f0dc06dfa1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a74728f76ec58b9956ca0a8f0dc06dfa1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a74728f76ec58b9956ca0a8f0dc06dfa1">get_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const std::vector&lt; <a class="el" href="classCellId.html">CellId</a> &gt; &amp;cell_ids)</td></tr>
<tr class="separator:a74728f76ec58b9956ca0a8f0dc06dfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ae0cb61bdd7e17c6b1589bdd16891e561">get_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;subdomain)</td></tr>
<tr class="separator:ae0cb61bdd7e17c6b1589bdd16891e561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c212a30784bec20b1ae13fad3fd579c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8c212a30784bec20b1ae13fad3fd579c"><td class="memTemplItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a8c212a30784bec20b1ae13fad3fd579c">count_cells_with_subdomain_association</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain)</td></tr>
<tr class="separator:a8c212a30784bec20b1ae13fad3fd579c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538d5bfd6cea7aa42224ba8d5952dd05"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a538d5bfd6cea7aa42224ba8d5952dd05"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a538d5bfd6cea7aa42224ba8d5952dd05">get_locally_owned_vertices</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a538d5bfd6cea7aa42224ba8d5952dd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparing different meshes</div></td></tr>
<tr class="memitem:a56a519fc2d6485f487664d8b6a7c5d10"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:a56a519fc2d6485f487664d8b6a7c5d10"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; std::pair&lt; typename MeshType::cell_iterator, typename MeshType::cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a56a519fc2d6485f487664d8b6a7c5d10">get_finest_common_cells</a> (const MeshType &amp;mesh_1, const MeshType &amp;mesh_2)</td></tr>
<tr class="separator:a56a519fc2d6485f487664d8b6a7c5d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aae387b14cb19f14e3dbd3e0e1a3e3ba2">have_same_coarse_mesh</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;mesh_2)</td></tr>
<tr class="separator:aae387b14cb19f14e3dbd3e0e1a3e3ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75c70b1760c88a852413a1a9fae107"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:abb75c70b1760c88a852413a1a9fae107"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#abb75c70b1760c88a852413a1a9fae107">have_same_coarse_mesh</a> (const MeshType &amp;mesh_1, const MeshType &amp;mesh_2)</td></tr>
<tr class="separator:abb75c70b1760c88a852413a1a9fae107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with distorted cells</div></td></tr>
<tr class="memitem:a964f88bdde9505bcbb863b801488ef8c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a964f88bdde9505bcbb863b801488ef8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a964f88bdde9505bcbb863b801488ef8c">fix_up_distorted_child_cells</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList &amp;distorted_cells, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation)</td></tr>
<tr class="separator:a964f88bdde9505bcbb863b801488ef8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extracting and creating patches of cells</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions extract and create patches of cells surrounding a single cell, and creating triangulation out of them. </p>
</div></td></tr>
<tr class="memitem:aea0b44d8461b32e6d3d90e2e02028e62"><td class="memTemplParams" colspan="2">template&lt;class MeshType &gt; </td></tr>
<tr class="memitem:aea0b44d8461b32e6d3d90e2e02028e62"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename MeshType::active_cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aea0b44d8461b32e6d3d90e2e02028e62">get_patch_around_cell</a> (const typename MeshType::active_cell_iterator &amp;cell)</td></tr>
<tr class="separator:aea0b44d8461b32e6d3d90e2e02028e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c90da78e89db4b78e772c0b8958e556"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a7c90da78e89db4b78e772c0b8958e556"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Container::cell_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a7c90da78e89db4b78e772c0b8958e556">get_cells_at_coarsest_common_level</a> (const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;patch_cells)</td></tr>
<tr class="separator:a7c90da78e89db4b78e772c0b8958e556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3b216d4efc9d4add312c055a5ec95f"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:aca3b216d4efc9d4add312c055a5ec95f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aca3b216d4efc9d4add312c055a5ec95f">build_triangulation_from_patch</a> (const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;patch, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt; &amp;local_triangulation, std::map&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt;::active_cell_iterator, typename Container::active_cell_iterator &gt; &amp;patch_to_global_tria_map)</td></tr>
<tr class="separator:aca3b216d4efc9d4add312c055a5ec95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac136e217e9b0d4273d37d0db0c40f937"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac136e217e9b0d4273d37d0db0c40f937"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac136e217e9b0d4273d37d0db0c40f937">get_dof_to_support_patch_map</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:ac136e217e9b0d4273d37d0db0c40f937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with periodic domains</div></td></tr>
<tr class="memitem:ac2a1903382c6cff07b33d456a641f6d9"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:ac2a1903382c6cff07b33d456a641f6d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality</a> (std::bitset&lt; 3 &gt; &amp;orientation, const FaceIterator &amp;face1, const FaceIterator &amp;face2, const <a class="el" href="classint.html">int</a> direction, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;offset=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:ac2a1903382c6cff07b33d456a641f6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace05eb85711971f65123e569fead988c"><td class="memTemplParams" colspan="2">template&lt;typename FaceIterator &gt; </td></tr>
<tr class="memitem:ace05eb85711971f65123e569fead988c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ace05eb85711971f65123e569fead988c">orthogonal_equality</a> (const FaceIterator &amp;face1, const FaceIterator &amp;face2, const <a class="el" href="classint.html">int</a> direction, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;offset=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:ace05eb85711971f65123e569fead988c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee88c4dce5066a41183b5dd70289b9df"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:aee88c4dce5066a41183b5dd70289b9df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">collect_periodic_faces</a> (const MeshType &amp;mesh, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id1, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id2, const <a class="el" href="classint.html">int</a> direction, std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;matched_pairs, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;offset=::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:aee88c4dce5066a41183b5dd70289b9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22eef800535f9e85a1723a6a36fd0f6"><td class="memTemplParams" colspan="2">template&lt;typename MeshType &gt; </td></tr>
<tr class="memitem:ab22eef800535f9e85a1723a6a36fd0f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#ab22eef800535f9e85a1723a6a36fd0f6">collect_periodic_faces</a> (const MeshType &amp;mesh, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id, const <a class="el" href="classint.html">int</a> direction, std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;matched_pairs, const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;offset=::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt;(), const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix=<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:ab22eef800535f9e85a1723a6a36fd0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with boundary and manifold ids</div></td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2ea00d3c65f290a020a268df8fb50c19">copy_boundary_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> reset_boundary_ids=false)</td></tr>
<tr class="separator:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5861f4e358367a1e12221a7e6832755f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga5861f4e358367a1e12221a7e6832755f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga5861f4e358367a1e12221a7e6832755f">map_boundary_to_manifold_ids</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;src_boundary_ids, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;dst_manifold_ids, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;reset_boundary_ids={})</td></tr>
<tr class="separator:ga5861f4e358367a1e12221a7e6832755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga306131b2b48ca10bb9a51e189806193c">copy_material_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> compute_face_ids=false)</td></tr>
<tr class="separator:ga306131b2b48ca10bb9a51e189806193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bdd10dc34f9ebb869b30bfaf70ff32"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gae8bdd10dc34f9ebb869b30bfaf70ff32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae8bdd10dc34f9ebb869b30bfaf70ff32">assign_co_dimensional_manifold_indicators</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::function&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>(const std::set&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;)&gt; &amp;disambiguation_function=[](const std::set&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_ids) { if(manifold_ids.size()==1) return *manifold_ids.begin();else return <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>;}, <a class="el" href="classbool.html">bool</a> overwrite_only_flat_manifold_ids=true)</td></tr>
<tr class="separator:gae8bdd10dc34f9ebb869b30bfaf70ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exceptions</div></td></tr>
<tr class="memitem:a9b96d83a9f10a39048e1613fa8da8cea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a9b96d83a9f10a39048e1613fa8da8cea">DeclException1</a> (ExcInvalidNumberOfPartitions, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of partitions you gave is &quot;&lt;&lt; arg1&lt;&lt; &quot;, but must be greater than zero.&quot;)</td></tr>
<tr class="separator:a9b96d83a9f10a39048e1613fa8da8cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27708777444134752f8cc8138857df28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a27708777444134752f8cc8138857df28">DeclException1</a> (ExcNonExistentSubdomain, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The subdomain id &quot;&lt;&lt; arg1&lt;&lt; &quot; has no cells associated with it.&quot;)</td></tr>
<tr class="separator:a27708777444134752f8cc8138857df28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088ac82f79509dbe1dc9e8d25bc7e50a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a088ac82f79509dbe1dc9e8d25bc7e50a">DeclException0</a> (ExcTriangulationHasBeenRefined)</td></tr>
<tr class="separator:a088ac82f79509dbe1dc9e8d25bc7e50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3154f24e33be2d7f42a123c0654958"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a1b3154f24e33be2d7f42a123c0654958">DeclException1</a> (ExcScalingFactorNotPositive, <a class="el" href="classdouble.html">double</a>,&lt;&lt; &quot;The scaling factor must be positive, but it is &quot;&lt;&lt; arg1&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:a1b3154f24e33be2d7f42a123c0654958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d361c91586d139eebcf2404caeae61a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridTools.html#a0d361c91586d139eebcf2404caeae61a">DeclException1</a> (ExcVertexNotUsed, unsigned <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The given vertex with index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not used in the given triangulation.&quot;)</td></tr>
<tr class="separator:a0d361c91586d139eebcf2404caeae61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace is a collection of algorithms working on triangulations, such as shifting or rotating triangulations, but also finding a cell that contains a given point. See the descriptions of the individual functions for more information. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a995b90803c22dbe67fc6d510494b2e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995b90803c22dbe67fc6d510494b2e51">&#9670;&nbsp;</a></span>CacheUpdateFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">GridTools::CacheUpdateFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum type given to the <a class="el" href="classGridTools_1_1Cache.html">Cache</a> class to select what information to update.</p>
<p>You can select more than one flag by concatenation using the bitwise or <code><a class="el" href="namespaceGridTools.html#a10dd90fb8c8cd12d2d1215a4cc4f270d">operator|(CacheUpdateFlags,CacheUpdateFlags)</a></code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a3f53fb4be316505bd3d554a60f36b66b"></a>update_nothing&#160;</td><td class="fielddoc"><p>Update Nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a9b55ce0c5531da349ed281e187eca71b"></a>update_vertex_to_cell_map&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_map, as returned by <a class="el" href="namespaceGridTools.html#a149baff9d70416e8c51b00ee88fc46ea">GridTools::vertex_to_cell_map()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a4d46baef6b17eb7033571ef1da2341a3"></a>update_vertex_to_cell_centers_directions&#160;</td><td class="fielddoc"><p>Update vertex_to_cell_centers_directions, as returned by <a class="el" href="namespaceGridTools.html#a963b408048697e309a808098c361b476">GridTools::vertex_to_cell_centers_directions()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a0f9bb3e7869273e59af59d0bbba24264"></a>update_used_vertices&#160;</td><td class="fielddoc"><p>Update a mapping of used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51ab902b04c2f3ce872a1c3c5f8c7f0a1b5"></a>update_used_vertices_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the used vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a8b9dcac6ccefa7abfee0e3d235e9a622"></a>update_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of the cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51ac2be525d2326d9ad0fcf80d119b902bf"></a>update_covering_rtree&#160;</td><td class="fielddoc"><p>Update the covering rtree object, initialized with pairs of a bounding box and an unsigned int. The bounding boxes are used to describe approximately which portion of the mesh contains locally owned cells by the process of rank the second element of the pair. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51ad72e91a2b48a683dcee04c0bbce9e607"></a>update_locally_owned_cell_bounding_boxes_rtree&#160;</td><td class="fielddoc"><p>Update an RTree of locally owned cell bounding boxes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51a5f2ef9bfe103e3cd81f9d695f02b3af4"></a>update_vertex_to_neighbor_subdomain&#160;</td><td class="fielddoc"><p>Update vertex to neighbor subdomain </p>
</td></tr>
<tr><td class="fieldname"><a id="a995b90803c22dbe67fc6d510494b2e51aee229c003fc7a805bbf17dcdb74e6267"></a>update_all&#160;</td><td class="fielddoc"><p>Update all objects. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00033">33</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acd5ccc543d561cfb086b571d1f7818cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5ccc543d561cfb086b571d1f7818cb">&#9670;&nbsp;</a></span>diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the diameter of a triangulation. The diameter is computed using only the vertices, i.e. if the diameter should be larger than the maximal distance between boundary vertices due to a higher order mapping, then this function will not catch this. </p>

</div>
</div>
<a id="a9e8169dc4981e90ba5d2386a87efa042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8169dc4981e90ba5d2386a87efa042">&#9670;&nbsp;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;&#160;dim&#160;&gt;()&#160;.template&#160;<a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the volume (i.e. the dim-dimensional measure) of the triangulation. We compute the measure using the integral \(\sum_K \int_K 1 \; dx\) where \(K\) are the cells of the given triangulation. The integral is approximated via quadrature for which we need the mapping argument.</p>
<p>If the triangulation is a dim-dimensional one embedded in a higher dimensional space of dimension spacedim, then the value returned is the dim-dimensional measure. For example, for a two-dimensional triangulation in three-dimensional space, the value returned is the area of the surface so described. (This obviously makes sense since the spacedim-dimensional measure of a dim-dimensional triangulation would always be zero if dim &lt; spacedim.</p>
<p>This function also works for objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, in which case the function is a collective operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation. </td></tr>
    <tr><td class="paramname">mapping</td><td>An optional argument used to denote the mapping that should be used when describing whether cells are bounded by straight or curved faces. The default is to use a \(Q_1\) mapping, which corresponds to straight lines bounding the cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dim-dimensional measure of the domain described by the triangulation, as discussed above. </dd></dl>

</div>
</div>
<a id="a47c293eff2ec7ce4b90ba08b35d1f2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c293eff2ec7ce4b90ba08b35d1f2e2">&#9670;&nbsp;</a></span>minimal_cell_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::minimal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;&#160;dim&#160;&gt;()&#160;.template&#160;<a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an approximation of the diameter of the smallest active cell of a triangulation. See step-24 for an example of use of this function.</p>
<p>Notice that, even if you pass a non-trivial mapping, the returned value is computed only using information on the vertices of the triangulation, possibly transformed by the mapping. While this is accurate most of the times, it may fail to give the correct result when the triangulation contains very distorted cells. </p>

</div>
</div>
<a id="ae8409fa9cb46a0070abc4da7de0f47f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8409fa9cb46a0070abc4da7de0f47f2">&#9670;&nbsp;</a></span>maximal_cell_diameter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::maximal_cell_diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;&#160;dim&#160;&gt;()&#160;.template&#160;<a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an approximation of the diameter of the largest active cell of a triangulation.</p>
<p>Notice that, even if you pass a non-trivial mapping to this function, the returned value is computed only using information on the vertices of the triangulation, possibly transformed by the mapping. While this is accurate most of the times, it may fail to give the correct result when the triangulation contains very distorted cells. </p>

</div>
</div>
<a id="a33fcabb522b0dc88c2959a1712e90fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fcabb522b0dc88c2959a1712e90fc1">&#9670;&nbsp;</a></span>cell_measure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::cell_measure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>(&amp;)&#160;</td>
          <td class="paramname"><em>vertex_indices</em>[GeometryInfo&lt; dim &gt;::vertices_per_cell]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of vertices (typically obtained using <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices</a>) as the first, and a list of vertex indices that characterize a single cell as the second argument, return the measure (area, volume) of this cell. If this is a real cell, then you can get the same result using <code>cell-&gt;measure()</code>, but this function also works for cells that do not exist except that you make it up by naming its vertices from the list.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000036">Deprecated:</a></b></dt><dd>Use the more general function which takes an <a class="el" href="classArrayView.html">ArrayView</a> instead. </dd></dl>

</div>
</div>
<a id="a290ae00a4f293af389264a5f8135051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290ae00a4f293af389264a5f8135051a">&#9670;&nbsp;</a></span>cell_measure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::cell_measure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of vertices (typically obtained using <a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">Triangulation::get_vertices()</a>) as the first, and a list of vertex indices that characterize a single cell as the second argument, return the measure (area, volume) of this cell. If this is a real cell, then you can get the same result using <code>cell-&gt;measure()</code>, but this function also works for cells that do not exist except that you make it up by naming its vertices from the list.</p>
<p>The parameter <code>vertex_indices</code> is expected to have <a class="el" href="structGeometryInfo.html#a2bb3a95a842d98b8b3bf9a64735d0eee">GeometryInfo&lt;dim&gt;::vertices_per_cell</a> entries. A std::vector is implicitly convertible to an <a class="el" href="classArrayView.html">ArrayView</a>, so it can be passed directly. See the <a class="el" href="classArrayView.html">ArrayView</a> class for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only implemented for codimension zero objects. </dd></dl>

</div>
</div>
<a id="a1fb82daccf66f77170be7e1f6dcc360f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb82daccf66f77170be7e1f6dcc360f">&#9670;&nbsp;</a></span>affine_cell_approximation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, dim, spacedim&gt;, <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; &gt; GridTools::affine_cell_approximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes an affine approximation of the map from the unit coordinates to the real coordinates of the form \(p_\text{real} = A p_\text{unit} + b \) by a least squares fit of this affine function to the \(2^\text{dim}\) vertices representing a quadrilateral or hexahedral cell in <code>spacedim</code> dimensions. The result is returned as a pair with the matrix <em>A</em> as the first argument and the vector <em>b</em> describing distance of the plane to the origin.</p>
<p>For any valid mesh cell whose geometry is not degenerate, this operation results in a unique affine mapping, even in cases where the actual transformation by a bi-/trilinear or higher order mapping might be singular. The result is exact in case the transformation from the unit to the real cell is indeed affine, such as in one dimension or for Cartesian and affine (parallelogram) meshes in 2D/3D.</p>
<p>This approximation is underlying the function <a class="el" href="classTriaAccessor.html#a3814b2ee53cd391e23dd4448a3d78abd">TriaAccessor::real_to_unit_cell_affine_approximation()</a> function.</p>
<p>For exact transformations to the unit cell, use <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. </p>

</div>
</div>
<a id="abce56c4b1243683d716027b8d497250a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce56c4b1243683d716027b8d497250a">&#9670;&nbsp;</a></span>compute_aspect_ratio_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVector.html">Vector</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; GridTools::compute_aspect_ratio_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes an aspect ratio measure for all locally-owned active cells and fills a vector with one entry per cell, given a <code>triangulation</code> and <code>mapping</code>. The size of the vector that is returned equals the number of active cells. The vector contains zero for non locally-owned cells. The aspect ratio of a cell is defined as the ratio of the maximum to minimum singular value of the Jacobian, taking the maximum over all quadrature points of a quadrature rule specified via <code>quadrature</code>. For example, for the special case of rectangular elements in 2d with dimensions \(a\) and \(b\) ( \(a \geq b\)), this function returns the usual aspect ratio definition \(a/b\). The above definition using singular values is a generalization to arbitrarily deformed elements. This function is intended to be used for \(d=2,3\) space dimensions, but it can also be used for \(d=1\) returning a value of 1.</p>
<dl class="section note"><dt>Note</dt><dd>Inverted elements do not throw an exception. Instead, a value of inf is written into the vector in case of inverted elements.</dd>
<dd>
Make sure to use enough quadrature points for a precise calculation of the aspect ratio in case of deformed elements.</dd>
<dd>
In parallel computations the return value will have the length n_active_cells but the aspect ratio is only computed for the cells that are locally owned and placed at index <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">CellAccessor::active_cell_index()</a>, respectively. All other values are set to 0. </dd></dl>

</div>
</div>
<a id="aa6477e53e65dfbcaa0b2add902f4350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6477e53e65dfbcaa0b2add902f4350e">&#9670;&nbsp;</a></span>compute_maximum_aspect_ratio()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> GridTools::compute_maximum_aspect_ratio </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the maximum aspect ratio by taking the maximum over all cells.</p>
<dl class="section note"><dt>Note</dt><dd>When running in parallel with a <a class="el" href="classTriangulation.html">Triangulation</a> that supports MPI, this is a collective call and the return value is the maximum over all processors. </dd></dl>

</div>
</div>
<a id="a95e86bcbb9bfbf045da4b3922506ed7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e86bcbb9bfbf045da4b3922506ed7b">&#9670;&nbsp;</a></span>compute_bounding_box() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt;spacedim&gt; GridTools::compute_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the smallest box containing the entire triangulation.</p>
<p>If the input triangulation is a <code><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></code>, then each processor will compute a bounding box enclosing all locally owned, ghost, and artificial cells. In the case of a domain without curved boundaries, these bounding boxes will all agree between processors because the union of the areas occupied by artificial and ghost cells equals the union of the areas occupied by the cells that other processors own. However, if the domain has curved boundaries, this is no longer the case. The bounding box returned may be appropriate for the current processor, but different from the bounding boxes computed on other processors. </p>

</div>
</div>
<a id="a350e00a4c5194b3007de4ea4bb13930b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350e00a4c5194b3007de4ea4bb13930b">&#9670;&nbsp;</a></span>project_to_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;Iterator::AccessorType::space_dimension&gt; GridTools::project_to_object </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; Iterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>trial_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the point on the geometrical object <code>object</code> closest to the given point <code>trial_point</code>. For example, if <code>object</code> is a one-dimensional line or edge, then the returned point will be a point on the geodesic that connects the vertices as the manifold associated with the object sees it (i.e., the geometric line may be curved if it lives in a higher dimensional space). If the iterator points to a quadrilateral in a higher dimensional space, then the returned point lies within the convex hull of the vertices of the quad as seen by the associated manifold.</p>
<dl class="section note"><dt>Note</dt><dd>This projection is usually not well-posed since there may be multiple points on the object that minimize the distance. The algorithm used in this function is robust (and the output is guaranteed to be on the given <code>object</code>) but may only provide a few correct digits if the object has high curvature. If your manifold supports it then the specialized function <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold::project_to_manifold()</a> may perform better. </dd></dl>

</div>
</div>
<a id="a1118c2c0a54f980218460af5601562cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1118c2c0a54f980218460af5601562cf">&#9670;&nbsp;</a></span>get_coarse_mesh_description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std:: tuple&lt;std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;, std::vector&lt;<a class="el" href="structCellData.html">CellData</a>&lt;dim&gt; &gt;, <a class="el" href="structSubCellData.html">SubCellData</a>&gt; GridTools::get_coarse_mesh_description </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the arrays that define the coarse mesh of a <a class="el" href="classTriangulation.html">Triangulation</a>. This function is the inverse of <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">Triangulation::create_triangulation()</a>.</p>
<p>The return value is a tuple with the vector of vertices, the vector of cells, and a <a class="el" href="structSubCellData.html">SubCellData</a> structure. The latter contains additional information about faces and lines.</p>
<p>This function is useful in cases where one needs to deconstruct a <a class="el" href="classTriangulation.html">Triangulation</a> or manipulate the numbering of the vertices in some way: an example is <a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations()</a>. </p>

</div>
</div>
<a id="aa502b615730af32271d9da4206939a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa502b615730af32271d9da4206939a81">&#9670;&nbsp;</a></span>delete_unused_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_unused_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove vertices that are not referenced by any of the cells. This function is called by all <code>GridIn::read_*</code> functions to eliminate vertices that are listed in the input files but are not used by the cells in the input file. While these vertices should not be in the input from the beginning, they sometimes are, most often when some cells have been removed by hand without wanting to update the vertex lists, as they might be lengthy.</p>
<p>This function is called by all <code>GridIn::read_*</code> functions as the triangulation class requires them to be called with used vertices only. This is so, since the vertices are copied verbatim by that class, so we have to eliminate unused vertices beforehand.</p>
<p>Not implemented for the codimension one case. </p>

</div>
</div>
<a id="a2fb09f2e9812f04661f9ca79e598e197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb09f2e9812f04661f9ca79e598e197">&#9670;&nbsp;</a></span>delete_duplicated_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::delete_duplicated_vertices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>considered_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove vertices that are duplicated, due to the input of a structured grid, for example. If these vertices are not removed, the faces bounded by these vertices become part of the boundary, even if they are in the interior of the mesh.</p>
<p>This function is called by some <code>GridIn::read_*</code> functions. Only the vertices with indices in <code>considered_vertices</code> are tested for equality. This speeds up the algorithm, which is, for worst-case hyper cube geometries \(O(N^{3/2})\) in 2D and \(O(N^{5/3})\) in 3D: quite slow. However, if you wish to consider all vertices, simply pass an empty vector. In that case, the function fills <code>considered_vertices</code> with all vertices.</p>
<p>Two vertices are considered equal if their difference in each coordinate direction is less than <code>tol</code>. </p>

</div>
</div>
<a id="a26e0f86b3a9310f1952cfe29e1fe7bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e0f86b3a9310f1952cfe29e1fe7bd4">&#9670;&nbsp;</a></span>invert_all_negative_measure_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::invert_all_negative_measure_cells </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Grids generated by grid generators may have an orientation of cells which is the inverse of the orientation required by deal.II.</p>
<p>In 2d and 3d this function checks whether all cells have negative or positive measure/volume. In the former case, all cells are inverted. It does nothing in 1d.</p>
<p>The inversion of cells might also work when only a subset of all cells have negative volume. However, grids consisting of a mixture of negative and positively oriented cells are very likely to be broken. Therefore, an exception is thrown, in case cells are not uniformly oriented.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called before <a class="el" href="namespaceGridTools.html#a8d5f04ca06ef2667c468296f538716e7">GridTools::consistently_order_cells()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all_vertices</td><td>The vertices of the mesh. </td></tr>
    <tr><td class="paramname">cells</td><td>The array of <a class="el" href="structCellData.html">CellData</a> objects that describe the mesh's topology. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d5f04ca06ef2667c468296f538716e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5f04ca06ef2667c468296f538716e7">&#9670;&nbsp;</a></span>consistently_order_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::consistently_order_cells </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a vector of <a class="el" href="structCellData.html">CellData</a> objects describing a mesh, reorder their vertices so that all lines are consistently oriented.</p>
<p>The expectations on orientation and a discussion of this function are available in the reordering module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cells</td><td>The array of <a class="el" href="structCellData.html">CellData</a> objects that describe the mesh's topology. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a212e99cf0d923cebfa04f1d23fa60b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212e99cf0d923cebfa04f1d23fa60b04">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Transformation , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::transform </td>
          <td>(</td>
          <td class="paramtype">const Transformation &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the vertices of the given triangulation by applying the function object provided as first argument to all its vertices.</p>
<p>The transformation given as argument is used to transform each vertex. Its respective type has to offer a function-like syntax, i.e. the predicate is either an object of a type that has an <code>operator()</code>, or it is a pointer to the function. In either case, argument and return value have to be of type <code><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The transformations that make sense to use with this function should have a Jacobian with a positive determinant. For example, rotation, shearing, stretching, or scaling all satisfy this (though there is no requirement that the transformation used actually is linear, as all of these examples are). On the other hand, reflections or inversions have a negative determinant of the Jacobian. The current function has no way of asserting a positive determinant of the Jacobian, but if you happen to use such a transformation, the result will be a triangulation in which cells have a negative volume.</dd>
<dd>
If you are using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> you will have hanging nodes in your local <a class="el" href="classTriangulation.html">Triangulation</a> even if your "global" mesh has no hanging nodes. This will cause issues with wrong positioning of hanging nodes in ghost cells if you call the current functions: The vertices of all locally owned cells will be correct, but the vertices of some ghost cells may not. This means that computations like <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> may give wrong answers.</dd>
<dd>
This function is in general not compatible with manifolds attached to the triangulation. For example, in order to refine the grid (using manifolds) after the grid transformation, you have to make sure that the original manifold is still valid for the transformed geometry. This does not hold in general, and it is necessary to clear the manifold and attach a new one for the transformed geometry in these cases. If you want to perform refinements according to the original manifold description attached to the triangulation, you should first do the refinements, subsequently deactivate all manifolds, and finally call the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function. The result is a triangulation with correctly transformed vertices, but otherwise straight-sided elements. The following procedure is recommended <div class="fragment"><div class="line">...</div><div class="line">triangulation.refine_global(n_refinements);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">Transformation&lt;dim&gt; transformation;</div><div class="line"><a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(transformation, triangulation);</div><div class="line">...</div></div><!-- fragment --></dd></dl>
<p>This function is used in the "Possibilities for extensions" section of step-38. It is also used in step-49 and step-53. </p>

</div>
</div>
<a id="a4b953611883979e3f920f800bd855df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b953611883979e3f920f800bd855df3">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift each vertex of the triangulation by the given shift vector. This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

</div>
</div>
<a id="a910bb99ec34eac082da97c08e7dd17c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910bb99ec34eac082da97c08e7dd17c3">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate all vertices of the given two-dimensional triangulation in counter-clockwise sense around the origin of the coordinate system by the given angle (given in radians, rather than degrees). This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only supported for dim=2. </dd></dl>

</div>
</div>
<a id="a580cbf329f016024a2e6b9d7eb9eed69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580cbf329f016024a2e6b9d7eb9eed69">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate all vertices of the given <code>triangulation</code> in counter-clockwise direction around the axis with the given index. Otherwise like the function above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>Angle in radians to rotate the <a class="el" href="classTriangulation.html">Triangulation</a> by. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Index of the coordinate axis to rotate around, keeping that coordinate fixed (0=x axis, 1=y axis, 2=z axis). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">triangulation</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object to rotate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for dim=1, 2, and 3. </dd></dl>

</div>
</div>
<a id="a7ed2aaa1aea3ac22b1e1807ce6d0b5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">&#9670;&nbsp;</a></span>laplace_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::laplace_transform </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>new_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>coefficient</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>solve_for_absolute_positions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the given triangulation smoothly to a different domain where, typically, each of the vertices at the boundary of the triangulation is mapped to the corresponding points in the <code>new_points</code> map.</p>
<p>The unknown displacement field \(u_d(\mathbf x)\) in direction \(d\) is obtained from the minimization problem </p><p class="formulaDsp">
\[ \min\, \int \frac{1}{2} c(\mathbf x) \mathbf \nabla u_d(\mathbf x) \cdot \mathbf \nabla u_d(\mathbf x) \,\rm d x \]
</p>
<p> subject to prescribed constraints. The minimizer is obtained by solving the Laplace equation of the dim components of a displacement field that maps the current domain into one described by <code>new_points</code> . Linear finite elements with four Gaussian quadrature points in each direction are used. The difference between the vertex positions specified in <code>new_points</code> and their current value in <code>tria</code> therefore represents the prescribed values of this displacement field at the boundary of the domain, or more precisely at all of those locations for which <code>new_points</code> provides values (which may be at part of the boundary, or even in the interior of the domain). The function then evaluates this displacement field at each unconstrained vertex and uses it to place the mapped vertex where the displacement field locates it. Because the solution of the Laplace equation is smooth, this guarantees a smooth mapping from the old domain to the new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_points</td><td>The locations where a subset of the existing vertices are to be placed. Typically, this would be a map from the vertex indices of all nodes on the boundary to their new locations, thus completely specifying the geometry of the mapped domain. However, it may also include interior points if necessary and it does not need to include all boundary vertices (although you then lose control over the exact shape of the mapped domain).</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object. This object is changed in- place, i.e., the previous locations of vertices are overwritten.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficient</td><td>An optional coefficient for the Laplace problem. Larger values make cells less prone to deformation (effectively increasing their stiffness). The coefficient is evaluated in the coordinate system of the old, undeformed configuration of the triangulation as input, i.e., before the transformation is applied. Should this function be provided, sensible results can only be expected if all coefficients are positive.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solve_for_absolute_positions</td><td>If set to <code>true</code>, the minimization problem is formulated with respect to the final vertex positions as opposed to their displacement. The two formulations are equivalent for the homogeneous problem (default value of <code>coefficient</code>), but they result in very different mesh motion otherwise. Since in most cases one will be using a non-constant coefficient in displacement formulation, the default value of this parameter is <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not currently implemented for the 1d case. </dd></dl>

</div>
</div>
<a id="a960178fc39f3b8bd68d62f5687bcbab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960178fc39f3b8bd68d62f5687bcbab0">&#9670;&nbsp;</a></span>get_all_vertices_at_boundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt; GridTools::get_all_vertices_at_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a std::map with all vertices of faces located in the boundary</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0967563badadd81f77f62622dd8bc2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0967563badadd81f77f62622dd8bc2cd">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scaling_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the entire triangulation by the given factor. To preserve the orientation of the triangulation, the factor must be positive.</p>
<p>This function uses the <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">transform()</a> function above, so the requirements on the triangulation stated there hold for this function as well. </p>

</div>
</div>
<a id="ac4e8aecd2cf74d3476e0daa11a00248b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e8aecd2cf74d3476e0daa11a00248b">&#9670;&nbsp;</a></span>distort_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::distort_random </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_boundary</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>seed</em> = <code>boost::random::mt19937::default_seed</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distort the given triangulation by randomly moving around all the vertices of the grid. The direction of movement of each vertex is random, while the length of the shift vector has a value of <code>factor</code> times the minimal length of the active edges adjacent to this vertex. Note that <code>factor</code> should obviously be well below <code>0.5</code>.</p>
<p>If <code>keep_boundary</code> is set to <code>true</code> (which is the default), then boundary vertices are not moved.</p>
<p><code>seed</code> is used for the initialization of the random engine. Its default value initializes the engine with the same state as in previous versions of deal.II. </p>

</div>
</div>
<a id="a62b77b07123012706fbadf91d8f022b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b77b07123012706fbadf91d8f022b3">&#9670;&nbsp;</a></span>remove_hanging_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::remove_hanging_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove hanging nodes from a grid. If the <code>isotropic</code> parameter is set to <code>false</code> (default) this function detects cells with hanging nodes and refines the neighbours in the direction that removes hanging nodes. If the <code>isotropic</code> parameter is set to <code>true</code>, the neighbours refinement is made in each directions. In order to remove all hanging nodes this procedure has to be repeated: this could require a large number of iterations. To avoid this a max number (<code>max_iterations</code>) of iteration is provided.</p>
<p>Consider the following grid: </p><div class="image">
<img src="remove_hanging_nodes-hanging.png" alt="remove_hanging_nodes-hanging.png"/>
</div>
<p><code>isotropic</code> == <code>false</code> would return: </p><div class="image">
<img src="remove_hanging_nodes-aniso.png" alt="remove_hanging_nodes-aniso.png"/>
</div>
<p><code>isotropic</code> == <code>true</code> would return: </p><div class="image">
<img src="remove_hanging_nodes-isotro.png" alt="remove_hanging_nodes-isotro.png"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a> to refine.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isotropic</td><td>If true refine cells in each directions, otherwise (default value) refine the cell in the direction that removes hanging node.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iterations</td><td>At each step only closest cells to hanging nodes are refined. The code may require a lot of iterations to remove all hanging nodes. <code>max_iterations</code> is the maximum number of iteration allowed. If <code>max_iterations</code> == <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> this function continues refining until there are no hanging nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In the case of parallel codes, this function should be combined with <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a>. </dd></dl>

</div>
</div>
<a id="a40336842aa2faac805746dc10c7c604f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40336842aa2faac805746dc10c7c604f">&#9670;&nbsp;</a></span>remove_anisotropy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::remove_anisotropy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>max_ratio</em> = <code>1.6180339887</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine a mesh anisotropically such that the resulting mesh is composed by cells with maximum ratio between dimensions less than <code>max_ratio</code>. This procedure requires an algorithm that may not terminate. Consequently, it is possible to set a maximum number of iterations through the <code>max_iterations</code> parameter.</p>
<p>Starting from a cell like this: </p><div class="image">
<img src="remove_anisotropy-coarse.png" alt="remove_anisotropy-coarse.png"/>
</div>
<p>This function would return: </p><div class="image">
<img src="remove_anisotropy-refined.png" alt="remove_anisotropy-refined.png"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a> to refine.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_ratio</td><td>Maximum value allowed among the ratio between the dimensions of each cell.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iterations</td><td>Maximum number of iterations allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In the case of parallel codes, this function should be combined with <a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">GridGenerator::flatten_triangulation</a> and <a class="el" href="namespaceGridTools.html#a62b77b07123012706fbadf91d8f022b3">GridTools::remove_hanging_nodes</a>. </dd></dl>

</div>
</div>
<a id="a3f129213c63c92a6ed84c6f2a906048b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f129213c63c92a6ed84c6f2a906048b">&#9670;&nbsp;</a></span>regularize_corner_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::regularize_corner_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>limit_angle_fraction</em> = <code>.75</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analyze the boundary cells of a mesh, and if one cell is found at a corner position (with dim adjacent faces on the boundary), and its dim-dimensional angle fraction exceeds <code>limit_angle_fraction</code>, refine globally once, and replace the children of such cell with children where the corner is no longer offending the given angle fraction.</p>
<p>If no boundary cells exist with two adjacent faces on the boundary, then the triangulation is left untouched. If instead we do have cells with dim adjacent faces on the boundary, then the fraction between the dim-dimensional solid angle and dim*pi/2 is checked against the parameter <code>limit_angle_fraction</code>. If it is higher, the grid is refined once, and the children of the offending cell are replaced with some cells that instead respect the limit. After this process the triangulation is flattened, and all <a class="el" href="classManifold.html">Manifold</a> objects are restored as they were in the original triangulation.</p>
<p>An example is given by the following mesh, obtained by attaching a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> to a mesh generated using <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div></div><!-- fragment --><div class="image">
<img src="regularize_mesh_01.png" alt="regularize_mesh_01.png"/>
</div>
 <p>The four cells that were originally the corners of a square will give you some troubles during computations, as the jacobian of the transformation from the reference cell to those cells will go to zero, affecting the error constants of the finite element estimates.</p>
<p>Those cells have a corner with an angle that is very close to 180 degrees, i.e., an angle fraction very close to one.</p>
<p>The same code, adding a call to regularize_corner_cells: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div><div class="line"><a class="code" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a>(tria);</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div></div><!-- fragment --><p> generates a mesh that has a much better behavior w.r.t. the jacobian of the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a>:</p>
<div class="image">
<img src="regularize_mesh_02.png" alt="regularize_mesh_02.png"/>
</div>
 <p>This mesh is very similar to the one obtained by <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>. However, using <a class="el" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a> one has the freedom to choose when to apply the regularization, i.e., one could in principle first refine a few times, and then call the regularize_corner_cells function:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;dim&gt;</a> m0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> tria;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria,-1,1);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(0, m0);</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line"><a class="code" href="namespaceGridTools.html#a3f129213c63c92a6ed84c6f2a906048b">GridTools::regularize_corner_cells</a>(tria);</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div></div><!-- fragment --><p>This generates the following mesh:</p>
<div class="image">
<img src="regularize_mesh_03.png" alt="regularize_mesh_03.png"/>
</div>
 <p>The function is currently implemented only for dim = 2 and will throw an exception if called with dim = 3.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a> to regularize.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">limit_angle_fraction</td><td>Maximum ratio of angle or solid angle that is allowed for a corner element in the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e8bb9211264d2106758ac4d7184117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8bb9211264d2106758ac4d7184117e">&#9670;&nbsp;</a></span>compute_point_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::compute_point_locations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;::active_cell_iterator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classTriangulation.html">Triangulation</a>'s <code>cache</code> and a list of <code>points</code>, call <a class="el" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">find_active_cell_around_point()</a> on each element of <code>points</code>, and return <code>cells</code>, reference positions <code>qpoints</code>, and a mapping <code>maps</code> from local to global indices into <code>points</code> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>The triangulation's <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>The point's vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_hint</td><td>(optional) A cell iterator for a cell which likely contains the first point of <code>points</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the following information:<ul>
<li><code>cells</code> : A vector of all the cells containing at least one of the <code>points</code> .</li>
<li><code>qpoints</code> : A vector of vectors of points. <code>qpoints</code>[i] contains the reference positions of all points that fall within the cell <code>cells</code>[i] .</li>
<li><code>indices</code> : A vector of vectors of integers, containing the mapping between local numbering in <code>qpoints</code> , and global index in <code>points</code> .</li>
</ul>
</dd></dl>
<p>If <code>points</code>[a] and <code>points</code>[b] are the only two points that fall in <code>cells</code>[c], then <code>qpoints</code>[c][0] and <code>qpoints</code>[c][1] are the reference positions of <code>points</code>[a] and <code>points</code>[b] in <code>cells</code>[c], and <code>indices</code>[c][0] = a, <code>indices</code>[c][1] = b. The function Mapping::transform_unit_to_real(qpoints[c][0]) returns <code>points</code>[a].</p>
<p>The algorithm builds an rtree of <code>points</code> to sort them spatially, before attempting to call <a class="el" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">find_active_cell_around_point()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not implemented for the codimension one case (<code>spacedim != dim</code>).</dd>
<dd>
If a point is not found inside the mesh, or is lying inside an artificial cell of a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>, the point is silently ignored. If you want to infer for which points the search failed, use the function <a class="el" href="namespaceGridTools.html#a5a845642f4d205352931267b58055d62">compute_point_locations_try_all()</a> that also returns a vector of indices indicating the points for which the search failed.</dd>
<dd>
The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line">std::tuple&lt;</div><div class="line">  std::vector&lt;</div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim, spacedim&gt;::active_cell_iterator</a>&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;</div></div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page.</dd>
<dd>
This function optimizes the search by making use of <a class="el" href="classGridTools_1_1Cache.html#a2350605fd3cd20b4df7eec0012974e5f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>, which either returns a cached rtree or builds and stores one. Building an rtree might hinder the performance if the function is called only once on few points. </dd></dl>

</div>
</div>
<a id="a5a845642f4d205352931267b58055d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a845642f4d205352931267b58055d62">&#9670;&nbsp;</a></span>compute_point_locations_try_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::compute_point_locations_try_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;::active_cell_iterator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is similar to <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>, but while <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">compute_point_locations()</a> silently ignores all points for which <a class="el" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">find_active_cell_around_point()</a> fails, this function also returns a vector containing the indices of the points for which <a class="el" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">find_active_cell_around_point()</a> failed.</p>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing four elements; the first three are documented in <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>. The last element of the <code>return_type</code> contains the indices of points which are neither found inside the mesh nor lie in artificial cells. The <code>return_type</code> equals the following tuple type: <div class="fragment"><div class="line">std::tuple&lt;</div><div class="line">  std::vector&lt;</div><div class="line">     <span class="keyword">typename</span> <a class="code" href="classTriaActiveIterator.html">Triangulation&lt;dim,spacedim&gt;::active_cell_iterator</a>&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div><div class="line">  std::vector&lt;unsigned int&gt;</div><div class="line">&gt;</div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not implemented for the codimension one case (<code>spacedim != dim</code>).</dd>
<dd>
This function optimizes the search by making use of <a class="el" href="classGridTools_1_1Cache.html#a2350605fd3cd20b4df7eec0012974e5f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>, which either returns a cached rtree or builds and stores one. Building an rtree might hinder the performance if the function is called only once on few points.</dd></dl>
<p>For a more detailed documentation see <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>. </p>

</div>
</div>
<a id="afe6eff31d194dd4beafc9eb6a22c5e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6eff31d194dd4beafc9eb6a22c5e27">&#9670;&nbsp;</a></span>distributed_compute_point_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::distributed_compute_point_locations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_bboxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a <code>cache</code> and a list of <code>local_points</code> for each process, find the points lying on the locally owned part of the mesh and compute the quadrature rules for them. Distributed compute point locations is a function similar to <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> but working for <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> objects and, unlike its serial version, also for a distributed triangulation (see <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_points</td><td>the array of points owned by the current process. Every process can have a different array of points which can be empty and not contained within the locally owned part of the triangulation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bboxes</td><td>a vector of vectors of bounding boxes; it describes the locally owned part of the mesh for each process. The bounding boxes describing which part of the mesh is locally owned by process with rank rk are contained in global_bboxes[rk]. The local description can be obtained from <a class="el" href="namespaceGridTools.html#ab6ed37fb4458b7a7c782afdb9d0d2664">GridTools::compute_mesh_predicate_bounding_box</a>; then the global one can be obtained using either <a class="el" href="namespaceGridTools.html#a3843115e3b2380ce9980335c0454a804">GridTools::exchange_local_bounding_boxes</a> or <a class="el" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Tolerance in terms of unit cell coordinates. Depending on the problem, it might be necessary to adjust the tolerance in order to be able to identify a cell. Floating point arithmetic implies that a point will, in general, not lie exactly on a vertex, edge, or face. In either case, it is not predictable which of the cells adjacent to a vertex or an edge/face this function returns. Consequently, algorithms that call this function need to take into account that the returned cell will only contain the point approximately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the quadrature information</dd></dl>
<p>The elements of the output tuple are:</p><ul>
<li>cells : a vector of all cells containing at least one point.</li>
<li>qpoints : a vector of vector of points; containing in <code>qpoints</code>[i] the reference positions of all points that fall within the cell <code>cells</code>[i] .</li>
<li>maps : a vector of vector of integers, containing the mapping between the numbering in qpoints (previous element of the tuple), and the vector of local points of the process owning the points.</li>
<li>points : a vector of vector of points. <code>points</code>[i][j] is the point in the real space corresponding. to <code>qpoints</code>[i][j] . Notice <code>points</code> are the points lying on the locally owned part of the mesh; thus these can be either copies of <code>local_points</code> or points received from other processes i.e. local_points for other processes</li>
<li>owners : a vector of vectors; <code>owners</code>[i][j] contains the rank of the process owning the point[i][j] (previous element of the tuple).</li>
</ul>
<p>The function uses the triangulation's mpi communicator: for this reason it throws an assert error if the <a class="el" href="classTriangulation.html">Triangulation</a> is not derived from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> .</p>
<p>In a serial execution the first three elements of the tuple are the same as in <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> .</p>
<p>Note: this function is a collective operation.</p>
<dl class="section note"><dt>Note</dt><dd>The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line">std::tuple&lt;</div><div class="line">  std::vector&lt;</div><div class="line">    <span class="keyword">typename</span> Triangulation&lt;dim, spacedim&gt;::active_cell_iterator&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;Point&lt;dim&gt;&gt;&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;Point&lt;spacedim&gt;&gt;&gt;,</div><div class="line">  std::vector&lt;std::vector&lt;unsigned int&gt;&gt;&gt;</div></div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page. </dd></dl>

</div>
</div>
<a id="a770c9eab75f60a58420c9e4c6573d2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770c9eab75f60a58420c9e4c6573d2ee">&#9670;&nbsp;</a></span>extract_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt; GridTools::extract_used_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;&#160;dim&#160;&gt;()&#160;.template&#160;<a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a map <code>vertex index -&gt; <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;</code> containing the used vertices of the given <code>container</code>. The key of the returned map (i.e., the first element of the pair above) is the global index in the triangulation, whereas the value of each pair is the physical location of the corresponding vertex. The used vertices are obtained by looping over all cells, and querying for each cell where its vertices are through the (optional) <code>mapping</code> argument.</p>
<p>In serial <a class="el" href="classTriangulation.html">Triangulation</a> objects and <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> objects, the size of the returned map equals <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a> (not <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a>). Note that in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, only vertices in locally owned cells and ghost cells are returned, as for all other vertices their real location might not be known (e.g. for distributed computations using <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>).</p>
<p>If you use the default <code>mapping</code>, the returned map satisfies the following equality:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> used_vertices = <a class="code" href="namespaceGridTools.html#a770c9eab75f60a58420c9e4c6573d2ee">extract_used_vertices</a>(tria);</div><div class="line"><span class="keyword">auto</span> all_vertices = tria.<a class="code" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;id_and_v : used_vertices)</div><div class="line">  all_vertices[id_and_v.first] == id_and_v.second; <span class="comment">// true</span></div></div><!-- fragment --><p>Notice that the above is not satisfied for mappings that change the location of vertices, like <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>.</p>
<p><a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container to extract vertices from. </td></tr>
    <tr><td class="paramname">mapping</td><td>The mapping to use to compute the points locations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f49d6a42c3dbabc53a86571e874cc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f49d6a42c3dbabc53a86571e874cc3f">&#9670;&nbsp;</a></span>find_closest_vertex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the index of the closest vertex to a given point in the map of vertices passed as the first argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>A map of index-&gt;vertex, as returned by <a class="el" href="namespaceGridTools.html#a770c9eab75f60a58420c9e4c6573d2ee">GridTools::extract_used_vertices()</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The target point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the vertex that is closest to the target point <code>p</code>. </dd></dl>

</div>
</div>
<a id="a07919e120e98a6a0139ffe8c9f4a2a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07919e120e98a6a0139ffe8c9f4a2a8b">&#9670;&nbsp;</a></span>find_closest_vertex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the index of the used vertex (or marked vertex) in a given mesh that is located closest to a given point.</p>
<p>This function uses the locations of vertices as stored in the triangulation. This is usually sufficient, unless you are using a <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> that moves the vertices around (for example, <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>). In this case, you should call the function with the same name and with an additional <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the closest vertex. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>An array of bools indicating which vertices of <code>mesh</code> will be considered within the search as the potentially closest vertex. On receiving a non-empty <code>marked_vertices</code>, the function will only search among <code>marked_vertices</code> for the closest vertex. The size of this array should be equal to the value returned by <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> for the triangulation underlying the given mesh (as opposed to the value returned by <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest vertex found. </dd></dl>

</div>
</div>
<a id="a84f7b02080d7740cdb0fe73f3917af36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f7b02080d7740cdb0fe73f3917af36">&#9670;&nbsp;</a></span>find_closest_vertex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::find_closest_vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return the index of the used vertex (or marked vertex) in a given mesh that is located closest to a given point. Use the given mapping to compute the actual location of the vertices.</p>
<p>If the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> does not modify the position of the mesh vertices (like, for example, <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> does), then this function is equivalent to the one with the same name, and without the <code>mapping</code> argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>A mapping used to compute the vertex locations </td></tr>
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the closest vertex. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>An array of bools indicating which vertices of <code>mesh</code> will be considered within the search as the potentially closest vertex. On receiving a non-empty <code>marked_vertices</code>, the function will only search among <code>marked_vertices</code> for the closest vertex. The size of this array should be equal to the value returned by <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation::n_vertices()</a> for the triangulation underlying the given mesh (as opposed to the value returned by <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the closest vertex found. </dd></dl>

</div>
</div>
<a id="a4111b7e10cb9b10f5f0d1d03654152e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4111b7e10cb9b10f5f0d1d03654152e1">&#9670;&nbsp;</a></span>find_cells_adjacent_to_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType&lt;dim, spacedim&gt;::active_cell_iterator&gt; GridTools::find_cells_adjacent_to_vertex </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find and return a vector of iterators to active cells that surround a given vertex with index <code>vertex_index</code>.</p>
<p>For locally refined grids, the vertex itself might not be a vertex of all adjacent cells that are returned. However, it will always be either a vertex of a cell or be a hanging node located on a face or an edge of it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">vertex_index</td><td>The index of the vertex for which we try to find adjacent cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of cells that lie adjacent to the given vertex.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It isn't entirely clear at this time whether the function does the right thing with anisotropically refined meshes. It needs to be checked for this case. </dd></dl>

</div>
</div>
<a id="a81430f37dc42f63e1cf0d3e62dc0a414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81430f37dc42f63e1cf0d3e62dc0a414">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename MeshType&lt;dim, spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an active non-artificial cell that surrounds a given point <code>p</code>. The return type is a pair of an iterator to the active cell along with the unit cell coordinates of the point.</p>
<p>The algorithm used in this function proceeds by first looking for the vertex located closest to the given point, see <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>. Secondly, all adjacent cells to this vertex are found in the mesh, see <a class="el" href="namespaceGridTools.html#a4111b7e10cb9b10f5f0d1d03654152e1">GridTools::find_cells_adjacent_to_vertex()</a>. Lastly, for each of these cells, the function tests whether the point is inside. This check is performed using the given <code>mapping</code> argument to determine whether cells have straight or curved boundaries.</p>
<p>If a point lies on the boundary of two or more cells, then the algorithm tries to identify the cell that is of highest refinement level.</p>
<p>If the point requested does not lie in a locally-owned or ghost cell, then this function will return the (invalid) <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">MeshType&lt;dim, spacedim&gt;::end()</a> iterator. This case can be handled similarly to the various <code><a class="el" href="namespacemystl.html#a8c9e318666ab4333e6cc33a054adceda">std::find()</a></code> and <code><a class="el" href="namespaceUtilities.html#aaa0f9cd449850bf25160131cc4bc5668">std::lower_bound()</a></code> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapping</td><td>The mapping used to determine whether the given point is inside a given cell. </td></tr>
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the surrounding cell. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>An array of <code>bool</code>s indicating whether an entry in the vertex array should be considered (and the others must be ignored) as the potentially closest vertex to the specified point. On specifying a non-default <code>marked_vertices</code>, <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">find_closest_vertex()</a> would only search among <code>marked_vertices</code> for the closest vertex. The size of this array should be equal to n_vertices() of the triangulation (as opposed to n_used_vertices() ). The motivation of using <code>marked_vertices</code> is to cut down the search space of vertices if one has a priori knowledge of a collection of vertices that the point of interest may be close to. </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance in terms of unit cell coordinates. Depending on the problem, it might be necessary to adjust the tolerance in order to be able to identify a cell. Floating point arithmetic implies that a point will, in general, not lie exactly on a vertex, edge, or face. In either case, it is not predictable which of the cells adjacent to a vertex or an edge/face this function returns. Consequently, algorithms that call this function need to take into account that the returned cell will only contain the point approximately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of an iterators into the mesh that points to the surrounding cell, and of the unit cell coordinates of that point. This local position might be located slightly outside an actual unit cell, due to numerical roundoff. Therefore, the point returned by this function should be projected onto the unit cell, using <a class="el" href="structGeometryInfo.html#aaae0fe397acba1d1079cbfa917b7046c">GeometryInfo::project_to_unit_cell()</a>. This is not automatically performed by the algorithm. The returned cell can be a locally-owned cell or a ghost cell (but not an artificial cell). The returned cell might be a ghost cell even if the given point is a vertex of a locally owned cell. The reason behind is that this is the only way to guarantee that all processors that participate in a parallel triangulation will agree which cell contains a point. For example, if two processors come together at one vertex and the function is called with this vertex, then one processor will return a locally owned cell and the other one a ghost cell. </dd></dl>

</div>
</div>
<a id="ad2ddac4773100d2e94724821ca57eef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ddac4773100d2e94724821ca57eef5">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MeshType&lt;dim, spacedim&gt;::active_cell_iterator GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A version of the above function that assumes straight boundaries and as a consequence simply calls the above function using <a class="el" href="classMappingQ1.html">MappingQ1</a> for the mapping argument.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator into the mesh that points to the surrounding cell. </dd></dl>

</div>
</div>
<a id="ad9b6a71ae04417bd4b1a3d6d237557f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b6a71ae04417bd4b1a3d6d237557f1">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another version where we use that mapping on a given cell that corresponds to the active finite element index of that cell. This is obviously only useful for hp-problems, since the active finite element index for all other DoF handlers is always zero. </p>

</div>
</div>
<a id="ac7644b2db63dcc544874c1497c6de1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7644b2db63dcc544874c1497c6de1a9">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">Cache</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;<a class="el" href="classTriangulation.html">Triangulation</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;::active_cell_iterator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finding an active non-artificial cell around a point can be very expensive in terms of computational costs. This function aims at providing a fast version of the above functions by using a space-tree to speed up the geometry search.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache</td><td>Object with information about the space-tree of a triangulation, see <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The point for which we want to find the surrounding cell. </td></tr>
    <tr><td class="paramname">cell_hint</td><td>Gives a hint for the geometry search, which is beneficial if a-priori knowledge is available regarding the cell on which the point may likely be located. A typical use case would be that this search has to be done for an array of points that are close to each other and where the adjacent cell of the previous point is a good hint for the next point in the array. </td></tr>
    <tr><td class="paramname">marked_vertices</td><td>See above. </td></tr>
    <tr><td class="paramname">tolerance</td><td>See above.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code example shows how to use this function:</p>
<div class="fragment"><div class="line"><a class="code" href="classGridTools_1_1Cache.html">GridTools::Cache&lt;dim, dim&gt;</a> cache(triangulation, mapping);</div><div class="line"><span class="keyword">auto</span> cell_hint = <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation&lt;dim, dim&gt;::active_cell_iterator</a>();</div><div class="line">std::vector&lt;bool&gt; marked_vertices = {};</div><div class="line"><span class="keywordtype">double</span> tolerance = 1.e-10;</div><div class="line"></div><div class="line">std::vector&lt;Point&lt;dim&gt;&gt; points; <span class="comment">// a vector of many points</span></div><div class="line">...</div><div class="line"></div><div class="line">for(<span class="keyword">auto</span> p : points)</div><div class="line">{</div><div class="line">  <span class="keyword">auto</span> cell_and_ref_point = <a class="code" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">GridTools::find_active_cell_around_point</a>(</div><div class="line">    cache, p, cell_hint, marked_vertices, tolerance);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (cell_and_ref_point.first != triangulation.<a class="code" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end</a>())</div><div class="line">    {</div><div class="line">     <span class="comment">// use current cell as hint for the next point</span></div><div class="line">     cell_hint = cell_and_ref_point.first;</div><div class="line">     <span class="comment">// do something with cell_and_ref_point</span></div><div class="line">     ...</div><div class="line">  }</div><div class="line"> <span class="keywordflow">else</span></div><div class="line">   {</div><div class="line">      <span class="comment">// The function did not find a locally owned or ghost cell in which</span></div><div class="line">      <span class="comment">// the point is located. We ought to handle this somehow here.</span></div><div class="line">   }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a6b35baf43f7ee073ac67431a8141df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b35baf43f7ee073ac67431a8141df62">&#9670;&nbsp;</a></span>find_active_cell_around_point() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;typename MeshType&lt;dim, spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; GridTools::find_active_cell_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::set&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_cell_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_cell_centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell_hint</em> = <code>typename&#160;MeshType&lt;&#160;dim,&#160;spacedim&#160;&gt;::active_cell_iterator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>used_vertices_rtree</em> = <code><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;&#160;std::pair&lt;&#160;<a class="el" href="classPoint.html">Point</a>&lt;&#160;spacedim&#160;&gt;,&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; *&#160;</td>
          <td class="paramname"><em>relevant_cell_bounding_boxes_rtree</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A version of the previous function that exploits an already existing map between vertices and cells (constructed using the function <a class="el" href="namespaceGridTools.html#a149baff9d70416e8c51b00ee88fc46ea">GridTools::vertex_to_cell_map()</a>), a map of vertex_to_cell_centers (obtained through <a class="el" href="namespaceGridTools.html#a963b408048697e309a808098c361b476">GridTools::vertex_to_cell_centers_directions()</a>), and optionally an RTree constructed from the used vertices of the <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<dl class="section note"><dt>Note</dt><dd>All of these structures can be queried from a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object. Note, however, that in this case MeshType has to be <a class="el" href="classTriangulation.html">Triangulation</a>, so that it might be more appropriate to directly call the function above with argument <code>cache</code> in this case. </dd></dl>

</div>
</div>
<a id="a2b45332283155be607e74d696dfd765c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b45332283155be607e74d696dfd765c">&#9670;&nbsp;</a></span>find_all_active_cells_around_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;typename MeshType&lt;dim, spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; &gt; GridTools::find_all_active_cells_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; typename MeshType&lt; dim, spacedim &gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>As compared to the functions above, this function identifies all active non-artificial cells around a point for a given tolerance level <code>tolerance</code> in terms of unit coordinates. Given a first cell with reference coordinates as parameter <code>first_cell</code>, e.g. obtained by one of the functions above, all corresponding neighboring cells with points in unit coordinates are also identified.</p>
<p>This function is useful e.g. for discontinuous function spaces where, for the case the given point <code>p</code> lies on a vertex, edge or face, several cells might hold independent values of the solution that get combined in some way in a user code.</p>
<p>This function is used as follows </p><div class="fragment"><div class="line"><span class="keyword">auto</span> first_pair = <a class="code" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">GridTools::find_active_cell_around_point</a>(...);</div><div class="line"><span class="keyword">auto</span> all_cells  = <a class="code" href="namespaceGridTools.html#a2b45332283155be607e74d696dfd765c">GridTools::find_all_active_cells_around_point</a>(</div><div class="line">                         mapping, mesh, p, tolerance, first_pair);</div></div><!-- fragment --> 
</div>
</div>
<a id="a6398d5b0c3c1c353ddbe8d04ee30958b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6398d5b0c3c1c353ddbe8d04ee30958b">&#9670;&nbsp;</a></span>find_all_active_cells_around_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, template&lt; int, int &gt; class MeshType, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;typename MeshType&lt;dim, spacedim&gt;::active_cell_iterator, <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; &gt; &gt; GridTools::find_all_active_cells_around_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_vertices</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A variant of the previous function that internally calls one of the functions <a class="el" href="namespaceGridTools.html#a81430f37dc42f63e1cf0d3e62dc0a414">find_active_cell_around_point()</a> to obtain a first cell, and subsequently adds all other active non-artificial cells by calling the function <a class="el" href="namespaceGridTools.html#a2b45332283155be607e74d696dfd765c">find_all_active_cells_around_point()</a> above. </p>

</div>
</div>
<a id="ab5c182c1901bb0d09046271809f918c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c182c1901bb0d09046271809f918c6">&#9670;&nbsp;</a></span>get_active_child_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType::active_cell_iterator&gt; GridTools::get_active_child_cells </td>
          <td>(</td>
          <td class="paramtype">const typename MeshType::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of all descendants of the given cell that are active. For example, if the current cell is once refined but none of its children are any further refined, then the returned list will contain all its children.</p>
<p>If the current cell is already active, then the returned list is empty (because the cell has no children that may be active).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active descendants of the given cell</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since in C++ the MeshType template argument can not be deduced from a function call, you will have to specify it after the function name, as for example in <div class="fragment"><div class="line">GridTools::get_active_child_cells&lt;DoFHandler&lt;dim&gt; &gt; (cell)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a30ccceb7c9216efc44dd4af561e0bea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ccceb7c9216efc44dd4af561e0bea0">&#9670;&nbsp;</a></span>get_active_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_active_neighbors </td>
          <td>(</td>
          <td class="paramtype">const typename MeshType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename MeshType::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the active cells around a given cell <code>cell</code> and return them in the vector <code>active_neighbors</code>. These neighbors are specifically the <em>face</em> neighbors of a cell or, if that neighbor is further refined, its active children that border on that face. On the other hand, the neighbors returned do not include cells that lie, for example, diagonally opposite to a vertex but are not face neighbors themselves. (In 3d, it also does not include cells that are adjacent to one of the edges of the current cell, but are not face neighbors.)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">active_neighbors</td><td>A list of active descendants of the given cell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Since in C++ the MeshType template argument can not be deduced from a function call, you will have to specify it after the function name, as for example in <div class="fragment"><div class="line">GridTools::get_active_neighbors&lt;DoFHandler&lt;dim&gt;&gt;(cell, active_neighbors)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a7d79ac1398633149f15b69831815d8c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d79ac1398633149f15b69831815d8c1">&#9670;&nbsp;</a></span>compute_active_cell_halo_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType::active_cell_iterator&gt; GridTools::compute_active_cell_halo_layer </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return the active cell layer around a subdomain (set of active cells) in the <code>mesh</code> (i.e. those that share a common set of vertices with the subdomain but are not a part of it). Here, the "subdomain" consists of exactly all of those cells for which the <code>predicate</code> returns <code>true</code>.</p>
<p>An example of a custom predicate is one that checks for a given material id </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span></div><div class="line">pred_mat_id(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> &amp; cell)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> cell-&gt;material_id() ==  1;</div><div class="line">}</div></div><!-- fragment --><p> and we can then extract the layer of cells around this material with the following call: </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a7d79ac1398633149f15b69831815d8c1">GridTools::compute_active_cell_halo_layer</a>(tria, pred_mat_id&lt;dim&gt;);</div></div><!-- fragment --><p>Predicates that are frequently useful can be found in namespace <a class="el" href="namespaceIteratorFilters.html">IteratorFilters</a>. For example, it is possible to extract a layer of cells around all of those cells with a given material id, </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a7d79ac1398633149f15b69831815d8c1">GridTools::compute_active_cell_halo_layer</a>(</div><div class="line">  tria, <a class="code" href="classIteratorFilters_1_1MaterialIdEqualTo.html">IteratorFilters::MaterialIdEqualTo</a>(1, <span class="keyword">true</span>));</div></div><!-- fragment --><p> or around all cells with one of a set of active FE indices for a <a class="el" href="classDoFHandler.html">DoFHandler</a> with hp-capabilities </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridTools.html#a7d79ac1398633149f15b69831815d8c1">GridTools::compute_active_cell_halo_layer</a>(</div><div class="line">  hp_dof_handler, <a class="code" href="classIteratorFilters_1_1ActiveFEIndexEqualTo.html">IteratorFilters::ActiveFEIndexEqualTo</a>({1,2}, <span class="keyword">true</span>));</div></div><!-- fragment --><p> Note that in the last two examples we ensure that the predicate returns true only for locally owned cells. This means that the halo layer will not contain any artificial cells.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">predicate</td><td>A function (or object of a type with an operator()) defining the subdomain around which the halo layer is to be extracted. It is a function that takes in an active cell and returns a boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells sharing at least one common vertex with the predicated subdomain. </dd></dl>

</div>
</div>
<a id="af3558d912b1294f2179dee890bbe8cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3558d912b1294f2179dee890bbe8cb6">&#9670;&nbsp;</a></span>compute_cell_halo_layer_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType::cell_iterator&gt; GridTools::compute_cell_halo_layer_on_level </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return the cell layer around a subdomain (set of cells) on a specified level of the <code>mesh</code> (i.e. those cells on that level that share a common set of vertices with the subdomain but are not a part of it). Here, the "subdomain" consists of exactly all of those cells for which the <code>predicate</code> returns <code>true</code>. </p>

</div>
</div>
<a id="a0117c7410775202cf35260713f88d691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0117c7410775202cf35260713f88d691">&#9670;&nbsp;</a></span>compute_ghost_cell_halo_layer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType::active_cell_iterator&gt; GridTools::compute_ghost_cell_halo_layer </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return ghost cells which are the active cell layer around all locally owned cells. This is most relevant for <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> where it will return a subset of all ghost cells on a processor, but for <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this will return all the ghost cells.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of ghost cells </dd></dl>

</div>
</div>
<a id="a737b9675dbefbeff9d9c819edbe92868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737b9675dbefbeff9d9c819edbe92868">&#9670;&nbsp;</a></span>compute_active_cell_layer_within_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType::active_cell_iterator&gt; GridTools::compute_active_cell_layer_within_distance </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>layer_thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return the set of active cells within a geometric distance of <code>layer_thickness</code> around a subdomain (set of active cells) in the <code>mesh</code>. Here, the "subdomain" consists of exactly all of those cells for which the <code>predicate</code> returns <code>true</code>.</p>
<p>The function first computes the cells that form the 'surface' of the subdomain that consists of all of the active cells for which the predicate is true. Using <a class="el" href="namespaceGridTools.html#a95e86bcbb9bfbf045da4b3922506ed7b">compute_bounding_box()</a>, a bounding box is computed for this subdomain and extended by <code>layer_thickness</code>. These cells are called interior subdomain boundary cells. The active cells with all of their vertices outside the extended bounding box are ignored. The cells that are inside the extended bounding box are then checked for their proximity to the interior subdomain boundary cells. This implies checking the distance between a pair of arbitrarily oriented cells, which is not trivial in general. To simplify this, the algorithm checks the distance between the two enclosing spheres of the cells. This will definitely result in slightly more cells being marked but also greatly simplifies the arithmetic complexity of the algorithm.</p>
<div class="image">
<img src="active_cell_layer_within_distance.png" alt="active_cell_layer_within_distance.png"/>
</div>
<p> The image shows a mesh generated by <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">subdivided_hyper_rectangle()</a>. The cells are marked using three different colors. If the grey colored cells in the image are the cells for which the predicate is true, then the function <a class="el" href="namespaceGridTools.html#a737b9675dbefbeff9d9c819edbe92868">compute_active_cell_layer_within_distance()</a> will return a set of cell iterators corresponding to the cells colored in red. The red colored cells are the active cells that are within a given distance to the grey colored cells.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>). </td></tr>
    <tr><td class="paramname">predicate</td><td>A function (or object of a type with an operator()) defining the subdomain around which the halo layer is to be extracted. It is a function that takes in an active cell and returns a boolean. </td></tr>
    <tr><td class="paramname">layer_thickness</td><td>specifies the geometric distance within which the function searches for active cells from the predicate domain. If the minimal distance between the enclosing sphere of the an active cell and the enclosing sphere of any of the cells for which the <code>predicate</code> returns <code>true</code> is less than <code>layer_thickness</code>, then the active cell is an <em>active_cell_within_distance</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells within a given geometric distance <code>layer_thickness</code> from the set of active cells for which the <code>predicate</code> returns <code>true</code>.</dd></dl>
<p>See <a class="el" href="namespaceGridTools.html#a7d79ac1398633149f15b69831815d8c1">compute_active_cell_halo_layer()</a>. </p>

</div>
</div>
<a id="a6d5f1dbc790083cb886c86b0a779776d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5f1dbc790083cb886c86b0a779776d">&#9670;&nbsp;</a></span>compute_ghost_cell_layer_within_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType::active_cell_iterator&gt; GridTools::compute_ghost_cell_layer_within_distance </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>layer_thickness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract and return a set of ghost cells which are within a <code>layer_thickness</code> around all locally owned cells. This is most relevant for <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> where it will return a subset of all ghost cells on a process, but for <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> this will return all the ghost cells. All the cells for the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> class that are not owned by the current processor can be considered as ghost cells; in particular, they do not only form a single layer of cells around the locally owned ones.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>). </td></tr>
    <tr><td class="paramname">layer_thickness</td><td>specifies the geometric distance within which the function searches for active cells from the locally owned cells. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A subset of ghost cells within a given geometric distance of <code>layer_thickness</code> from the locally owned cells of a current process.</dd></dl>
<p>Also see <a class="el" href="namespaceGridTools.html#a0117c7410775202cf35260713f88d691">compute_ghost_cell_halo_layer()</a> and <a class="el" href="namespaceGridTools.html#a737b9675dbefbeff9d9c819edbe92868">compute_active_cell_layer_within_distance()</a>. </p>

</div>
</div>
<a id="a663a467b31abdb8036b4986002f551c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663a467b31abdb8036b4986002f551c8">&#9670;&nbsp;</a></span>compute_bounding_box() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classPoint.html">Point</a>&lt;MeshType::space_dimension&gt;, <a class="el" href="classPoint.html">Point</a>&lt;MeshType::space_dimension&gt; &gt; GridTools::compute_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute and return a bounding box, defined through a pair of points bottom left and top right, that surrounds a subdomain of the <code>mesh</code>. Here, the "subdomain" consists of exactly all of those active cells for which the <code>predicate</code> returns <code>true</code>.</p>
<p>For a description of how <code>predicate</code> works, see <a class="el" href="namespaceGridTools.html#a7d79ac1398633149f15b69831815d8c1">compute_active_cell_halo_layer()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function was written before the <a class="el" href="classBoundingBox.html">BoundingBox</a> class was invented. Consequently, it returns a pair of points, rather than a <a class="el" href="classBoundingBox.html">BoundingBox</a> object as one may expect. However, <a class="el" href="classBoundingBox.html">BoundingBox</a> has a conversion constructor from pairs of points, so the result of this function can still be assigned to a <a class="el" href="classBoundingBox.html">BoundingBox</a> object. </dd></dl>

</div>
</div>
<a id="ab6ed37fb4458b7a7c782afdb9d0d2664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ed37fb4458b7a7c782afdb9d0d2664">&#9670;&nbsp;</a></span>compute_mesh_predicate_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classBoundingBox.html">BoundingBox</a>&lt;MeshType::space_dimension&gt; &gt; GridTools::compute_mesh_predicate_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>refinement_level</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_merge</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_boxes</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a collection of bounding boxes so that all active cells for which the given predicate is true, are completely enclosed in at least one of the bounding boxes. Notice the cover is only guaranteed to contain all these active cells but it's not necessarily exact i.e. it can include a bigger area than their union.</p>
<p>For each cell at a given refinement level containing active cells for which <code>predicate</code> is true, the function creates a bounding box of its children for which <code>predicate</code> is true.</p>
<p>This results in a cover of all active cells for which <code>predicate</code> is true; the parameters <code>allow_merge</code> and <code>max_boxes</code> are used to reduce the number of cells at a computational cost and covering a bigger n-dimensional volume.</p>
<p>The parameters to control the algorithm are:</p><ul>
<li><code>predicate</code> : the property of the cells to enclose e.g. <a class="el" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a> . The predicate is tested only on active cells.</li>
<li><code>refinement_level</code> : it defines the level at which the initial bounding box are created. The refinement should be set to a coarse refinement level. A bounding box is created for each active cell at coarser level than <code>refinement_level</code>; if <code>refinement_level</code> is higher than the number of levels of the triangulation an exception is thrown.</li>
<li><code>allow_merge</code> : This flag allows for box merging and, by default, is false. The algorithm has a cost of O(N^2) where N is the number of the bounding boxes created from the refinement level; for this reason, if the flag is set to true, make sure to choose wisely a coarse enough <code>refinement_level</code>.</li>
<li><code>max_boxes</code> : the maximum number of bounding boxes to compute. If more are created the smaller ones are merged with neighbors. By default after merging the boxes which can be expressed as a single one no more boxes are merged. See the <a class="el" href="classBoundingBox.html#a2ee80a34bb8b1d1b6727959e8ef992ad">BoundingBox::get_neighbor_type</a> () function for details. Notice only neighboring cells are merged (see the <code>get_neighbor_type</code> function in bounding box class): if the target number of bounding boxes max_boxes can't be reached by merging neighbors an exception is thrown</li>
</ul>
<p>The following image describes an example of the algorithm with <code>refinement_level</code> = 2, <code>allow_merge</code> = true and <code>max_boxes</code> = 1. The cells with the property predicate are in red, the area of a bounding box is slightly orange. </p><div class="image">
<img src="bounding_box_predicate.png" alt="bounding_box_predicate.png"/>
</div>
<ul>
<li>1. In black we can see the cells of the current level.</li>
<li>2. For each cell containing the red area a bounding box is created: by default these are returned.</li>
<li>3. Because <code>allow_merge</code> = true the number of bounding boxes is reduced while not changing the cover. If <code>max_boxes</code> was left as default or bigger than 1 these two boxes would be returned.</li>
<li>4. Because <code>max_boxes</code> = 1 the smallest bounding box is merged to the bigger one. Notice it is important to choose the parameters wisely. For instance, <code>allow_merge</code> = false and <code>refinement_level</code> = 1 returns the very same bounding box but with a fraction of the computational cost.</li>
</ul>
<p>This function does not take into account the curvature of cells and thus it is not suited for handling curved geometry: the mapping is assumed to be linear. </p>

</div>
</div>
<a id="a84063935e67e3a3bb5afadc7b00599ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84063935e67e3a3bb5afadc7b00599ac">&#9670;&nbsp;</a></span>guess_point_owner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::guess_point_owner </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>global_bboxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an array of points, use the global bounding box description obtained using <a class="el" href="namespaceGridTools.html#ab6ed37fb4458b7a7c782afdb9d0d2664">GridTools::compute_mesh_predicate_bounding_box</a> to guess, for each of them, which process might own it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">global_bboxes</td><td><a class="el" href="classVector.html">Vector</a> of bounding boxes describing the portion of mesh with a property for each process. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>Array of points to test.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the following information:<ul>
<li>A vector indicized with ranks of processes. For each rank it contains a vector of the indices of points it might own.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the rank of the owner.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the ranks of the guessed owners.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line">std::tuple&lt;std::vector&lt;std::vector&lt;unsigned int&gt;&gt;,</div><div class="line">           std::map&lt; unsigned int, unsigned int&gt;,</div><div class="line">           std::map&lt; unsigned int, std::vector&lt;unsigned int&gt;&gt;&gt;</div></div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page. </dd></dl>

</div>
</div>
<a id="a327cb9de55959193994a994047592ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327cb9de55959193994a994047592ec9">&#9670;&nbsp;</a></span>guess_point_owner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridTools::guess_point_owner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; std::pair&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>covering_rtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a covering rtree (see <a class="el" href="classGridTools_1_1Cache.html#a56d93d80716d8ac7f7fe67d4971a7434">GridTools::Cache::get_covering_rtree()</a>), and an array of points, find a superset of processes which, individually, may own the cell containing the points.</p>
<p>For further details see <a class="el" href="namespaceGridTools.html#a84063935e67e3a3bb5afadc7b00599ac">GridTools::guess_point_owner</a>; here only different input/output types are reported:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">covering_rtree</td><td>RTRee which enables us to identify which process(es) in a parallel computation may own the cell that surrounds a given point.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>A vector of points to consider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple containing the following information:<ul>
<li>A map indexed by processor ranks. For each rank it contains a vector of the indices of points it might own.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the rank of the owner; these are points for which a single possible owner was found.</li>
<li>A map from the index <code>unsigned int</code> of the point in <code>points</code> to the ranks of the guessed owners; these are points for which multiple possible owners were found.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual return type of this function, i.e., the type referenced above as <code>return_type</code>, is <div class="fragment"><div class="line">std::tuple&lt;std::map&lt;unsigned int, std::vector&lt;unsigned int&gt;&gt;,</div><div class="line">           std::map&lt;unsigned int, unsigned int&gt;,</div><div class="line">           std::map&lt;unsigned int, std::vector&lt;unsigned int&gt;&gt;&gt;</div></div><!-- fragment --> The type is abbreviated in the online documentation to improve readability of this page. </dd></dl>

</div>
</div>
<a id="a149baff9d70416e8c51b00ee88fc46ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149baff9d70416e8c51b00ee88fc46ea">&#9670;&nbsp;</a></span>vertex_to_cell_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::set&lt;typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::active_cell_iterator&gt; &gt; GridTools::vertex_to_cell_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the adjacent cells of all the vertices. If a vertex is also a hanging node, the associated coarse cell is also returned. The vertices are ordered by the vertex index. This is the number returned by the function <code>cell-&gt;vertex_index()</code>. Notice that only the indices marked in the array returned by <a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">Triangulation&lt;dim,spacedim&gt;::get_used_vertices()</a> are used. </p>

</div>
</div>
<a id="a963b408048697e309a808098c361b476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963b408048697e309a808098c361b476">&#9670;&nbsp;</a></span>vertex_to_cell_centers_directions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; &gt; &gt; GridTools::vertex_to_cell_centers_directions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector of normalized tensors for each vertex-cell combination of the output of <a class="el" href="namespaceGridTools.html#a149baff9d70416e8c51b00ee88fc46ea">GridTools::vertex_to_cell_map()</a> (which is expected as input parameter for this function). Each tensor represents a geometric vector from the vertex to the respective cell center.</p>
<p>An assertion will be thrown if the size of the input vector is not equal to the number of vertices of the triangulation.</p>
<p>result[v][c] is a unit <a class="el" href="classTensor.html">Tensor</a> for vertex index v, indicating the direction of the center of the c-th cell with respect to the vertex v. </p>

</div>
</div>
<a id="a2d9ac4e5783a4c13911c576064b255be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9ac4e5783a4c13911c576064b255be">&#9670;&nbsp;</a></span>find_closest_vertex_of_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::find_closest_vertex_of_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;&#160;dim&#160;&gt;()&#160;.template&#160;<a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local vertex index of cell <code>cell</code> that is closest to the given location <code>position</code>. The location of the vertices is extracted from the (optional) <code>mapping</code> argument, to guarantee that the correct answer is returned when the underlying mapping modifies the position of the vertices. </p>

</div>
</div>
<a id="a0dbda577beb1addbcd2e5ed867fdfc3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbda577beb1addbcd2e5ed867fdfc3c">&#9670;&nbsp;</a></span>compute_local_to_global_vertex_index_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="namespacetypes.html#a4fbb80cf1f559474b7f3044eaf08a078">types::global_vertex_index</a>&gt; GridTools::compute_local_to_global_vertex_index_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a globally unique index for each vertex and hanging node associated with a locally owned active cell. The vertices of a ghost cell that are hanging nodes of a locally owned cells have a global index. However, the other vertices of the cells that do not <em>touch</em> an active cell do not have a global index on this processor.</p>
<p>The key of the map is the local index of the vertex and the value is the global index. The indices need to be recomputed after refinement or coarsening and may be different. </p>

</div>
</div>
<a id="a64e99800a9a49575a928623f68deab7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e99800a9a49575a928623f68deab7b">&#9670;&nbsp;</a></span>get_longest_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classdouble.html">double</a>&gt; GridTools::get_longest_direction </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the highest value among ratios between extents in each of the coordinate directions of a <code>cell</code>. Moreover, return the dimension relative to the highest elongation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>an iterator pointing to the cell.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair&lt;unsigned int, double&gt; such that the <code>first</code> value is the dimension of the highest elongation and the <code>second</code> value is the ratio among the dimensions of the <code>cell</code>. </dd></dl>

</div>
</div>
<a id="a002fd376a184234ccbf5eca8f8fd7012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002fd376a184234ccbf5eca8f8fd7012">&#9670;&nbsp;</a></span>get_face_connectivity_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_face_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern in which nonzero entries indicate that two cells are connected via a common face. The diagonal entries of the sparsity pattern are also set.</p>
<p>The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

</div>
</div>
<a id="ab54e2fb68484ddaedaab56de13323169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54e2fb68484ddaedaab56de13323169">&#9670;&nbsp;</a></span>get_vertex_connectivity_of_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_vertex_connectivity_of_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern in which nonzero entries indicate that two cells are connected via a common vertex. The diagonal entries of the sparsity pattern are also set.</p>
<p>The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

</div>
</div>
<a id="acec0e25e2e5b5c9f359516d85ef29950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec0e25e2e5b5c9f359516d85ef29950">&#9670;&nbsp;</a></span>get_vertex_connectivity_of_cells_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_vertex_connectivity_of_cells_on_level </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>connectivity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a sparsity pattern for a given level mesh in which nonzero entries indicate that two cells are connected via a common vertex. The diagonal entries of the sparsity pattern are also set.</p>
<p>The rows and columns refer to the cells as they are traversed in their natural order using cell iterators. </p>

</div>
</div>
<a id="a99eba8e3b388258eda37a2724579dd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99eba8e3b388258eda37a2724579dd1d">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use graph partitioner to partition the active cells making up the entire domain. After calling this function, the subdomain ids of all active cells will have values between zero and <code>n_partitions-1</code>. You can access the subdomain id of a cell by using <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code>.</p>
<p>Use the third argument to select between partitioning algorithms provided by METIS or ZOLTAN. METIS is the default partitioner.</p>
<p>If deal.II was not installed with ZOLTAN or METIS, this function will generate an error when corresponding partition method is chosen, unless <code>n_partitions</code> is one. I.e., you can write a program so that it runs in the single-processor single-partition case without packages installed, and only requires them installed when multiple partitions are required.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>cell_weight</code> signal has been attached to the <code>triangulation</code>, then this will be used and passed to the partitioner. </dd></dl>

</div>
</div>
<a id="a72956e32f5a1091a6c8731b545e7fcbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72956e32f5a1091a6c8731b545e7fcbf">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function performs the same operation as the one above, except that it takes into consideration a specific set of <code>cell_weights</code>, which allow the partitioner to balance the graph while taking into consideration the computational effort expended on each cell.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>cell_weights</code> vector is empty, then no weighting is taken into consideration. If not then the size of this vector must equal to the number of active cells in the triangulation. </dd></dl>

</div>
</div>
<a id="a3c475677bc29b764e9fa5978d4d41f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c475677bc29b764e9fa5978d4d41f77">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_connection_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the previous one, i.e. it partitions a triangulation using a partitioning algorithm into a number of subdomains identified by the <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code> flag.</p>
<p>The difference to the previous function is the second argument, a sparsity pattern that represents the connectivity pattern between cells.</p>
<p>While the function above builds it directly from the triangulation by considering which cells neighbor each other, this function can take a more refined connectivity graph. The sparsity pattern needs to be of size \(N\times N\), where \(N\) is the number of active cells in the triangulation. If the sparsity pattern contains an entry at position \((i,j)\), then this means that cells \(i\) and \(j\) (in the order in which they are traversed by active cell iterators) are to be considered connected; partitioning algorithm will then try to partition the domain in such a way that (i) the subdomains are of roughly equal size, and (ii) a minimal number of connections are broken.</p>
<p>This function is mainly useful in cases where connections between cells exist that are not present in the triangulation alone (otherwise the previous function would be the simpler one to use). Such connections may include that certain parts of the boundary of a domain are coupled through symmetric boundary conditions or integrals (e.g. friction contact between the two sides of a crack in the domain), or if a numerical scheme is used that not only connects immediate neighbors but a larger neighborhood of cells (e.g. when solving integral equations).</p>
<p>In addition, this function may be useful in cases where the default sparsity pattern is not entirely sufficient. This can happen because the default is to just consider face neighbors, not neighboring cells that are connected by edges or vertices. While the latter couple when using continuous finite elements, they are typically still closely connected in the neighborship graph, and partitioning algorithm will not usually cut important connections in this case. However, if there are vertices in the mesh where many cells (many more than the common 4 or 6 in 2d and 3d, respectively) come together, then there will be a significant number of cells that are connected across a vertex, but several degrees removed in the connectivity graph built only using face neighbors. In a case like this, partitioning algorithm may sometimes make bad decisions and you may want to build your own connectivity graph.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>cell_weight</code> signal has been attached to the <code>triangulation</code>, then this will be used and passed to the partitioner. </dd></dl>

</div>
</div>
<a id="af499f992ff3d4716f7f15c55d68ade02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af499f992ff3d4716f7f15c55d68ade02">&#9670;&nbsp;</a></span>partition_triangulation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_connection_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3e">SparsityTools::Partitioner</a>&#160;</td>
          <td class="paramname"><em>partitioner</em> = <code><a class="el" href="namespaceSparsityTools.html#a34d8cbf5559e454001e512c4368c2c3ea523050e2859a16f13d8c0683d0806538">SparsityTools::Partitioner::metis</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function performs the same operation as the one above, except that it takes into consideration a specific set of <code>cell_weights</code>, which allow the partitioner to balance the graph while taking into consideration the computational effort expended on each cell.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>cell_weights</code> vector is empty, then no weighting is taken into consideration. If not then the size of this vector must equal to the number of active cells in the triangulation. </dd></dl>

</div>
</div>
<a id="a1951822ebc7a80fb21aea5d4cd6dac6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1951822ebc7a80fb21aea5d4cd6dac6c">&#9670;&nbsp;</a></span>partition_triangulation_zorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_triangulation_zorder </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>group_siblings</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a partitioning of the active cells making up the entire domain using the same partitioning scheme as in the p4est library if the flag <code>group_siblings</code> is set to true (default behavior of this function). After calling this function, the subdomain ids of all active cells will have values between zero and <code>n_partitions-1</code>. You can access the subdomain id of a cell by using <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>If the flag <code>group_siblings</code> is set to false, children of a cell might be placed on different processors even though they are all active, which is an assumption made by p4est. By relaxing this, we can create partitions owning a single cell (also for refined meshes). </dd></dl>

</div>
</div>
<a id="a70d37431a097d36fb7152c41e0352b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d37431a097d36fb7152c41e0352b5e">&#9670;&nbsp;</a></span>partition_multigrid_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::partition_multigrid_levels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partitions the cells of a multigrid hierarchy by assigning level subdomain ids using the "youngest child" rule, that is, each cell in the hierarchy is owned by the processor who owns its left most child in the forest, and active cells have the same subdomain id and level subdomain id. You can access the level subdomain id of a cell by using <code>cell-&gt;level_subdomain_id()</code>.</p>
<p>Note: This function assumes that the active cells have already been partitioned. </p>

</div>
</div>
<a id="a74728f76ec58b9956ca0a8f0dc06dfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74728f76ec58b9956ca0a8f0dc06dfa1">&#9670;&nbsp;</a></span>get_subdomain_association() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&gt; GridTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classCellId.html">CellId</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allows to ask for the owning subdomain of cells identified by <a class="el" href="classCellId.html">CellId</a> objects that do not have to exist on the current process.</p>
<dl class="section note"><dt>Note</dt><dd>This function has not been implemented yet for <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>. </dd></dl>

</div>
</div>
<a id="ae0cb61bdd7e17c6b1589bdd16891e561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cb61bdd7e17c6b1589bdd16891e561">&#9670;&nbsp;</a></span>get_subdomain_association() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::get_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each active cell, return in the output array to which subdomain (as given by the <code>cell-&gt;<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">subdomain_id()</a></code> function) it belongs. The output array is supposed to have the right size already when calling this function.</p>
<p>This function returns the association of each cell with one subdomain. If you are looking for the association of each <em>DoF</em> with a subdomain, use the <code><a class="el" href="namespaceDoFTools.html#a0429b3117b2ab1f5a1fd0d55de26ad81">DoFTools::get_subdomain_association</a></code> function. </p>

</div>
</div>
<a id="a8c212a30784bec20b1ae13fad3fd579c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c212a30784bec20b1ae13fad3fd579c">&#9670;&nbsp;</a></span>count_cells_with_subdomain_association()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> GridTools::count_cells_with_subdomain_association </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count how many cells are uniquely associated with the given <code>subdomain</code> index.</p>
<p>This function may return zero if there are no cells with the given <code>subdomain</code> index. This can happen, for example, if you try to partition a coarse mesh into more partitions (one for each processor) than there are cells in the mesh.</p>
<p>This function returns the number of cells associated with one subdomain. If you are looking for the association of <em>DoFs</em> with this subdomain, use the <code><a class="el" href="namespaceDoFTools.html#ac704c6d311cd0f289d625427e03708ac">DoFTools::count_dofs_with_subdomain_association</a></code> function. </p>

</div>
</div>
<a id="a538d5bfd6cea7aa42224ba8d5952dd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538d5bfd6cea7aa42224ba8d5952dd05">&#9670;&nbsp;</a></span>get_locally_owned_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; GridTools::get_locally_owned_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a triangulation, return a mask that represents which of its vertices are "owned" by the current process in the same way as we talk about locally owned cells or degrees of freedom (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a> and <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">GlossLocallyOwnedDof</a>). For the purpose of this function, we define a locally owned vertex as follows: a vertex is owned by that processor with the smallest subdomain id (which equals the MPI rank of that processor) among all owners of cells adjacent to this vertex. In other words, vertices that are in the interior of a partition of the triangulation are owned by the owner of this partition; for vertices that lie on the boundary between two or more partitions, the owner is the processor with the least subdomain_id among all adjacent subdomains.</p>
<p>For sequential triangulations (as opposed to, for example, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>), every user vertex is of course owned by the current processor, i.e., the function returns <a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">Triangulation::get_used_vertices()</a>. For parallel triangulations, the returned mask is a subset of what <a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">Triangulation::get_used_vertices()</a> returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>The triangulation of which the function evaluates which vertices are locally owned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The subset of vertices, as described above. The length of the returned array equals <a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">Triangulation.n_vertices()</a> and may, consequently, be larger than <a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">Triangulation::n_used_vertices()</a>. </dd></dl>

</div>
</div>
<a id="a56a519fc2d6485f487664d8b6a7c5d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a519fc2d6485f487664d8b6a7c5d10">&#9670;&nbsp;</a></span>get_finest_common_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::pair&lt;typename MeshType::cell_iterator, typename MeshType::cell_iterator&gt; &gt; GridTools::get_finest_common_cells </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two meshes (i.e. objects of type <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>) that are based on the same coarse mesh, this function figures out a set of cells that are matched between the two meshes and where at most one of the meshes is more refined on this cell. In other words, it finds the smallest cells that are common to both meshes, and that together completely cover the domain.</p>
<p>This function is useful, for example, in time-dependent or nonlinear application, where one has to integrate a solution defined on one mesh (e.g., the one from the previous time step or nonlinear iteration) against the shape functions of another mesh (the next time step, the next nonlinear iteration). If, for example, the new mesh is finer, then one has to obtain the solution on the coarse mesh (mesh_1) and interpolate it to the children of the corresponding cell of mesh_2. Conversely, if the new mesh is coarser, one has to express the coarse cell shape function by a linear combination of fine cell shape functions. In either case, one needs to loop over the finest cells that are common to both triangulations. This function returns a list of pairs of matching iterators to cells in the two meshes that can be used to this end.</p>
<p>Note that the list of these iterators is not necessarily ordered, and does also not necessarily coincide with the order in which cells are traversed in one, or both, of the meshes given as arguments.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can only be used with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> when both meshes use the same <a class="el" href="classTriangulation.html">Triangulation</a> since, with a distributed <a class="el" href="classTriangulation.html">Triangulation</a>, not all cells are stored locally, so the resulting list may not cover the entire domain. </dd></dl>

</div>
</div>
<a id="aae387b14cb19f14e3dbd3e0e1a3e3ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae387b14cb19f14e3dbd3e0e1a3e3ba2">&#9670;&nbsp;</a></span>have_same_coarse_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the two triangulations are based on the same coarse mesh. This is determined by checking whether they have the same number of cells on the coarsest level, and then checking that they have the same vertices.</p>
<p>The two meshes may have different refinement histories beyond the coarse mesh. </p>

</div>
</div>
<a id="abb75c70b1760c88a852413a1a9fae107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb75c70b1760c88a852413a1a9fae107">&#9670;&nbsp;</a></span>have_same_coarse_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::have_same_coarse_mesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same function as above, but working on arguments of type <a class="el" href="classDoFHandler.html">DoFHandler</a>. This function is provided to allow calling have_same_coarse_mesh for all types of containers representing triangulations or the classes built on triangulations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a964f88bdde9505bcbb863b801488ef8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964f88bdde9505bcbb863b801488ef8c">&#9670;&nbsp;</a></span>fix_up_distorted_child_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::DistortedCellList GridTools::fix_up_distorted_child_cells </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::DistortedCellList &amp;&#160;</td>
          <td class="paramname"><em>distorted_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a triangulation and a list of cells whose children have become distorted as a result of mesh refinement, try to fix these cells up by moving the center node around.</p>
<p>The function returns a list of cells with distorted children that couldn't be fixed up for whatever reason. The returned list is therefore a subset of the input argument.</p>
<p>For a definition of the concept of distorted cells, see the <a class="el" href="DEALGlossary.html#GlossDistorted">glossary entry</a>. The first argument passed to the current function is typically the exception thrown by the <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement</a> function. </p>

</div>
</div>
<a id="aea0b44d8461b32e6d3d90e2e02028e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0b44d8461b32e6d3d90e2e02028e62">&#9670;&nbsp;</a></span>get_patch_around_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename MeshType::active_cell_iterator&gt; GridTools::get_patch_around_cell </td>
          <td>(</td>
          <td class="paramtype">const typename MeshType::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns a list of all the active neighbor cells of the given, active cell. Here, a neighbor is defined as one having at least part of a face in common with the given cell, but not edge (in 3d) or vertex neighbors (in 2d and 3d).</p>
<p>The first element of the returned list is the cell provided as argument. The remaining ones are neighbors: The function loops over all faces of that given cell and checks if that face is not on the boundary of the domain. Then, if the neighbor cell does not have any children (i.e., it is either at the same refinement level as the current cell, or coarser) then this neighbor cell is added to the list of cells. Otherwise, if the neighbor cell is refined and therefore has children, then this function loops over all subfaces of current face adds the neighbors behind these sub-faces to the list to be returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. In C++, the compiler can not determine <code>MeshType</code> from the function call. You need to specify it as an explicit template argument following the function name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>An iterator pointing to a cell of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of active cells that form the patch around the given cell</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Patches are often used in defining error estimators that require the solution of a local problem on the patch surrounding each of the cells of the mesh. This also requires manipulating the degrees of freedom associated with the cells of a patch. To this end, there are further functions working on patches in namespace <a class="el" href="namespaceDoFTools.html">DoFTools</a>.</dd>
<dd>
In the context of a parallel distributed computation, it only makes sense to call this function on locally owned cells. This is because the neighbors of locally owned cells are either locally owned themselves, or ghost cells. For both, we know that these are in fact the real cells of the complete, parallel triangulation. We can also query the degrees of freedom on these. </dd></dl>

</div>
</div>
<a id="a7c90da78e89db4b78e772c0b8958e556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c90da78e89db4b78e772c0b8958e556">&#9670;&nbsp;</a></span>get_cells_at_coarsest_common_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Container::cell_iterator&gt; GridTools::get_cells_at_coarsest_common_level </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes a vector of active cells (hereafter named <code>patch_cells</code>) as input argument, and returns a vector of their parent cells with the coarsest common level of refinement. In other words, find that set of cells living at the same refinement level so that all cells in the input vector are children of the cells in the set, or are in the set itself.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>In C++, the compiler can not determine the type of <code>Container</code> from the function call. You need to specify it as an explicit template argument following the function name. This type has to satisfy the requirements of a mesh container (see <a class="el" href="group__Concepts.html#ConceptMeshType">ConceptMeshType</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch_cells</td><td>A vector of active cells for which this function finds the parents at the coarsest common level. This vector of cells typically results from calling the function <a class="el" href="namespaceGridTools.html#aea0b44d8461b32e6d3d90e2e02028e62">GridTools::get_patch_around_cell()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of cells with the coarsest common level of refinement of the input cells. </dd></dl>

</div>
</div>
<a id="aca3b216d4efc9d4add312c055a5ec95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3b216d4efc9d4add312c055a5ec95f">&#9670;&nbsp;</a></span>build_triangulation_from_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::build_triangulation_from_patch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; Container::dimension, Container::space_dimension &gt;::active_cell_iterator, typename Container::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>patch_to_global_tria_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function constructs a <a class="el" href="classTriangulation.html">Triangulation</a> (named <code>local_triangulation</code>) from a given vector of active cells. This vector (which we think of the cells corresponding to a "patch") contains active cells that are part of an existing global <a class="el" href="classTriangulation.html">Triangulation</a>. The goal of this function is to build a local <a class="el" href="classTriangulation.html">Triangulation</a> that contains only the active cells given in <code>patch</code> (and potentially a minimum number of additional cells required to form a valid <a class="el" href="classTriangulation.html">Triangulation</a>). The function also returns a map that allows to identify the cells in the output <a class="el" href="classTriangulation.html">Triangulation</a> and corresponding cells in the input list.</p>
<p>The function copies the location of vertices of cells from the cells of the source triangulation to the triangulation that is built from the list of patch cells. This adds support for triangulations which have been perturbed or smoothed in some manner which makes the triangulation deviate from the standard deal.II refinement strategy of placing new vertices at midpoints of faces or edges.</p>
<p>The operation implemented by this function is frequently used in the definition of error estimators that need to solve "local" problems on each cell and its neighbors. A similar construction is necessary in the definition of the Clement interpolation operator in which one needs to solve a local problem on all cells within the support of a shape function. This function then builds a complete <a class="el" href="classTriangulation.html">Triangulation</a> from a list of cells that make up such a patch; one can then later attach a <a class="el" href="classDoFHandler.html">DoFHandler</a> to such a <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>If the list of input cells contains only cells at the same refinement level, then the output <a class="el" href="classTriangulation.html">Triangulation</a> simply consists of a <a class="el" href="classTriangulation.html">Triangulation</a> containing only exactly these patch cells. On the other hand, if the input cells live on different refinement levels, i.e., the <a class="el" href="classTriangulation.html">Triangulation</a> of which they are part is adaptively refined, then the construction of the output <a class="el" href="classTriangulation.html">Triangulation</a> is not so simple because the coarsest level of a <a class="el" href="classTriangulation.html">Triangulation</a> can not contain hanging nodes. Rather, we first have to find the common refinement level of all input cells, along with their common parents (see <a class="el" href="namespaceGridTools.html#a7c90da78e89db4b78e772c0b8958e556">GridTools::get_cells_at_coarsest_common_level()</a>), build a <a class="el" href="classTriangulation.html">Triangulation</a> from those, and then adaptively refine it so that the input cells all also exist in the output <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>A consequence of this procedure is that the output <a class="el" href="classTriangulation.html">Triangulation</a> may contain more active cells than the ones that exist in the input vector. On the other hand, one typically wants to solve the local problem not on the entire output <a class="el" href="classTriangulation.html">Triangulation</a>, but only on those cells of it that correspond to cells in the input list. In this case, a user typically wants to assign degrees of freedom only on cells that are part of the "patch", and somehow ignore those excessive cells. The current function supports this common requirement by setting the user flag for the cells in the output <a class="el" href="classTriangulation.html">Triangulation</a> that match with cells in the input list. Cells which are not part of the original patch will not have their <code>user_flag</code> set; we can then avoid assigning degrees of freedom using the <a class="el" href="classFE__Nothing.html">FE_Nothing&lt;dim&gt;</a> element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>In C++, the compiler can not determine the type of <code>Container</code> from the function call. You need to specify it as an explicit template argument following the function name. This type that satisfies the requirements of a mesh container (see <a class="el" href="group__Concepts.html#ConceptMeshType">ConceptMeshType</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patch</td><td>A vector of active cells from a common triangulation. These cells may or may not all be at the same refinement level. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_triangulation</td><td>A triangulation whose active cells correspond to the given vector of active cells in <code>patch</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">patch_to_global_tria_map</td><td>A map between the local triangulation which is built as explained above, and the cell iterators in the input list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac136e217e9b0d4273d37d0db0c40f937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac136e217e9b0d4273d37d0db0c40f937">&#9670;&nbsp;</a></span>get_dof_to_support_patch_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, std::vector&lt;typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt;::active_cell_iterator&gt; &gt; GridTools::get_dof_to_support_patch_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function runs through the degrees of freedom defined by the <a class="el" href="classDoFHandler.html">DoFHandler</a> and for each dof constructs a vector of active_cell_iterators representing the cells of support of the associated basis element at that degree of freedom. This function was originally designed for the implementation of local projections, for instance the Clement interpolant, in conjunction with other local patch functions like <a class="el" href="namespaceGridTools.html#aca3b216d4efc9d4add312c055a5ec95f">GridTools::build_triangulation_from_patch</a>.</p>
<p><a class="el" href="classDoFHandler.html">DoFHandler</a>'s built on top of <a class="el" href="classTriangulation.html">Triangulation</a> or parallel:distributed::<a class="el" href="classTriangulation.html">Triangulation</a> are supported and handled appropriately.</p>
<p>The result is the patch of cells representing the support of the basis element associated to the degree of freedom. For instance using an <a class="el" href="classFE__Q.html">FE_Q</a> finite element, we obtain the standard patch of cells touching the degree of freedom and then add other cells that take care of possible hanging node constraints. Using a <a class="el" href="classFE__DGQ.html">FE_DGQ</a> finite element, the degrees of freedom are logically considered to be "interior" to the cells so the patch would consist exclusively of the single cell on which the degree of freedom is located.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> which could be built on a <a class="el" href="classTriangulation.html">Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> with a finite element that has degrees of freedom that are logically associated to a vertex, line, quad, or hex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from the global_dof_index of degrees of freedom on locally relevant cells to vectors containing <a class="el" href="group__CPP11.html#gaace8c98aca00e7e48a619bb5e08084aa">DoFHandler::active_cell_iterators</a> of cells in the support of the basis function at that degree of freedom. </dd></dl>

</div>
</div>
<a id="ac2a1903382c6cff07b33d456a641f6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a1903382c6cff07b33d456a641f6d9">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;&#160;1,&#160;FaceIterator::AccessorType::space_dimension&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An orthogonal equality test for faces.</p>
<p><code>face1</code> and <code>face2</code> are considered equal, if a one to one matching between its vertices can be achieved via an orthogonal equality relation.</p>
<p>Here, two vertices <code>v_1</code> and <code>v_2</code> are considered equal, if \(M\cdot v_1 + offset - v_2\) is parallel to the unit vector in unit direction <code>direction</code>. If the parameter <code>matrix</code> is a reference to a spacedim x spacedim matrix, \(M\) is set to <code>matrix</code>, otherwise \(M\) is the identity matrix.</p>
<p>If the matching was successful, the <em>relative</em> orientation of <code>face1</code> with respect to <code>face2</code> is returned in the bitset <code>orientation</code>, where </p><div class="fragment"><div class="line">orientation[0] -&gt; face_orientation</div><div class="line">orientation[1] -&gt; face_flip</div><div class="line">orientation[2] -&gt; face_rotation</div></div><!-- fragment --><p>In 2D <code>face_orientation</code> is always <code>true</code>, <code>face_rotation</code> is always <code>false</code>, and face_flip has the meaning of <code>line_flip</code>. More precisely in 3d:</p>
<p><code>face_orientation</code>: <code>true</code> if <code>face1</code> and <code>face2</code> have the same orientation. Otherwise, the vertex indices of <code>face1</code> match the vertex indices of <code>face2</code> in the following manner:</p>
<div class="fragment"><div class="line">face1:           face2:</div><div class="line"></div><div class="line">1 - 3            2 - 3</div><div class="line">|   |    &lt;--&gt;    |   |</div><div class="line">0 - 2            0 - 1</div></div><!-- fragment --><p><code>face_flip</code>: <code>true</code> if the matched vertices are rotated by 180 degrees:</p>
<div class="fragment"><div class="line">face1:           face2:</div><div class="line"></div><div class="line">1 - 0            2 - 3</div><div class="line">|   |    &lt;--&gt;    |   |</div><div class="line">3 - 2            0 - 1</div></div><!-- fragment --><p><code>face_rotation</code>: <code>true</code> if the matched vertices are rotated by 90 degrees counterclockwise:</p>
<div class="fragment"><div class="line">face1:           face2:</div><div class="line"></div><div class="line">0 - 2            2 - 3</div><div class="line">|   |    &lt;--&gt;    |   |</div><div class="line">1 - 3            0 - 1</div></div><!-- fragment --><p>and any combination of that... More information on the topic can be found in the <a class="el" href="DEALGlossary.html#GlossFaceOrientation">glossary</a> article. </p>

</div>
</div>
<a id="ace05eb85711971f65123e569fead988c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace05eb85711971f65123e569fead988c">&#9670;&nbsp;</a></span>orthogonal_equality() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FaceIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> GridTools::orthogonal_equality </td>
          <td>(</td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FaceIterator &amp;&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, FaceIterator::AccessorType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;&#160;1,&#160;FaceIterator::AccessorType::space_dimension&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but doesn't return the actual orientation </p>

</div>
</div>
<a id="aee88c4dce5066a41183b5dd70289b9df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee88c4dce5066a41183b5dd70289b9df">&#9670;&nbsp;</a></span>collect_periodic_faces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>::<a class="el" href="classTensor.html">Tensor</a>&lt;&#160;1,&#160;MeshType::space_dimension&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will collect periodic face pairs on the coarsest mesh level of the given <code>mesh</code> (a <a class="el" href="classTriangulation.html">Triangulation</a> or <a class="el" href="classDoFHandler.html">DoFHandler</a>) and add them to the vector <code>matched_pairs</code> leaving the original contents intact.</p>
<p>Define a 'first' boundary as all boundary faces having boundary_id <code>b_id1</code> and a 'second' boundary consisting of all faces belonging to <code>b_id2</code>.</p>
<p>This function tries to match all faces belonging to the first boundary with faces belonging to the second boundary with the help of <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a>.</p>
<p>The bitset that is returned inside of <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a> encodes the <em>relative</em> orientation of the first face with respect to the second face, see the documentation of <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a> for further details.</p>
<p>The <code>direction</code> refers to the space direction in which periodicity is enforced. When matching periodic faces this vector component is ignored.</p>
<p>The <code>offset</code> is a vector tangential to the faces that is added to the location of vertices of the 'first' boundary when attempting to match them to the corresponding vertices of the 'second' boundary. This can be used to implement conditions such as \(u(0,y)=u(1,y+1)\).</p>
<p>Optionally, a \(dim\times dim\) rotation <code>matrix</code> can be specified that describes how vector valued DoFs of the first face should be modified prior to constraining to the DoFs of the second face. The <code>matrix</code> is used in two places. First, <code>matrix</code> will be supplied to <a class="el" href="namespaceGridTools.html#ac2a1903382c6cff07b33d456a641f6d9">orthogonal_equality()</a> and used for matching faces: Two vertices \(v_1\) and \(v_2\) match if \(\text{matrix}\cdot v_1 + \text{offset} - v_2\) is parallel to the unit vector in unit direction <code>direction</code>. (For more details see <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a>, the glossary <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">glossary entry on periodic conditions</a> and step-45). Second, <code>matrix</code> will be stored in the <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a> collection <code>matched_pairs</code> for further use.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The created std::vector can be used in <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints()</a> and in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5ba7cf46ec43269f5ba430e91996d065">parallel::distributed::Triangulation::add_periodicity()</a> to enforce periodicity algebraically.</dd>
<dd>
Because elements will be added to <code>matched_pairs</code> (and existing entries will be preserved), it is possible to call this function several times with different boundary ids to generate a vector with all periodic pairs.</dd>
<dd>
Since the periodic face pairs are found on the coarsest mesh level, it is necessary to ensure that the coarsest level faces have the correct boundary indicators set. In general, this means that one must first set all boundary indicators on the coarse grid before performing any global or local grid refinement. </dd></dl>

</div>
</div>
<a id="ab22eef800535f9e85a1723a6a36fd0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22eef800535f9e85a1723a6a36fd0f6">&#9670;&nbsp;</a></span>collect_periodic_faces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_periodic_faces </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">PeriodicFacePair</a>&lt; typename MeshType::cell_iterator &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matched_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTensor.html">Tensor</a>&lt; 1, MeshType::space_dimension &gt; &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>::<a class="el" href="classTensor.html">Tensor</a>&lt;&#160;1,&#160;MeshType::space_dimension&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em> = <code><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This compatibility version of <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">collect_periodic_faces()</a> only works on grids with cells in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>.</p>
<p>Instead of defining a 'first' and 'second' boundary with the help of two boundary_ids this function defines a 'left' boundary as all faces with local face index <code>2*direction</code> and boundary indicator <code>b_id</code> and, similarly, a 'right' boundary consisting of all face with local face index <code>2*direction+1</code> and boundary indicator <code>b_id</code>. Faces with coordinates only differing in the <code>direction</code> component are identified.</p>
<p>This function will collect periodic face pairs on the coarsest mesh level and add them to <code>matched_pairs</code> leaving the original contents intact.</p>
<p>See above function for further details.</p>
<dl class="section note"><dt>Note</dt><dd>This version of <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">collect_periodic_faces()</a> will not work on meshes with cells not in <a class="el" href="DEALGlossary.html#GlossFaceOrientation">standard orientation</a>. </dd></dl>

</div>
</div>
<a id="a9565dbf2f8e45fee28e40806870e2c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9565dbf2f8e45fee28e40806870e2c98">&#9670;&nbsp;</a></span>exchange_cell_data_to_ghosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::exchange_cell_data_to_ghosts </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std_cxx17::optional&lt; DataType &gt;(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const typename MeshType::active_cell_iterator &amp;, const DataType &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>unpack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::active_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_filter</em> = <code><a class="el" href="structalways__return.html">always_return</a>&lt;&#160;typename&#160;MeshType::active_cell_iterator,&#160;<a class="el" href="classbool.html">bool</a>&#160;&gt;{true}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchange arbitrary data of type <code>DataType</code> provided by the function objects from locally owned cells to ghost cells on other processors.</p>
<p>After this call, you typically will have received data from <code>unpack</code> on every ghost cell as it was given by <code>pack</code> on the owning processor. Whether you do or do not receive information to <code>unpack</code> on a given ghost cell depends on whether the <code>pack</code> function decided that something needs to be sent. It does so using the std_cxx17::optional mechanism: if the std_cxx17::optional return object of the <code>pack</code> function is empty, then this implies that no data has to be sent for the locally owned cell it was called on. In that case, <code>unpack</code> will also not be called on the ghost cell that corresponds to it on the receiving side. On the other hand, if the std_cxx17::optional object is not empty, then the data stored within it will be sent to the received and the <code>unpack</code> function called with it.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>The type of the data to be communicated. It is assumed to be serializable by boost::serialization. In many cases, this data type can not be deduced by the compiler, e.g., if you provide lambda functions for the second and third argument to this function. In this case, you have to explicitly specify the <code>DataType</code> as a template argument to the function call. </td></tr>
    <tr><td class="paramname">MeshType</td><td>The type of <code>mesh</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A variable of a type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. </td></tr>
    <tr><td class="paramname">pack</td><td>The function that will be called on each locally owned cell that is a ghost cell somewhere else. As mentioned above, the function may return a regular data object of type <code>DataType</code> to indicate that data should be sent, or an empty <code>std_cxx17::optional&lt;DataType&gt;</code> to indicate that nothing has to be sent for this cell. </td></tr>
    <tr><td class="paramname">unpack</td><td>The function that will be called for each ghost cell for which data was sent, i.e., for which the <code>pack</code> function on the sending side returned a non-empty std_cxx17::optional object. The <code>unpack</code> function is then called with the data sent by the processor that owns that cell. </td></tr>
    <tr><td class="paramname">cell_filter</td><td>Only cells are communicated where this filter function returns the value <code>true</code>. In the default case, the function returns true on all cells and thus, all relevant cells are communicated.</td></tr>
  </table>
  </dd>
</dl>
<h4>An example </h4>
<p>Here is an example that shows how this function is to be used in a concrete context. It is taken from the code that makes sure that the <code>active_fe_index</code> (a single unsigned integer) is transported from locally owned cells where one can set it in <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities, to the corresponding ghost cells on other processors to ensure that one can query the right value also on those processors: </p><div class="fragment"><div class="line"><span class="keyword">using</span> active_cell_iterator =</div><div class="line">  typename ::DoFHandler&lt;dim,spacedim&gt;::active_cell_iterator;</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">pack</a> = [] (<span class="keyword">const</span> active_cell_iterator &amp;cell) -&gt; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">            {</div><div class="line">              <span class="keywordflow">return</span> cell-&gt;active_fe_index();</div><div class="line">            };</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">unpack</a> = [] (<span class="keyword">const</span> active_cell_iterator &amp;cell,</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> active_fe_index) -&gt; <span class="keywordtype">void</span></div><div class="line">              {</div><div class="line">                cell-&gt;set_active_fe_index(active_fe_index);</div><div class="line">              };</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridTools.html#a9565dbf2f8e45fee28e40806870e2c98">GridTools::exchange_cell_data_to_ghosts</a>&lt;</div><div class="line">  <span class="keywordtype">unsigned</span> <a class="code" href="classint.html">int</a>, <a class="code" href="classDoFHandler.html">::DoFHandler&lt;dim,spacedim&gt;</a>&gt; (dof_handler,</div><div class="line">                                                   <a class="code" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">pack</a>,</div><div class="line">                                                   <a class="code" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">unpack</a>);</div></div><!-- fragment --><p>You will notice that the <code>pack</code> lambda function returns an <code>unsigned int</code>, not a <code>std_cxx17::optional&lt;unsigned int&gt;</code>. The former converts automatically to the latter, implying that data will always be transported to the other processor.</p>
<p>(In reality, the <code>unpack</code> function needs to be a bit more complicated because it is not allowed to call DoFAccessor::set_active_fe_index() on ghost cells. Rather, the <code>unpack</code> function directly accesses internal data structures. But you get the idea &ndash; the code could, just as well, have exchanged material ids, user indices, boundary indicators, or any kind of other data with similar calls as the ones above.) </p>

</div>
</div>
<a id="aaf50b74d325f8e814bd03ef7654f880c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf50b74d325f8e814bd03ef7654f880c">&#9670;&nbsp;</a></span>exchange_cell_data_to_level_ghosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename MeshType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::exchange_cell_data_to_level_ghosts </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std_cxx17::optional&lt; DataType &gt;(const typename MeshType::level_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const typename MeshType::level_cell_iterator &amp;, const DataType &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>unpack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename MeshType::level_cell_iterator &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_filter</em> = <code><a class="el" href="structalways__return.html">always_return</a>&lt;&#160;typename&#160;MeshType::level_cell_iterator,&#160;<a class="el" href="classbool.html">bool</a>&#160;&gt;{&#160;true}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchange arbitrary data of type <code>DataType</code> provided by the function objects from locally owned level cells to ghost level cells on other processes.</p>
<p>In addition to the parameters of <a class="el" href="namespaceGridTools.html#a9565dbf2f8e45fee28e40806870e2c98">exchange_cell_data_to_ghosts()</a>, this function allows to provide a <code>cell_filter</code> function, which can be used to only communicate marked cells. In the default case, all relevant cells are communicated. </p>

</div>
</div>
<a id="a3843115e3b2380ce9980335c0454a804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3843115e3b2380ce9980335c0454a804">&#9670;&nbsp;</a></span>exchange_local_bounding_boxes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classBoundingBox.html">BoundingBox</a>&lt;spacedim&gt; &gt; &gt; GridTools::exchange_local_bounding_boxes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_bboxes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a457cb4c41d499faf229512ab30629eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457cb4c41d499faf229512ab30629eb2">&#9670;&nbsp;</a></span>build_global_description_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;std::pair&lt;<a class="el" href="classBoundingBox.html">BoundingBox</a>&lt;spacedim&gt;, unsigned <a class="el" href="classint.html">int</a>&gt; &gt; GridTools::build_global_description_tree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this collective operation each process provides a vector of bounding boxes and a communicator. All these vectors are gathered on each of the processes, organized in a search tree which, and then returned.</p>
<p>The idea is that the vector of bounding boxes describes a relevant property of the computations on each process individually, which could also be of use to other processes. An example would be if the input vector of bounding boxes corresponded to a covering of the locally owned partition of a mesh (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>) of a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. While these may overlap the bounding boxes of other processes, finding which process owns the cell that encloses a given point is vastly easier if the process trying to figure this out has a list of bounding boxes for each of the other processes at hand.</p>
<p>The returned search tree object is an r-tree with packing algorithm, which is provided by boost library. See <a href="https://www.boost.org/doc/libs/1_67_0/libs/geometry/doc/html/geometry/spatial_indexes/introduction.html">https://www.boost.org/doc/libs/1_67_0/libs/geometry/doc/html/geometry/spatial_indexes/introduction.html</a> for more information.</p>
<p>In the returned tree, each node contains a pair of elements: the first being a bounding box, the second being the rank of the process whose local description contains the bounding box.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a collective operation. </dd></dl>

</div>
</div>
<a id="a1ae36862c413167cf798e4b076dbc991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae36862c413167cf798e4b076dbc991">&#9670;&nbsp;</a></span>collect_coinciding_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::collect_coinciding_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coinciding_vertex_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_to_coinciding_vertex_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect for a given triangulation all locally relevant vertices that coincide due to periodicity.</p>
<p>Coinciding vertices are put into a group, e.g.: [1, 25, 51], which is labeled by an arbitrary element from it, e.g.: "1". All coinciding vertices store the label to its group, so that they can quickly access all the coinciding vertices in that group: e.g.: 51 -&gt; "1" -&gt; [1, 25, 51]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coinciding_vertex_groups</td><td>A map of equivalence classes (of coinciding vertices) labeled by an arbitrary element from them. Vertices not coinciding are ignored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertex_to_coinciding_vertex_group</td><td>Map of a vertex to the label of a group of coinciding vertices. Vertices not contained in this vector are not coinciding with any other vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3537ac484ba51325c7ca150ddaaf2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3537ac484ba51325c7ca150ddaaf2a5">&#9670;&nbsp;</a></span>compute_vertices_with_ghost_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;unsigned <a class="el" href="classint.html">int</a>, std::set&lt;::<a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&gt; &gt; GridTools::compute_vertices_with_ghost_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a map that, for each vertex, lists all the processes whose subdomains are adjacent to that vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b96d83a9f10a39048e1613fa8da8cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b96d83a9f10a39048e1613fa8da8cea">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidNumberOfPartitions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The number of partitions you gave is &quot;&lt;&lt; arg1&lt;&lt; &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but must be greater than zero.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a27708777444134752f8cc8138857df28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27708777444134752f8cc8138857df28">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcNonExistentSubdomain&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The subdomain id &quot;&lt;&lt; arg1&lt;&lt; &quot; has no cells associated with it.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a088ac82f79509dbe1dc9e8d25bc7e50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088ac82f79509dbe1dc9e8d25bc7e50a">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcTriangulationHasBeenRefined&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a1b3154f24e33be2d7f42a123c0654958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3154f24e33be2d7f42a123c0654958">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcScalingFactorNotPositive&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The scaling factor must be&#160;</td>
          <td class="paramname"><em>positive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but it is &quot;&lt;&lt; arg1&lt;&lt; &quot;.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a0d361c91586d139eebcf2404caeae61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d361c91586d139eebcf2404caeae61a">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridTools::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcVertexNotUsed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The given vertex with index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not used in the given triangulation.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="af34ed1fee44c7365f620b203b0c06974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34ed1fee44c7365f620b203b0c06974">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StreamType&amp; GridTools::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator which outputs assemble flags as a set of or'd text values.</p>
<p><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00101">101</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a10dd90fb8c8cd12d2d1215a4cc4f270d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10dd90fb8c8cd12d2d1215a4cc4f270d">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> GridTools::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which returns an object in which all bits are set which are either set in the first or the second argument. This operator exists since if it did not then the result of the bit-or <code>operator |</code> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type CacheUpdateFlags.</p>
<p><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00124">124</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="ad16a1564283fb76f8dc55443b0e6ee53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16a1564283fb76f8dc55443b0e6ee53">&#9670;&nbsp;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> GridTools::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which returns an object in which all bits are set which are not set in the argument. This operator exists since if it did not then the result of the bit-negation <code>operator ~</code> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type CacheUpdateFlags.</p>
<p><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00140">140</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="aaf5a34086f9e813638189fc7d72d3874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5a34086f9e813638189fc7d72d3874">&#9670;&nbsp;</a></span>operator|=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&amp; GridTools::operator|= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which sets the bits from the second argument also in the first one.</p>
<p><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00155">155</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a564267811af347736ab43b6ce0721d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564267811af347736ab43b6ce0721d49">&#9670;&nbsp;</a></span>operator &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> GridTools::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which returns an object in which all bits are set which are set in the first as well as the second argument. This operator exists since if it did not then the result of the bit-and <code>operator &amp;</code> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type CacheUpdateFlags.</p>
<p><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00171">171</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
<a id="a34b9c6e4eddef8e14827575aaf11af99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b9c6e4eddef8e14827575aaf11af99">&#9670;&nbsp;</a></span>operator &=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&amp; GridTools::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a>&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator which clears all the bits in the first argument if they are not also set in the second argument.</p>
<p><a class="el" href="namespaceGridTools.html#a995b90803c22dbe67fc6d510494b2e51">CacheUpdateFlags</a> </p>

<p class="definition">Definition at line <a class="el" href="grid__tools__cache__update__flags_8h_source.html#l00186">186</a> of file <a class="el" href="grid__tools__cache__update__flags_8h_source.html">grid_tools_cache_update_flags.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
