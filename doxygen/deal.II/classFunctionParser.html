<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFunctionParser.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FunctionParser&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFunctionParser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FunctionParser&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="function__parser_8h_source.html">deal.II/base/function_parser.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FunctionParser&lt; dim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFunctionParser__inherit__graph.svg" width="1799" height="199"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2426bdaf98de531415477667097235b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">ConstMap</a> = std::map&lt; std::string, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:a2426bdaf98de531415477667097235b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3a3152c1a97076b961dcb35a3bb36b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a> { <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36babf0b91e6181d44127eb8d23ff080f286">Euler</a>, 
<a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36bab261116ff92510dff59a179b43fdb444">UpwindEuler</a>, 
<a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36ba1d80de60e448c04501ec359c16b6c08d">FourthOrder</a>
 }</td></tr>
<tr class="separator:a8e3a3152c1a97076b961dcb35a3bb36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385ed76410d75f5f15304ccebaac220d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a385ed76410d75f5f15304ccebaac220d">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td></tr>
<tr class="separator:a385ed76410d75f5f15304ccebaac220d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0d7c78097d8aa1799a81d74f429aaa34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a0d7c78097d8aa1799a81d74f429aaa34">FunctionParser</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>=1, const <a class="el" href="classdouble.html">double</a> initial_time=0.0, const <a class="el" href="classdouble.html">double</a> <a class="el" href="classAutoDerivativeFunction.html#a204ccd3b85b37277a5cd0c878869fdc6">h</a>=1e-8)</td></tr>
<tr class="separator:a0d7c78097d8aa1799a81d74f429aaa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a025a34dddf97b70fa604da253561e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a5a025a34dddf97b70fa604da253561e4">FunctionParser</a> (const std::string &amp;expression, const std::string &amp;<a class="el" href="classFunctionParser.html#a28a412ab0963d8e01227df051439d4c3">constants</a>=&quot;&quot;, const std::string &amp;variable_names=<a class="el" href="classFunctionParser.html#ad2a69afb91de468f3bb2de6245258dd6">default_variable_names</a>()+&quot;,t&quot;, const <a class="el" href="classdouble.html">double</a> <a class="el" href="classAutoDerivativeFunction.html#a204ccd3b85b37277a5cd0c878869fdc6">h</a>=1e-8)</td></tr>
<tr class="separator:a5a025a34dddf97b70fa604da253561e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981060f088b43cdf6f9fac1b840d0346"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a981060f088b43cdf6f9fac1b840d0346">FunctionParser</a> (const <a class="el" href="classFunctionParser.html">FunctionParser</a> &amp;)=delete</td></tr>
<tr class="separator:a981060f088b43cdf6f9fac1b840d0346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4312d538a4c339c1d0aa92bd0e6c17cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a4312d538a4c339c1d0aa92bd0e6c17cb">FunctionParser</a> (<a class="el" href="classFunctionParser.html">FunctionParser</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a4312d538a4c339c1d0aa92bd0e6c17cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c3fa994097013c991d74002d3609a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#aa99c3fa994097013c991d74002d3609a">~FunctionParser</a> () override</td></tr>
<tr class="separator:aa99c3fa994097013c991d74002d3609a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f24fe8e0939be26ee10a25e9abfc50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctionParser.html">FunctionParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a16f24fe8e0939be26ee10a25e9abfc50">operator=</a> (const <a class="el" href="classFunctionParser.html">FunctionParser</a> &amp;)=delete</td></tr>
<tr class="separator:a16f24fe8e0939be26ee10a25e9abfc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32a0384dd8a6250399405b2370e22e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFunctionParser.html">FunctionParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#aa32a0384dd8a6250399405b2370e22e9">operator=</a> (<a class="el" href="classFunctionParser.html">FunctionParser</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aa32a0384dd8a6250399405b2370e22e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac973d1e4fc6912ccf833c108894e414"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a> (const std::string &amp;<a class="el" href="classFunctionParser.html#ac3bd431f237d7f893e898cedf63bbd06">vars</a>, const std::vector&lt; std::string &gt; &amp;<a class="el" href="classFunctionParser.html#a1f0b4911c4724b6a6d663d8316b3ee3b">expressions</a>, const <a class="el" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">ConstMap</a> &amp;<a class="el" href="classFunctionParser.html#a28a412ab0963d8e01227df051439d4c3">constants</a>, const <a class="el" href="classbool.html">bool</a> time_dependent=false)</td></tr>
<tr class="separator:aac973d1e4fc6912ccf833c108894e414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2331d2600f14502108e9770932e6dbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#ad2331d2600f14502108e9770932e6dbb">initialize</a> (const std::string &amp;<a class="el" href="classFunctionParser.html#ac3bd431f237d7f893e898cedf63bbd06">vars</a>, const std::string &amp;expression, const <a class="el" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">ConstMap</a> &amp;<a class="el" href="classFunctionParser.html#a28a412ab0963d8e01227df051439d4c3">constants</a>, const <a class="el" href="classbool.html">bool</a> time_dependent=false)</td></tr>
<tr class="separator:ad2331d2600f14502108e9770932e6dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382e05189908a8d462525824a74433e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a382e05189908a8d462525824a74433e9">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a382e05189908a8d462525824a74433e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56c50f2d585a27c3a26f2c0d3082263"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#ac56c50f2d585a27c3a26f2c0d3082263">vector_value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values) const override</td></tr>
<tr class="separator:ac56c50f2d585a27c3a26f2c0d3082263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9304a37a6c71122f0cf3e51e0db353f5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a9304a37a6c71122f0cf3e51e0db353f5">get_expressions</a> () const</td></tr>
<tr class="separator:a9304a37a6c71122f0cf3e51e0db353f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada47ab970ec0732a04b933dec44b3b1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoDerivativeFunction.html#ada47ab970ec0732a04b933dec44b3b1c">set_formula</a> (const <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a> <a class="el" href="classAutoDerivativeFunction.html#abf9fa4317f26a2be16b56a85ac4e050b">formula</a>=<a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36babf0b91e6181d44127eb8d23ff080f286">Euler</a>)</td></tr>
<tr class="separator:ada47ab970ec0732a04b933dec44b3b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcfb02bfd5543481d50cb0a98d01c14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoDerivativeFunction.html#a8dcfb02bfd5543481d50cb0a98d01c14">set_h</a> (const <a class="el" href="classdouble.html">double</a> <a class="el" href="classAutoDerivativeFunction.html#a204ccd3b85b37277a5cd0c878869fdc6">h</a>)</td></tr>
<tr class="separator:a8dcfb02bfd5543481d50cb0a98d01c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699fef370c63619a08aa94433f34136b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoDerivativeFunction.html#a699fef370c63619a08aa94433f34136b">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a699fef370c63619a08aa94433f34136b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030c5e1de5262221de1e545298470f19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoDerivativeFunction.html#a030c5e1de5262221de1e545298470f19">vector_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;gradients) const override</td></tr>
<tr class="separator:a030c5e1de5262221de1e545298470f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#af4509a9d71dc1a1ca05cb6205161dc60">vector_gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:af4509a9d71dc1a1ca05cb6205161dc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8535ed93698d68154fb3544272dad2dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoDerivativeFunction.html#a8535ed93698d68154fb3544272dad2dd">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;gradients, const unsigned <a class="el" href="classint.html">int</a> component=0) const override</td></tr>
<tr class="separator:a8535ed93698d68154fb3544272dad2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf557f137782b46e85461235d5bd47d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#afcf557f137782b46e85461235d5bd47d">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;gradients, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:afcf557f137782b46e85461235d5bd47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3872f43eb38248e3d87edeca0dfc2c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoDerivativeFunction.html#ad3872f43eb38248e3d87edeca0dfc2c4">vector_gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt;&gt; &amp;gradients) const override</td></tr>
<tr class="separator:ad3872f43eb38248e3d87edeca0dfc2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109f7bff0fb455c042086f98bd003ede"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a109f7bff0fb455c042086f98bd003ede">vector_gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classdouble.html">double</a> &gt;&gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:a109f7bff0fb455c042086f98bd003ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562fc1114e95e702e6696721f71528db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a562fc1114e95e702e6696721f71528db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa041dde994d40c068e00661197ac75a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aa041dde994d40c068e00661197ac75a6">vector_value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:aa041dde994d40c068e00661197ac75a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad1b4f548be005a1ffeeca7a450b028d8">vector_values</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:ad1b4f548be005a1ffeeca7a450b028d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a4ddbeb5adda74140a00dfc8db3687b4a">vector_gradients</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classdouble.html">double</a> &gt;&gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:a4ddbeb5adda74140a00dfc8db3687b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763c928e78dc33bbe50873128f06e153"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a763c928e78dc33bbe50873128f06e153">laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a763c928e78dc33bbe50873128f06e153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33430fb1069660fb8cfe599181aceefa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a33430fb1069660fb8cfe599181aceefa">vector_laplacian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values) const</td></tr>
<tr class="separator:a33430fb1069660fb8cfe599181aceefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae80353c3a581fa918ea555c3e1c7353"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#aae80353c3a581fa918ea555c3e1c7353">laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:aae80353c3a581fa918ea555c3e1c7353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6582ff5ce8fddc37866077976df598f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a6582ff5ce8fddc37866077976df598f9">vector_laplacian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:a6582ff5ce8fddc37866077976df598f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa2ec8f2270bdee842413805c4d7442"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a8aa2ec8f2270bdee842413805c4d7442">hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a8aa2ec8f2270bdee842413805c4d7442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94960fba14557566fa5df8745a721939"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a94960fba14557566fa5df8745a721939">vector_hessian</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:a94960fba14557566fa5df8745a721939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e69625d9daf07615270d65d97dfebde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a2e69625d9daf07615270d65d97dfebde">hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;values, const unsigned <a class="el" href="classint.html">int</a> component=0) const</td></tr>
<tr class="separator:a2e69625d9daf07615270d65d97dfebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b732264fb498528453312e24d2f49"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#abc1b732264fb498528453312e24d2f49">vector_hessian_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, <a class="el" href="classdouble.html">double</a> &gt;&gt;&gt; &amp;values) const</td></tr>
<tr class="separator:abc1b732264fb498528453312e24d2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e07b63ee34bd7e7ab2492be5213377"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a45e07b63ee34bd7e7ab2492be5213377">memory_consumption</a> () const</td></tr>
<tr class="separator:a45e07b63ee34bd7e7ab2492be5213377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () const</td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (const Number new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (const Number delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad2a69afb91de468f3bb2de6245258dd6"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#ad2a69afb91de468f3bb2de6245258dd6">default_variable_names</a> ()</td></tr>
<tr class="separator:ad2a69afb91de468f3bb2de6245258dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc1cb3077648bf52443c59372dbd3e18"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafc1cb3077648bf52443c59372dbd3e18">ExcParseError</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2)</td></tr>
<tr class="separator:gafc1cb3077648bf52443c59372dbd3e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162ae10375ba0e34500198c643f67cc7"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga162ae10375ba0e34500198c643f67cc7">ExcInvalidExpressionSize</a> (<a class="el" href="classint.html">int</a> arg1, <a class="el" href="classint.html">int</a> arg2)</td></tr>
<tr class="separator:ga162ae10375ba0e34500198c643f67cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58d24b47b673bba1d0dfc534f994304"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoDerivativeFunction.html#af58d24b47b673bba1d0dfc534f994304">get_formula_of_order</a> (const unsigned <a class="el" href="classint.html">int</a> ord)</td></tr>
<tr class="separator:af58d24b47b673bba1d0dfc534f994304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a></td></tr>
<tr class="separator:a7248c7e11dc434fb7d16cdc5e41e3770"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad8063ed9dcbe58753504d9173475befe"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunction.html#ad8063ed9dcbe58753504d9173475befe">dimension</a></td></tr>
<tr class="separator:ad8063ed9dcbe58753504d9173475befe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0a2705462fa483eeda48ff4350bd5a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a0a2705462fa483eeda48ff4350bd5a2c">init_muparser</a> () const</td></tr>
<tr class="separator:a0a2705462fa483eeda48ff4350bd5a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac3bd431f237d7f893e898cedf63bbd06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#ac3bd431f237d7f893e898cedf63bbd06">vars</a></td></tr>
<tr class="separator:ac3bd431f237d7f893e898cedf63bbd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9db54883b5a13707f5224aaa3b79c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; std::vector&lt; std::unique_ptr&lt; mu::Parser &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a8c9db54883b5a13707f5224aaa3b79c4">fp</a></td></tr>
<tr class="separator:a8c9db54883b5a13707f5224aaa3b79c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a412ab0963d8e01227df051439d4c3"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a28a412ab0963d8e01227df051439d4c3">constants</a></td></tr>
<tr class="separator:a28a412ab0963d8e01227df051439d4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc579b5b4007c34b9cc6298ca55f4b60"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#acc579b5b4007c34b9cc6298ca55f4b60">var_names</a></td></tr>
<tr class="separator:acc579b5b4007c34b9cc6298ca55f4b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0b4911c4724b6a6d663d8316b3ee3b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a1f0b4911c4724b6a6d663d8316b3ee3b">expressions</a></td></tr>
<tr class="separator:a1f0b4911c4724b6a6d663d8316b3ee3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf646e5ac85fd46840bcc0ed65f648c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#aaf646e5ac85fd46840bcc0ed65f648c5">initialized</a></td></tr>
<tr class="separator:aaf646e5ac85fd46840bcc0ed65f648c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645b346a60cb1826c29a904adcac6a46"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionParser.html#a645b346a60cb1826c29a904adcac6a46">n_vars</a></td></tr>
<tr class="separator:a645b346a60cb1826c29a904adcac6a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br />
class FunctionParser&lt; dim &gt;</h3>

<p>This class implements a function object that gets its value by parsing a string describing this function. It is a wrapper class for the muparser library (see <a href="https://beltoforion.de/en/muparser/">https://beltoforion.de/en/muparser/</a>). This class lets you evaluate strings such as "sqrt(1-x^2+y^2)" for given values of 'x' and 'y'. Please refer to the muparser documentation for more information. This class is used in the step-33 and step-36 tutorial programs (the latter being much simpler to understand).</p>
<p>In addition to the built-in functions of muparser, namely </p><div class="fragment"><div class="line"><a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>, <a class="code" href="numbers_8h.html#a02761f62f66f685e954daed42bcb3a1b">cos</a>, <a class="code" href="numbers_8h.html#a744c1a2f59eee344cde5a970be8e6c99">tan</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#a17229421811a17b2eb6145fe0f933ec2">asin</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#aafbf69ffef5e5d013fc0be51d1cd88a6">acos</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#a803fcea270d7a523a91e3b7c173059f9">atan</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#a766e4d9bbfe24e99245081947db6a0c7">sinh</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#a26c1f7a69dc8ac2e16144493d3b3b896">cosh</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">tanh</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#a1fb4eb9452e084d3c9128ea5fc25720b">asinh</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#ab51a65b3c0995d2eb36c7c2e818c2349">acosh</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#a0d6d5136ba07cf1ca9eca4cbff740e15">atanh</a>,</div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD.html#a130b20f2ea3522f1d123c75c63c0f67d">atan2</a>, log2, <a class="code" href="namespaceDifferentiation_1_1SD.html#af3073c01113bca5a5e9a1b921643ced4">log10</a>, <a class="code" href="numbers_8h.html#a5ecbfe991bebf7e99864f2e4eb3ea8df">log</a>, ln, <a class="code" href="numbers_8h.html#a372e01cd9d1d07fdf136f4f40975d5cf">exp</a>, <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>, <a class="code" href="namespaceDifferentiation_1_1SD.html#aa55d50a1ffa79c27f9bd9ea104f15158">sign</a>, rint, <a class="code" href="numbers_8h.html#a0ebae11c64606a73e80a6328b1ab0802">abs</a>, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">min</a>, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">max</a>, <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a>, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">avg</a></div></div><!-- fragment --><p> this class also supports the following operations:</p><ul>
<li><code>if(condition, then-value, else-value)</code></li>
<li><code>|</code> and <code>&amp;</code> (logic or and and)</li>
<li><code>int(x)</code>, <code>ceil(x)</code>, <code>floor(x)</code> (rounding)</li>
<li><code>cot(x)</code>, <code>csc(x)</code>, <code>sec(x)</code></li>
<li><code>pow(x,n)</code>, <code>log(x)</code></li>
<li><code>erfc(x)</code></li>
<li><code>rand()</code>, <code>rand_seed(seed)</code></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This class implements the list of functions just mentioned as user-defined functions by extending muparser. This means, in particular, that the <code>if(condition, then-value, else-value)</code> syntax evaluates all three arguments before determining whether the condition is true, and then discarding either the "then" or the "else" expressions. In almost all situations, this is not a problem except if the evaluation of one of the expressions throws a floating point exception in cases where it will later be discarded. (Assuming floating point exceptions are switched on, as is the default for deal.II in debug mode on most systems.) An example would be the expression <code>if(x&gt;0, sqrt(x), 0)</code> which is mathematically well defined, but on systems where this is enabled will abort the program with a floating point exception when evaluated with a negative <code>x</code>. This is because the square root of <code>x</code> is computed before the <code>if</code> statement's condition is considered to determine whether the result should be the second or third argument. If this kind of behavior is a problem, you can resort to the muparser built-in syntax <code>(condition ? then-value : else-value)</code>, using the ternary syntax familiar to C++ programmers. If this syntax is used, muparser uses lazy evaluation in which only one of the branches is evaluated, depending on whether the <code>condition</code> is true or false.</dd></dl>
<p>The following examples shows how to use this class: </p><div class="fragment"><div class="line"><span class="comment">// set up problem:</span></div><div class="line"><a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> variables = <span class="stringliteral">&quot;x,y&quot;</span>;</div><div class="line"><a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> expression = <span class="stringliteral">&quot;cos(x) + sqrt(y)&quot;</span>;</div><div class="line">std::map&lt;std::string, double&gt; <a class="code" href="classFunctionParser.html#a28a412ab0963d8e01227df051439d4c3">constants</a>;</div><div class="line"></div><div class="line"><span class="comment">// FunctionParser with 2 variables and 1 component:</span></div><div class="line"><a class="code" href="classFunctionParser.html">FunctionParser&lt;2&gt;</a> <a class="code" href="classFunctionParser.html#a8c9db54883b5a13707f5224aaa3b79c4">fp</a>(1);</div><div class="line"><a class="code" href="classFunctionParser.html#a8c9db54883b5a13707f5224aaa3b79c4">fp</a>.initialize(variables,</div><div class="line">              expression,</div><div class="line">              constants);</div><div class="line"></div><div class="line"><span class="comment">// Point at which we want to evaluate the function</span></div><div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a>(0.0, 4.0);</div><div class="line"></div><div class="line"><span class="comment">// evaluate the expression at &#39;point&#39;:</span></div><div class="line"><span class="keywordtype">double</span> result = <a class="code" href="classFunctionParser.html#a8c9db54883b5a13707f5224aaa3b79c4">fp</a>.value(<a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a>);</div><div class="line"></div><div class="line"><a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Function &#39;&quot;</span> &lt;&lt; expression &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span></div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; @ &quot;</span> &lt;&lt; <a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a></div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; is &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div></div><!-- fragment --><p> The second example is a bit more complex: </p><div class="fragment"><div class="line"><span class="comment">// Define some constants that will be used by the function parser</span></div><div class="line">std::map&lt;std::string, double&gt; <a class="code" href="classFunctionParser.html#a28a412ab0963d8e01227df051439d4c3">constants</a>;</div><div class="line">constants[<span class="stringliteral">&quot;pi&quot;</span>] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line"></div><div class="line"><span class="comment">// Define the variables that will be used inside the expressions</span></div><div class="line"><a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> variables = <span class="stringliteral">&quot;x,y,z&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">// Define the expressions of the individual components of a</span></div><div class="line"><span class="comment">// vector valued function with two components:</span></div><div class="line">std::vector&lt;std::string&gt; <a class="code" href="classFunctionParser.html#a1f0b4911c4724b6a6d663d8316b3ee3b">expressions</a>(2);</div><div class="line"><a class="code" href="classFunctionParser.html#a1f0b4911c4724b6a6d663d8316b3ee3b">expressions</a>[0] = <span class="stringliteral">&quot;sin(2*pi*x)+sinh(pi*z)&quot;</span>;</div><div class="line"><a class="code" href="classFunctionParser.html#a1f0b4911c4724b6a6d663d8316b3ee3b">expressions</a>[1] = <span class="stringliteral">&quot;sin(2*pi*y)*exp(x^2)&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">// function parser with 3 variables and 2 components</span></div><div class="line"><a class="code" href="classFunctionParser.html">FunctionParser&lt;3&gt;</a> vector_function(2);</div><div class="line"></div><div class="line"><span class="comment">// And populate it with the newly created objects.</span></div><div class="line">vector_function.initialize(variables,</div><div class="line">                           <a class="code" href="classFunctionParser.html#a1f0b4911c4724b6a6d663d8316b3ee3b">expressions</a>,</div><div class="line">                           constants);</div><div class="line"></div><div class="line"><span class="comment">// Point at which we want to evaluate the function</span></div><div class="line"><a class="code" href="classPoint.html">Point&lt;3&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a>(0.0, 1.0, 1.0);</div><div class="line"></div><div class="line"><span class="comment">// This Vector will store the result</span></div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> result(2);</div><div class="line"></div><div class="line"><span class="comment">// Fill &#39;result&#39; by evaluating the function</span></div><div class="line">vector_function.vector_value(<a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a>, result);</div><div class="line"></div><div class="line"><span class="comment">// We can also only evaluate the 2nd component:</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> c = vector_function.value(<a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a>, 1);</div><div class="line"></div><div class="line"><span class="comment">// Output the evaluated function</span></div><div class="line"><a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Function &#39;&quot;</span> &lt;&lt; <a class="code" href="classFunctionParser.html#a1f0b4911c4724b6a6d663d8316b3ee3b">expressions</a>[0] &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; <a class="code" href="classFunctionParser.html#a1f0b4911c4724b6a6d663d8316b3ee3b">expressions</a>[1] &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span></div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; <a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a></div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; is &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div></div><!-- fragment --><p>This class overloads the virtual methods <a class="el" href="classFunctionParser.html#a382e05189908a8d462525824a74433e9">value()</a> and <a class="el" href="classFunctionParser.html#ac56c50f2d585a27c3a26f2c0d3082263">vector_value()</a> of the <a class="el" href="classFunction.html">Function</a> base class with the byte compiled versions of the expressions given to the <a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize()</a> methods. Note that the class will not work unless you first call the <a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize()</a> method that accepts the text description of the function as an argument (among other things).</p>
<p>The syntax to describe a function follows usual programming practice, and is explained in detail at the homepage of the underlying muparser library at <a href="https://beltoforion.de/en/muparser/">https://beltoforion.de/en/muparser/</a>.</p>
<p>For a wrapper of the <a class="el" href="classFunctionParser.html">FunctionParser</a> class that supports <a class="el" href="classParameterHandler.html">ParameterHandler</a>, see <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a>.</p>
<p>Vector-valued functions can either be declared using strings where the function components are separated by semicolons, or using a vector of strings each defining one vector component.</p>
<p>An example of time dependent scalar function is the following: </p><div class="fragment"><div class="line">   <span class="comment">// Empty constants object</span></div><div class="line">   std::map&lt;std::string,double&gt; <a class="code" href="classFunctionParser.html#a28a412ab0963d8e01227df051439d4c3">constants</a>;</div><div class="line"></div><div class="line">   <span class="comment">// Variables that will be used inside the expressions</span></div><div class="line">   <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> variables = <span class="stringliteral">&quot;x,y,t&quot;</span>;</div><div class="line"></div><div class="line">   <span class="comment">// Define the expression of the scalar time dependent function.</span></div><div class="line">   <a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> expression = <span class="stringliteral">&quot;exp(y*x)*exp(-t)&quot;</span>;</div><div class="line"></div><div class="line">   <span class="comment">// Generate an empty scalar function</span></div><div class="line">   <a class="code" href="classFunctionParser.html">FunctionParser&lt;2&gt;</a> <span class="keyword">function</span>;</div><div class="line"></div><div class="line">   <span class="comment">// And populate it with the newly created objects.</span></div><div class="line">   <span class="keyword">function</span>.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(variables,</div><div class="line">                       expression,</div><div class="line">                       constants,</div><div class="line"><span class="comment">// Treat the last variable (&quot;t&quot;) as time.</span></div><div class="line">                       <span class="keyword">true</span>);</div></div><!-- fragment --><p>The following is another example of how to instantiate a vector valued function by using a single string: </p><div class="fragment"><div class="line"><span class="comment">// Empty constants object</span></div><div class="line">std::map&lt;std::string,double&gt; <a class="code" href="classFunctionParser.html#a28a412ab0963d8e01227df051439d4c3">constants</a>;</div><div class="line"></div><div class="line"><span class="comment">// Variables that will be used inside the expressions</span></div><div class="line"><a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> variables = <span class="stringliteral">&quot;x,y&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">// Define the expression of the vector valued  function.</span></div><div class="line"><a class="code" href="namespacemystl.html#a00d13e8a0f7f569f855fca0e8b9e2e9a">std::string</a> expression = <span class="stringliteral">&quot;cos(2*pi*x)*y^2; sin(2*pi*x)*exp(y)&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">// Generate an empty vector valued function</span></div><div class="line"><a class="code" href="classFunctionParser.html">FunctionParser&lt;2&gt;</a> <span class="keyword">function</span>(2);</div><div class="line"></div><div class="line"><span class="comment">// And populate it with the newly created objects.</span></div><div class="line"><span class="keyword">function</span>.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(variables,</div><div class="line">                    expression,</div><div class="line">                    constants);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The difference between this class and the SymbolicFunction class is that the SymbolicFunction class allows to compute first and second order derivatives (in a symbolic way), while this class computes first order derivatives only, using finite differences. For complicated expressions, this class is generally faster than SymbolicFunction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00223">223</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2426bdaf98de531415477667097235b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2426bdaf98de531415477667097235b8">&#9670;&nbsp;</a></span>ConstMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::<a class="el" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">ConstMap</a> =  std::map&lt;std::string, <a class="el" href="classdouble.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the constant map. Used by the <a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize()</a> method. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00284">284</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a id="a385ed76410d75f5f15304ccebaac220d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385ed76410d75f5f15304ccebaac220d">&#9670;&nbsp;</a></span>time_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="classdouble.html">double</a> &gt;::real_type&gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar-valued real type used for representing time. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00170">170</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8e3a3152c1a97076b961dcb35a3bb36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3a3152c1a97076b961dcb35a3bb36b">&#9670;&nbsp;</a></span>DifferenceFormula</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">AutoDerivativeFunction::DifferenceFormula</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Names of difference formulas. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8e3a3152c1a97076b961dcb35a3bb36babf0b91e6181d44127eb8d23ff080f286"></a>Euler&#160;</td><td class="fielddoc"><p>The symmetric Euler formula of second order: </p><p class="formulaDsp">
\[ u&#39;(t) \approx \frac{u(t+h) - u(t-h)}{2h}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a8e3a3152c1a97076b961dcb35a3bb36bab261116ff92510dff59a179b43fdb444"></a>UpwindEuler&#160;</td><td class="fielddoc"><p>The upwind Euler formula of first order: </p><p class="formulaDsp">
\[ u&#39;(t) \approx \frac{u(t) - u(t-h)}{h}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a8e3a3152c1a97076b961dcb35a3bb36ba1d80de60e448c04501ec359c16b6c08d"></a>FourthOrder&#160;</td><td class="fielddoc"><p>The fourth order scheme </p><p class="formulaDsp">
\[ u&#39;(t) \approx \frac{u(t-2h) - 8u(t-h) + 8u(t+h) - u(t+2h)}{12h}. \]
</p>
 </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="auto__derivative__function_8h_source.html#l00088">88</a> of file <a class="el" href="auto__derivative__function_8h_source.html">auto_derivative_function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0d7c78097d8aa1799a81d74f429aaa34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7c78097d8aa1799a81d74f429aaa34">&#9670;&nbsp;</a></span>FunctionParser() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::<a class="el" href="classFunctionParser.html">FunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_components</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>initial_time</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Its arguments are the same of the base class <a class="el" href="classFunction.html">Function</a>, with the additional parameter <code>h</code>, used for the computation of gradients using finite differences. This object needs to be initialized with the <a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize()</a> method before you can use it. If an attempt to use this function is made before the <a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize()</a> method has been called, then an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8cc_source.html#l00045">45</a> of file <a class="el" href="function__parser_8cc_source.html">function_parser.cc</a>.</p>

</div>
</div>
<a id="a5a025a34dddf97b70fa604da253561e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a025a34dddf97b70fa604da253561e4">&#9670;&nbsp;</a></span>FunctionParser() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::<a class="el" href="classFunctionParser.html">FunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>constants</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable_names</em> = <code><a class="el" href="classFunctionParser.html#ad2a69afb91de468f3bb2de6245258dd6">default_variable_names</a>()&#160;+&#160;&quot;,t&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>h</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for parsed functions. Takes directly a semi-colon separated list of expressions (one for each component of the function), an optional comma-separated list of constants, variable names and step size for the computation of first order derivatives by finite differences. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8cc_source.html#l00055">55</a> of file <a class="el" href="function__parser_8cc_source.html">function_parser.cc</a>.</p>

</div>
</div>
<a id="a981060f088b43cdf6f9fac1b840d0346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981060f088b43cdf6f9fac1b840d0346">&#9670;&nbsp;</a></span>FunctionParser() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::<a class="el" href="classFunctionParser.html">FunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Objects of this type can not be copied, and consequently this constructor is deleted. </p>

</div>
</div>
<a id="a4312d538a4c339c1d0aa92bd0e6c17cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4312d538a4c339c1d0aa92bd0e6c17cb">&#9670;&nbsp;</a></span>FunctionParser() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::<a class="el" href="classFunctionParser.html">FunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Objects of this type can not be moved, and consequently this constructor is deleted. </p>

</div>
</div>
<a id="aa99c3fa994097013c991d74002d3609a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99c3fa994097013c991d74002d3609a">&#9670;&nbsp;</a></span>~FunctionParser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::~<a class="el" href="classFunctionParser.html">FunctionParser</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a16f24fe8e0939be26ee10a25e9abfc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f24fe8e0939be26ee10a25e9abfc50">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionParser.html">FunctionParser</a>&amp; <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. Objects of this type can not be copied, and consequently this operator is deleted. </p>

</div>
</div>
<a id="aa32a0384dd8a6250399405b2370e22e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32a0384dd8a6250399405b2370e22e9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFunctionParser.html">FunctionParser</a>&amp; <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move operator. Objects of this type can not be moved, and consequently this operator is deleted. </p>

</div>
</div>
<a id="aac973d1e4fc6912ccf833c108894e414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac973d1e4fc6912ccf833c108894e414">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the object by setting the actual parsed functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td>a string with the variables that will be used by the expressions to be evaluated. Note that the variables can have any name (of course different from the function names defined above!), but the order IS important. The first variable will correspond to the first component of the point in which the function is evaluated, the second variable to the second component and so forth. If this function is also time dependent, then it is necessary to specify it by setting the <code>time_dependent</code> parameter to true. An exception is thrown if the number of variables specified here is different from dim (if this function is not time-dependent) or from dim+1 (if it is time-dependent).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expressions</td><td>a list of strings containing the expressions that will be byte compiled by the internal parser (muParser). Note that the size of this vector must match exactly the number of components of the <a class="el" href="classFunctionParser.html">FunctionParser</a>, as declared in the constructor. If this is not the case, an exception is thrown.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>a map of constants used to pass any necessary constant that we want to specify in our expressions (in the example above the number pi). An expression is valid if and only if it contains only defined variables and defined constants (other than the functions specified above). If a constant is given whose name is not valid (eg: <code>constants["sin"] = 1.5;</code>) an exception is thrown.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_dependent</td><td>If this is a time dependent function, then the last variable declared in <code>vars</code> is assumed to be the time variable, and <a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">FunctionTime::get_time()</a> is used to initialize it when evaluating the function. Naturally the number of variables parsed by <a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize()</a> in this case is dim+1. The value of this parameter defaults to false, i.e., do not consider time. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="function__parser_8cc_source.html#l00094">94</a> of file <a class="el" href="function__parser_8cc_source.html">function_parser.cc</a>.</p>

</div>
</div>
<a id="ad2331d2600f14502108e9770932e6dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2331d2600f14502108e9770932e6dbb">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the function. Same as above, but accepts a string rather than a vector of strings. If this is a vector valued function, its components are expected to be separated by a semicolon. An exception is thrown if this method is called and the number of components successfully parsed does not match the number of components of the base function. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8cc_source.html#l00261">261</a> of file <a class="el" href="function__parser_8cc_source.html">function_parser.cc</a>.</p>

</div>
</div>
<a id="ad2a69afb91de468f3bb2de6245258dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a69afb91de468f3bb2de6245258dd6">&#9670;&nbsp;</a></span>default_variable_names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::default_variable_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that returns default names for variables, to be used in the first argument of the <a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize()</a> functions: it returns "x" in 1d, "x,y" in 2d, and "x,y,z" in 3d. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00454">454</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a id="a382e05189908a8d462525824a74433e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382e05189908a8d462525824a74433e9">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the function at the given point. Unless there is only one component (i.e., the function is scalar), you should state the component you want to have evaluated; it defaults to zero, i.e., the first component. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">Function&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="function__parser_8cc_source.html#l00276">276</a> of file <a class="el" href="function__parser_8cc_source.html">function_parser.cc</a>.</p>

</div>
</div>
<a id="ac56c50f2d585a27c3a26f2c0d3082263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac56c50f2d585a27c3a26f2c0d3082263">&#9670;&nbsp;</a></span>vector_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::vector_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all components of a vector-valued function at the given point <code>p</code>.</p>
<p><code>values</code> shall have the right size beforehand, i.e. <a class="el" href="classFunction.html#a7248c7e11dc434fb7d16cdc5e41e3770">n_components</a>. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">Function&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="function__parser_8cc_source.html#l00311">311</a> of file <a class="el" href="function__parser_8cc_source.html">function_parser.cc</a>.</p>

</div>
</div>
<a id="a9304a37a6c71122f0cf3e51e0db353f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9304a37a6c71122f0cf3e51e0db353f5">&#9670;&nbsp;</a></span>get_expressions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::get_expressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an array of function expressions (one per component), used to initialize this function. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8cc_source.html#l00037">37</a> of file <a class="el" href="function__parser_8cc_source.html">function_parser.cc</a>.</p>

</div>
</div>
<a id="a0a2705462fa483eeda48ff4350bd5a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2705462fa483eeda48ff4350bd5a2c">&#9670;&nbsp;</a></span>init_muparser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::init_muparser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize fp and vars on the current thread. This function may only be called once per thread. A thread can test whether the function has already been called by testing whether 'fp.get().size()==0' (not initialized) or &gt;0 (already initialized). </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8cc_source.html#l00137">137</a> of file <a class="el" href="function__parser_8cc_source.html">function_parser.cc</a>.</p>

</div>
</div>
<a id="ada47ab970ec0732a04b933dec44b3b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada47ab970ec0732a04b933dec44b3b1c">&#9670;&nbsp;</a></span>set_formula()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAutoDerivativeFunction.html">AutoDerivativeFunction</a>&lt; dim &gt;::set_formula </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a>&#160;</td>
          <td class="paramname"><em>formula</em> = <code><a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36babf0b91e6181d44127eb8d23ff080f286">Euler</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Choose the difference formula. See the enum <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a> for available choices. </p>

<p class="definition">Definition at line <a class="el" href="auto__derivative__function_8cc_source.html#l00043">43</a> of file <a class="el" href="auto__derivative__function_8cc_source.html">auto_derivative_function.cc</a>.</p>

</div>
</div>
<a id="a8dcfb02bfd5543481d50cb0a98d01c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcfb02bfd5543481d50cb0a98d01c14">&#9670;&nbsp;</a></span>set_h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAutoDerivativeFunction.html">AutoDerivativeFunction</a>&lt; dim &gt;::set_h </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes the difference step size <code>h</code>. It's within the user's responsibility to choose an appropriate value here. <code>h</code> should be chosen taking into account the absolute value of as well as the amount of local variation of the function. Setting <code>h=1e-6</code> might be a good choice for functions with an absolute value of about 1, that furthermore does not vary to much. </p>

<p class="definition">Definition at line <a class="el" href="auto__derivative__function_8cc_source.html#l00065">65</a> of file <a class="el" href="auto__derivative__function_8cc_source.html">auto_derivative_function.cc</a>.</p>

</div>
</div>
<a id="a699fef370c63619a08aa94433f34136b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699fef370c63619a08aa94433f34136b">&#9670;&nbsp;</a></span>gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; <a class="el" href="classAutoDerivativeFunction.html">AutoDerivativeFunction</a>&lt; dim &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the specified component of the function at the given point.</p>
<p>Compute numerical difference quotients using the preset <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a>. </p>

<p>Reimplemented from <a class="el" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">Function&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="auto__derivative__function_8cc_source.html#l00075">75</a> of file <a class="el" href="auto__derivative__function_8cc_source.html">auto_derivative_function.cc</a>.</p>

</div>
</div>
<a id="a030c5e1de5262221de1e545298470f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030c5e1de5262221de1e545298470f19">&#9670;&nbsp;</a></span>vector_gradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAutoDerivativeFunction.html">AutoDerivativeFunction</a>&lt; dim &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at the given point.</p>
<p>Compute numerical difference quotients using the preset <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a>. </p>

<p class="definition">Definition at line <a class="el" href="auto__derivative__function_8cc_source.html#l00127">127</a> of file <a class="el" href="auto__derivative__function_8cc_source.html">auto_derivative_function.cc</a>.</p>

</div>
</div>
<a id="af4509a9d71dc1a1ca05cb6205161dc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4509a9d71dc1a1ca05cb6205161dc60">&#9670;&nbsp;</a></span>vector_gradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::vector_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classdouble.html">double</a>  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of all components of the function at the given point. </p>

</div>
</div>
<a id="a8535ed93698d68154fb3544272dad2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8535ed93698d68154fb3544272dad2dd">&#9670;&nbsp;</a></span>gradient_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAutoDerivativeFunction.html">AutoDerivativeFunction</a>&lt; dim &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the specified component of the function at the <code>points</code>. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array.</p>
<p>Compute numerical difference quotients using the preset <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a>. </p>

<p class="definition">Definition at line <a class="el" href="auto__derivative__function_8cc_source.html#l00204">204</a> of file <a class="el" href="auto__derivative__function_8cc_source.html">auto_derivative_function.cc</a>.</p>

</div>
</div>
<a id="afcf557f137782b46e85461235d5bd47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf557f137782b46e85461235d5bd47d">&#9670;&nbsp;</a></span>gradient_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classdouble.html">double</a>  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the specified component of the function at the <code>points</code>. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array. </p>

</div>
</div>
<a id="ad3872f43eb38248e3d87edeca0dfc2c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3872f43eb38248e3d87edeca0dfc2c4">&#9670;&nbsp;</a></span>vector_gradient_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAutoDerivativeFunction.html">AutoDerivativeFunction</a>&lt; dim &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the function at the <code>points</code>, for all components. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array.</p>
<p>The outer loop over <code>gradients</code> is over the points in the list, the inner loop over the different components of the function.</p>
<p>Compute numerical difference quotients using the preset <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a>. </p>

<p class="definition">Definition at line <a class="el" href="auto__derivative__function_8cc_source.html#l00268">268</a> of file <a class="el" href="auto__derivative__function_8cc_source.html">auto_derivative_function.cc</a>.</p>

</div>
</div>
<a id="a109f7bff0fb455c042086f98bd003ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109f7bff0fb455c042086f98bd003ede">&#9670;&nbsp;</a></span>vector_gradient_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::vector_gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classdouble.html">double</a>  &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the function at the <code>points</code>, for all components. It is assumed that <code>gradients</code> already has the right size, i.e. the same size as the <code>points</code> array.</p>
<p>The outer loop over <code>gradients</code> is over the points in the list, the inner loop over the different components of the function. </p>

</div>
</div>
<a id="af58d24b47b673bba1d0dfc534f994304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58d24b47b673bba1d0dfc534f994304">&#9670;&nbsp;</a></span>get_formula_of_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAutoDerivativeFunction.html">AutoDerivativeFunction</a>&lt; dim &gt;::<a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a> <a class="el" href="classAutoDerivativeFunction.html">AutoDerivativeFunction</a>&lt; dim &gt;::get_formula_of_order </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>ord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classAutoDerivativeFunction.html#a8e3a3152c1a97076b961dcb35a3bb36b">DifferenceFormula</a> of the order <code>ord</code> at minimum. </p>

<p class="definition">Definition at line <a class="el" href="auto__derivative__function_8cc_source.html#l00336">336</a> of file <a class="el" href="auto__derivative__function_8cc_source.html">auto_derivative_function.cc</a>.</p>

</div>
</div>
<a id="a562fc1114e95e702e6696721f71528db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562fc1114e95e702e6696721f71528db">&#9670;&nbsp;</a></span>value_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the specified component of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array.</p>
<p>By default, this function repeatedly calls <a class="el" href="classFunctionParser.html#a382e05189908a8d462525824a74433e9">value()</a> for each point separately, to fill the output array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1Polynomial.html#a5b5151e5d4af43db47f22508e3e9e2da">Functions::Polynomial&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionCinfty.html#a1f732d99ec3104f62c9f6558fc95e2ef">Functions::CutOffFunctionCinfty&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionC1.html#a651a2e1ac8f701f11f5aff73c3e4d1b7">Functions::CutOffFunctionC1&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionW1.html#ac6c1b619bc0cbdef7827a1463232b366">Functions::CutOffFunctionW1&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionLinfty.html#a35079df32399892031b574316eed93a3">Functions::CutOffFunctionLinfty&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1JumpFunction.html#a54d253b6d583aa25aee52732f829a350">Functions::JumpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1SlitSingularityFunction.html#a3f0ece56f98717e112cb3c4b0c96aa2d">Functions::SlitSingularityFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ExpFunction.html#a66005ee23a0660a5e54aca0bd694a53b">Functions::ExpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineGradFunction.html#a7d60c31d44bd65265c16edff1d17f1b8">Functions::CosineGradFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineFunction.html#ab65c3110ef06c891d440763dc214ae24">Functions::CosineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1PillowFunction.html#a39f76bfa5a4ed3148506b78915fb5f9c">Functions::PillowFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1Q1WedgeFunction.html#a94605a72f91c3c4725b759bb605ee90e">Functions::Q1WedgeFunction&lt; dim &gt;</a>, <a class="el" href="classFunctionDerivative.html#a07ff98bb6ebea318330b0cb9dc1b2e27">FunctionDerivative&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1SquareFunction.html#a0c70138bad558fc220c39ae9d37adca5">Functions::SquareFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1Bessel1.html#af0a254ac1d1ef48463b7a84b618555b4">Functions::Bessel1&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="aa041dde994d40c068e00661197ac75a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa041dde994d40c068e00661197ac75a6">&#9670;&nbsp;</a></span>vector_value_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::vector_value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a>  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array, and that all elements be vectors with the same number of components as this function has.</p>
<p>By default, this function repeatedly calls <a class="el" href="classFunctionParser.html#ac56c50f2d585a27c3a26f2c0d3082263">vector_value()</a> for each point separately, to fill the output array. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1CutOffFunctionCinfty.html#a1dda79292756d0c7f09a6e83b0863110">Functions::CutOffFunctionCinfty&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionC1.html#a61af4a99b469378a46a997a0595161cd">Functions::CutOffFunctionC1&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionW1.html#a16ed2d98f36f587761295b2b47818027">Functions::CutOffFunctionW1&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CutOffFunctionLinfty.html#a318b0becb0f5cecd192d7aa4308b8518">Functions::CutOffFunctionLinfty&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1SlitSingularityFunction.html#a5655ffe8f2572ac26e3ad0be3c22f357">Functions::SlitSingularityFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineGradFunction.html#aa49e52415a6782ddc4477cf1b8695e2d">Functions::CosineGradFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineFunction.html#a354cd862599cd88a4e620b58525b7df6">Functions::CosineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#a84bc050634158b33755dc7b81251d7db">Functions::FlowFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#a84bc050634158b33755dc7b81251d7db">Functions::FlowFunction&lt; 2 &gt;</a>, and <a class="el" href="classFunctions_1_1Q1WedgeFunction.html#ad320f5d29637d534e9ba18846e9f94c3">Functions::Q1WedgeFunction&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="ad1b4f548be005a1ffeeca7a450b028d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b4f548be005a1ffeeca7a450b028d8">&#9670;&nbsp;</a></span>vector_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::vector_values </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a>  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of values, one for each point.</p>
<p>The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1StokesCosine.html#a539d0baad1334331d7f183792ba34ea6">Functions::StokesCosine&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1PoisseuilleFlow.html#a3eeb878c2e1a245939d18ed9ddb660ed">Functions::PoisseuilleFlow&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#a6ba8c353d5f32375ca5e1a66d0ce891f">Functions::FlowFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1FlowFunction.html#a6ba8c353d5f32375ca5e1a66d0ce891f">Functions::FlowFunction&lt; 2 &gt;</a>.</p>

</div>
</div>
<a id="a4ddbeb5adda74140a00dfc8db3687b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddbeb5adda74140a00dfc8db3687b4a">&#9670;&nbsp;</a></span>vector_gradients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::vector_gradients </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classdouble.html">double</a>  &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each component of the function, fill a vector of gradient values, one for each point.</p>
<p>The default implementation of this function in <a class="el" href="classFunction.html">Function</a> calls <a class="el" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list()</a> for each component. In order to improve performance, this can be reimplemented in derived classes to speed up performance. </p>

</div>
</div>
<a id="a763c928e78dc33bbe50873128f06e153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763c928e78dc33bbe50873128f06e153">&#9670;&nbsp;</a></span>laplacian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdouble.html">double</a>  <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of a given component at point <code>p</code>. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1FourierCosineSum.html#a2a1c7fcd649b3ee19246cacc959240c9">Functions::FourierCosineSum&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FourierSineSum.html#ac7c526282ab402c2ee2544c60ca23fe7">Functions::FourierSineSum&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FourierSineFunction.html#a5d16e976f45b81191acf5a7b3c9e8815">Functions::FourierSineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FourierCosineFunction.html#ae8edfa1e08bf54d0100f94e9002dfd9a">Functions::FourierCosineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1JumpFunction.html#a86cbfd2456dd09a73f9d1bdd42f4bbef">Functions::JumpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1SlitSingularityFunction.html#a5ce6644654989e420eaafa30441e5a23">Functions::SlitSingularityFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ExpFunction.html#ab45b5c96be5d8ef78ed207b7ee2541bb">Functions::ExpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineGradFunction.html#ac19c861870a6ffeaef0a674550557ad3">Functions::CosineGradFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineFunction.html#a16edf5258ef925d2a2fa4ee2843ee929">Functions::CosineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1PillowFunction.html#a2fa3b2ace3f2a3822d063593c6c044a1">Functions::PillowFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1Q1WedgeFunction.html#a7d0c19357b5fce55a4bb90d92f55a82f">Functions::Q1WedgeFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CSpline.html#a41b9b9ee8fbf353ff61d4c96eba5e703">Functions::CSpline&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1SquareFunction.html#a37e2886605febf10ff1b223d8f1ec0be">Functions::SquareFunction&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a33430fb1069660fb8cfe599181aceefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33430fb1069660fb8cfe599181aceefa">&#9670;&nbsp;</a></span>vector_laplacian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::vector_laplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="aae80353c3a581fa918ea555c3e1c7353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae80353c3a581fa918ea555c3e1c7353">&#9670;&nbsp;</a></span>laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdouble.html">double</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacian of one component at a set of points. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1JumpFunction.html#a0122a909ecec19d7e375bb97297bac82">Functions::JumpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1SlitSingularityFunction.html#ab6216f47632cbb11721c47ddc8d12a7a">Functions::SlitSingularityFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1ExpFunction.html#a49b01b26ec37ef5adba5a6da5e32f37a">Functions::ExpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CosineFunction.html#aa6bcb9008b39f85a74d18729bf754975">Functions::CosineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1PillowFunction.html#ac3dd2dc5d1d56b69bb190ab10ffd9e9e">Functions::PillowFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1Q1WedgeFunction.html#a894f7b0d6de28ab70893a765d6b86a60">Functions::Q1WedgeFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1SquareFunction.html#a41d177957cf47eabfdda94beeff800d9">Functions::SquareFunction&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a6582ff5ce8fddc37866077976df598f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6582ff5ce8fddc37866077976df598f9">&#9670;&nbsp;</a></span>vector_laplacian_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::vector_laplacian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a>  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Laplacians of all components at a set of points. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1FlowFunction.html#aea79a40ce18f8968aa52da9bdb2064c9">Functions::FlowFunction&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1FlowFunction.html#aea79a40ce18f8968aa52da9bdb2064c9">Functions::FlowFunction&lt; 2 &gt;</a>.</p>

</div>
</div>
<a id="a8aa2ec8f2270bdee842413805c4d7442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa2ec8f2270bdee842413805c4d7442">&#9670;&nbsp;</a></span>hessian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim, <a class="el" href="classdouble.html">double</a> &gt; <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of a given component at point <code>p</code>, that is the gradient of the gradient of the function. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1CosineFunction.html#af17f8b49ba7bf00bbc0803db89684194">Functions::CosineFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1LevelSet_1_1Plane.html#a6e15a26375f2ac4b4ad05781c1d3ca85">Functions::LevelSet::Plane&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1CSpline.html#a006fd7fde5ff629e1b6f5b6c6b3cee06">Functions::CSpline&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1Spherical.html#a1ac78d3127e9082877938962a86c6a32">Functions::Spherical&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1LevelSet_1_1Sphere.html#a096f75aea491f26f139b41b5f1803489">Functions::LevelSet::Sphere&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1CoordinateRestriction.html#ac43e2d4f41e2e24fc87d1bcd60a2dd28">Functions::CoordinateRestriction&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a94960fba14557566fa5df8745a721939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94960fba14557566fa5df8745a721939">&#9670;&nbsp;</a></span>vector_hessian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::vector_hessian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, <a class="el" href="classdouble.html">double</a>  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of all components at point <code>p</code> and store them in <code>values</code>. </p>

</div>
</div>
<a id="a2e69625d9daf07615270d65d97dfebde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e69625d9daf07615270d65d97dfebde">&#9670;&nbsp;</a></span>hessian_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::hessian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, <a class="el" href="classdouble.html">double</a>  &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessian of one component at a set of points. </p>

</div>
</div>
<a id="abc1b732264fb498528453312e24d2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b732264fb498528453312e24d2f49">&#9670;&nbsp;</a></span>vector_hessian_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::vector_hessian_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, <a class="el" href="classdouble.html">double</a>  &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Hessians of all components at a set of points. </p>

</div>
</div>
<a id="a45e07b63ee34bd7e7ab2492be5213377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e07b63ee34bd7e7ab2492be5213377">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an estimate for the memory consumption, in bytes, of this object.</p>
<p>This function is virtual and can be overloaded by derived classes. </p>

<p>Reimplemented in <a class="el" href="classFunctions_1_1Polynomial.html#a2e1af7bafbf4f480c5cf6638ef669d8d">Functions::Polynomial&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1InterpolatedUniformGridData.html#aeedef0a7c09f521c5e16bbcbd4951289">Functions::InterpolatedUniformGridData&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1InterpolatedTensorProductGridData.html#a996a3f8871bc5a626b78f9933a25efe9">Functions::InterpolatedTensorProductGridData&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1JumpFunction.html#a6b2746bc10c623cdc8a13c1e6b6652eb">Functions::JumpFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#ad11ae10ddf295c00ceddbf009605745a">Functions::FlowFunction&lt; dim &gt;</a>, <a class="el" href="classFunctions_1_1FlowFunction.html#ad11ae10ddf295c00ceddbf009605745a">Functions::FlowFunction&lt; 2 &gt;</a>, <a class="el" href="classFunctions_1_1CSpline.html#a1b1d3c8a4c22b615efcb4e8cc143d13e">Functions::CSpline&lt; dim &gt;</a>, <a class="el" href="classFunctionDerivative.html#a046459a557118c1bb97f457b52b056bb">FunctionDerivative&lt; dim &gt;</a>, and <a class="el" href="classFunctions_1_1Spherical.html#aa8d6fac9ab77af568c3641c0392c428f">Functions::Spherical&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the time variable. </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time to <code>new_time</code>, overwriting the old value. </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; Number &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the time by the given time step <code>delta_t</code>. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac3bd431f237d7f893e898cedf63bbd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bd431f237d7f893e898cedf63bbd06">&#9670;&nbsp;</a></span>vars</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt;std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; &gt; <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::vars</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Place for the variables for each thread </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00397">397</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a id="a8c9db54883b5a13707f5224aaa3b79c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9db54883b5a13707f5224aaa3b79c4">&#9670;&nbsp;</a></span>fp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt;std::vector&lt;std::unique_ptr&lt;mu::Parser&gt; &gt; &gt; <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::fp</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The muParser objects for each thread (and one for each component). We are storing a unique_ptr so that we don't need to include the definition of mu::Parser in this header. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00405">405</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a id="a28a412ab0963d8e01227df051439d4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a412ab0963d8e01227df051439d4c3">&#9670;&nbsp;</a></span>constants</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::constants</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An array to keep track of all the constants, required to initialize fp in each thread. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00411">411</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a id="acc579b5b4007c34b9cc6298ca55f4b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc579b5b4007c34b9cc6298ca55f4b60">&#9670;&nbsp;</a></span>var_names</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::var_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An array for the variable names, required to initialize fp in each thread. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00417">417</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a id="a1f0b4911c4724b6a6d663d8316b3ee3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0b4911c4724b6a6d663d8316b3ee3b">&#9670;&nbsp;</a></span>expressions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::expressions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An array of function expressions (one per component), required to initialize fp in each thread. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00433">433</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a id="aaf646e5ac85fd46840bcc0ed65f648c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf646e5ac85fd46840bcc0ed65f648c5">&#9670;&nbsp;</a></span>initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>State of usability. This variable is checked every time the function is called for evaluation. It's set to true in the <a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize()</a> methods. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00439">439</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a id="a645b346a60cb1826c29a904adcac6a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645b346a60cb1826c29a904adcac6a46">&#9670;&nbsp;</a></span>n_vars</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunctionParser.html">FunctionParser</a>&lt; dim &gt;::n_vars</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of variables. If this is also a function of time, then the number of variables is dim+1, otherwise it is dim. In the case that this is a time dependent function, the time is supposed to be the last variable. If <a class="el" href="classFunctionParser.html#a645b346a60cb1826c29a904adcac6a46">n_vars</a> is not identical to the number of the variables parsed by the <a class="el" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize()</a> method, then an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="function__parser_8h_source.html#l00448">448</a> of file <a class="el" href="function__parser_8h_source.html">function_parser.h</a>.</p>

</div>
</div>
<a id="ad8063ed9dcbe58753504d9173475befe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8063ed9dcbe58753504d9173475befe">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Export the value of the template parameter as a static member constant. Sometimes useful for some expression template programming. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00159">159</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<a id="a7248c7e11dc434fb7d16cdc5e41e3770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7248c7e11dc434fb7d16cdc5e41e3770">&#9670;&nbsp;</a></span>n_components</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a>  &gt;::n_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vector components. </p>

<p class="definition">Definition at line <a class="el" href="function_8h_source.html#l00164">164</a> of file <a class="el" href="function_8h_source.html">function.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="function__parser_8h_source.html">function_parser.h</a></li>
<li>source/base/<a class="el" href="function__parser_8cc_source.html">function_parser.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
