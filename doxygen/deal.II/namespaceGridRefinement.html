<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceGridRefinement.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GridRefinement Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">GridRefinement Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2cd1fd8890571beb15b4b5bc92650680"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2cd1fd8890571beb15b4b5bc92650680"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a2cd1fd8890571beb15b4b5bc92650680">adjust_refine_and_coarsen_number_fraction</a> (const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> current_n_cells, const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> max_n_cells, const <a class="el" href="classdouble.html">double</a> top_fraction_of_cells, const <a class="el" href="classdouble.html">double</a> bottom_fraction_of_cells)</td></tr>
<tr class="separator:a2cd1fd8890571beb15b4b5bc92650680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e5395381ed87155942a61a1edd134d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:a48e5395381ed87155942a61a1edd134d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">refine_and_coarsen_fixed_number</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const <a class="el" href="classdouble.html">double</a> top_fraction_of_cells, const <a class="el" href="classdouble.html">double</a> bottom_fraction_of_cells, const unsigned <a class="el" href="classint.html">int</a> max_n_cells=std::numeric_limits&lt; unsigned <a class="el" href="classint.html">int</a> &gt;::max())</td></tr>
<tr class="separator:a48e5395381ed87155942a61a1edd134d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90dc87c4db158b8d01f6d564ac614e5"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:ae90dc87c4db158b8d01f6d564ac614e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">refine_and_coarsen_fixed_fraction</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const <a class="el" href="classdouble.html">double</a> top_fraction, const <a class="el" href="classdouble.html">double</a> bottom_fraction, const unsigned <a class="el" href="classint.html">int</a> max_n_cells=std::numeric_limits&lt; unsigned <a class="el" href="classint.html">int</a> &gt;::max(), const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a> norm_type=VectorTools::NormType::L1_norm)</td></tr>
<tr class="separator:ae90dc87c4db158b8d01f6d564ac614e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ecb57c6fa25805a26727843c877932"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:a52ecb57c6fa25805a26727843c877932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a52ecb57c6fa25805a26727843c877932">refine_and_coarsen_optimize</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const unsigned <a class="el" href="classint.html">int</a> order=2)</td></tr>
<tr class="separator:a52ecb57c6fa25805a26727843c877932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf30058b31ce7f9b389e8310bb9fc54"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:a1cf30058b31ce7f9b389e8310bb9fc54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a1cf30058b31ce7f9b389e8310bb9fc54">refine</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const <a class="el" href="classdouble.html">double</a> threshold, const unsigned <a class="el" href="classint.html">int</a> max_to_mark=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a1cf30058b31ce7f9b389e8310bb9fc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eee186cf23024df6854a9990a786703"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:a5eee186cf23024df6854a9990a786703"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a5eee186cf23024df6854a9990a786703">coarsen</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const <a class="el" href="classdouble.html">double</a> threshold)</td></tr>
<tr class="separator:a5eee186cf23024df6854a9990a786703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69747f64b7eca6d10665d13edd9ba712"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#a69747f64b7eca6d10665d13edd9ba712">DeclException0</a> (ExcNegativeCriteria)</td></tr>
<tr class="separator:a69747f64b7eca6d10665d13edd9ba712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72ab05d12dcbb8ecb4288619757f96c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridRefinement.html#ad72ab05d12dcbb8ecb4288619757f96c">DeclException0</a> (ExcInvalidParameterValue)</td></tr>
<tr class="separator:ad72ab05d12dcbb8ecb4288619757f96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides a collection of functions that aid in refinement and coarsening of triangulations. Despite the name of the namespace, the functions do not actually <em>refine</em> the triangulation, but only <em>mark cells for refinement or coarsening</em>. In other words, they perform the "mark" part of the typical "solve-estimate-mark-refine" cycle of the adaptive finite element loop.</p>
<p>The functions in this namespace form two categories. There are the auxiliary functions <a class="el" href="namespaceGridRefinement.html#a1cf30058b31ce7f9b389e8310bb9fc54">refine()</a> and <a class="el" href="namespaceGridRefinement.html#a5eee186cf23024df6854a9990a786703">coarsen()</a>. More important for users are the other functions, which implement refinement strategies, as being found in the literature on adaptive finite element methods. For mathematical discussion of these methods, consider works by D&ouml;rfler, Morin, Nochetto, Rannacher, Stevenson, and others. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2cd1fd8890571beb15b4b5bc92650680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd1fd8890571beb15b4b5bc92650680">&#9670;&nbsp;</a></span>adjust_refine_and_coarsen_number_fraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>&gt; GridRefinement::adjust_refine_and_coarsen_number_fraction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td>
          <td class="paramname"><em>current_n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td>
          <td class="paramname"><em>max_n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>top_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>bottom_fraction_of_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of double values of which the first is adjusted refinement fraction of cells and the second is adjusted coarsening fraction of cells.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">current_n_cells</td><td>The current cell number.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_n_cells</td><td>The maximal number of cells. If current cell number <code>current_n_cells</code> is already exceeded maximal cell number <code>max_n_cells</code>, refinement fraction of cells will be set to zero and coarsening fraction of cells will be adjusted to reduce cell number to @ max_n_cells. If cell number is going to be exceeded only upon refinement, then refinement and coarsening fractions are going to be adjusted with a same ratio in an attempt to reach the maximum number of cells. Be aware though that through proliferation of refinement due to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a>, this number is only an indicator. The default value of this argument is to impose no limit on the number of cells.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_fraction_of_cells</td><td>The requested fraction of active cells to be refined.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom_fraction_of_cells</td><td>The requested fraction of active cells to be coarsened.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Usually you do not need to call this function explicitly. Pass <code>max_n_cells</code> to function <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">refine_and_coarsen_fixed_number()</a> or function <a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">refine_and_coarsen_fixed_fraction()</a> and they will call this function if necessary. </dd></dl>

</div>
</div>
<a id="a48e5395381ed87155942a61a1edd134d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e5395381ed87155942a61a1edd134d">&#9670;&nbsp;</a></span>refine_and_coarsen_fixed_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine_and_coarsen_fixed_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>top_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>bottom_fraction_of_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_n_cells</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides a strategy to mark cells for refinement and coarsening with the goal of providing predictable growth in the size of the mesh by refining a given fraction of all cells.</p>
<p>The function takes a vector of refinement <code>criteria</code> and two values between zero and one denoting the fractions of cells to be refined and coarsened. It flags cells for further processing by <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a> according to the following greedy algorithm:</p>
<ol>
<li>
<p class="startli">Sort the cells according to descending values of <code>criteria</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Mark the <code>top_fraction_of_cells</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> active cells with the largest refinement criteria for refinement.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Mark the <code>bottom_fraction_of_cells</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> active cells with the smallest refinement criteria for coarsening.</p>
<p class="endli"></p>
</li>
</ol>
<p>As an example, with no coarsening, setting <code>top_fraction_of_cells</code> to 1/3 will result in approximately doubling the number of cells in two dimensions. That is because each of these 1/3 of cells will be replaced by its four children, resulting in \(4\times \frac 13 N\) cells, whereas the remaining 2/3 of cells remains untouched &ndash; thus yielding a total of \(4\times \frac 13 N + \frac 23 N = 2N\) cells. The same effect in three dimensions is achieved by refining 1/7th of the cells. These values are therefore frequently used because they ensure that the cost of computations on subsequent meshes become expensive sufficiently quickly that the fraction of time spent on the coarse meshes is not too large. On the other hand, the fractions are small enough that mesh adaptation does not refine too many cells in each step.</p>
<dl class="section note"><dt>Note</dt><dd>This function only sets the coarsening and refinement flags. The mesh is not changed until you call <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">triangulation</td><td>The triangulation whose cells this function is supposed to mark for coarsening and refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">criteria</td><td>The refinement criterion for each mesh cell. Entries may not be negative.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_fraction_of_cells</td><td>The fraction of cells to be refined. If this number is zero, no cells will be refined. If it equals one, the result will be flagging for global refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom_fraction_of_cells</td><td>The fraction of cells to be coarsened. If this number is zero, no cells will be coarsened.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_n_cells</td><td>This argument can be used to specify a maximal number of cells. If this number is going to be exceeded upon refinement, then refinement and coarsening fractions are going to be adjusted in an attempt to reach the maximum number of cells. Be aware though that through proliferation of refinement due to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a>, this number is only an indicator. The default value of this argument is to impose no limit on the number of cells. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae90dc87c4db158b8d01f6d564ac614e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90dc87c4db158b8d01f6d564ac614e5">&#9670;&nbsp;</a></span>refine_and_coarsen_fixed_fraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine_and_coarsen_fixed_fraction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>top_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>bottom_fraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_n_cells</em> = <code>std::numeric_limits&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a>&#160;</td>
          <td class="paramname"><em>norm_type</em> = <code>VectorTools::NormType::L1_norm</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides a strategy to mark cells for refinement and coarsening with the goal of controlling the reduction of the error estimate.</p>
<p>Also known as the <b>bulk criterion</b> or D&ouml;rfler marking, this function computes the thresholds for refinement and coarsening such that the <code>criteria</code> of cells getting flagged for refinement make up for a certain fraction of the total error. We explain its operation for refinement, coarsening works analogously.</p>
<p>Let <em>c<sub>K</sub></em> be the criterion of cell <em>K</em>. Then the total error estimate is computed by the formula </p><p class="formulaDsp">
\[ E = \sum_{K\in \cal T} c_K. \]
</p>
<p>If <em> 0 &lt; a &lt; 1</em> is <code>top_fraction</code>, then we refine the smallest subset \(\cal M\) of the <a class="el" href="classTriangulation.html">Triangulation</a> \(\cal T\) such that </p><p class="formulaDsp">
\[ a E \le \sum_{K\in \cal M} c_K \]
</p>
<p>The algorithm is performed by the greedy algorithm described in <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">refine_and_coarsen_fixed_number()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The often used formula with squares on the left and right is recovered by actually storing the square of <em>c<sub>K</sub></em> in the vector <code>criteria</code>.</dd></dl>
<p>From the point of view of implementation, this time we really need to sort the array of criteria. Just like the other strategy described above, this function only computes the threshold values and then passes over to <a class="el" href="namespaceGridRefinement.html#a1cf30058b31ce7f9b389e8310bb9fc54">refine()</a> and <a class="el" href="namespaceGridRefinement.html#a5eee186cf23024df6854a9990a786703">coarsen()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tria</td><td>The triangulation whose cells this function is supposed to mark for coarsening and refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">criteria</td><td>The refinement criterion computed on each mesh cell. Entries may not be negative.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_fraction</td><td>The fraction of the total estimate which should be refined. If this number is zero, no cells will be refined. If it equals one, the result will be flagging for global refinement.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom_fraction</td><td>The fraction of the estimate coarsened. If this number is zero, no cells will be coarsened.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_n_cells</td><td>This argument can be used to specify a maximal number of cells. If this number is going to be exceeded upon refinement, then refinement and coarsening fractions are going to be adjusted in an attempt to reach the maximum number of cells. Be aware though that through proliferation of refinement due to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a>, this number is only an indicator. The default value of this argument is to impose no limit on the number of cells.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">norm_type</td><td>To determine thresholds, combined errors on subsets of cells are calculated as norms of the criteria on these cells. Different types of norms can be used for this purpose, from which VectorTools::NormType::L1_norm and VectorTools::NormType::L2_norm are currently supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52ecb57c6fa25805a26727843c877932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ecb57c6fa25805a26727843c877932">&#9670;&nbsp;</a></span>refine_and_coarsen_optimize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine_and_coarsen_optimize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>order</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function flags cells of a triangulation for refinement with the aim to reach a grid that is optimal with respect to an objective function that tries to balance reducing the error and increasing the numerical cost when the mesh is refined. Specifically, this function makes the assumption that if you refine a cell \(K\) with error indicator \(\eta_K\) provided by the second argument to this function, then the error on the children (for all children together) will only be \(2^{-\text{order}}\eta_K\) where <code>order</code> is the third argument of this function. This makes the assumption that the error is only a local property on a mesh and can be reduced by local refinement &ndash; an assumption that is true for the interpolation operator, but not for the usual Galerkin projection, although it is approximately true for elliptic problems where the Greens function decays quickly and the error here is not too much affected by a too coarse mesh somewhere else.</p>
<p>With this, we can define the objective function this function tries to optimize. Let us assume that the mesh currently has \(N_0\) cells. Then, if we refine the \(m\) cells with the largest errors, we expect to get (in \(d\) space dimensions) </p><p class="formulaDsp">
\[ N(m) = (N_0-m) + 2^d m = N_0 + (2^d-1)m \]
</p>
<p> cells ( \(N_0-m\) are not refined, and each of the \(m\) cells we refine yield \(2^d\) child cells. On the other hand, with refining \(m\) cells, and using the assumptions above, we expect that the error will be </p><p class="formulaDsp">
\[ \eta^\text{exp}(m) = \sum_{K, K\; \text{will not be refined}} \eta_K + \sum_{K, K\; \text{will be refined}} 2^{-\text{order}}\eta_K \]
</p>
<p> where the first sum extends over \(N_0-m\) cells and the second over the \(m\) cells that will be refined. Note that \(N(m)\) is an increasing function of \(m\) whereas \(\eta^\text{exp}(m)\) is a decreasing function.</p>
<p>This function then tries to find that number \(m\) of cells to mark for refinement for which the objective function </p><p class="formulaDsp">
\[ J(m) = N(m)^{\text{order}/d} \eta^\text{exp}(m) \]
</p>
<p> is minimal.</p>
<p>The rationale for this function is two-fold. First, compared to the <a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">refine_and_coarsen_fixed_fraction()</a> and <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">refine_and_coarsen_fixed_number()</a> functions, this function has the property that if all refinement indicators are the same (i.e., we have achieved a mesh where the error per cell is equilibrated), then the entire mesh is refined. This is based on the observation that a mesh with equilibrated error indicators is the optimal mesh (i.e., has the least overall error) among all meshes with the same number of cells. (For proofs of this, see R. Becker, M. Braack, R. Rannacher: "Numerical simulation of laminar flames at low Mach number
with adaptive finite elements", Combustion Theory and Modelling, Vol. 3, Nr. 3, p. 503-534 1999; and W. Bangerth, R. Rannacher: "Adaptive Finite
Element Methods for Differential Equations", Birkhauser, 2003.)</p>
<p>Second, the function uses the observation that ideally, the error behaves like \(e \approx c N^{-\alpha}\) with some constant \(\alpha\) that depends on the dimension and the finite element degree. It should - given optimal mesh refinement - not depend so much on the regularity of the solution, as it is based on the idea, that all singularities can be resolved by refinement. Mesh refinement is then based on the idea that we want to make \(c=e N^\alpha\) small. This corresponds to the functional \(J(m)\) above.</p>
<dl class="section note"><dt>Note</dt><dd>This function was originally implemented by Thomas Richter. It follows a strategy described in T. Richter, "Parallel Multigrid Method
for Adaptive Finite Elements with Application to 3D Flow Problems", PhD thesis, University of Heidelberg, 2005. See in particular Section 4.3, pp. 42-43. </dd></dl>

</div>
</div>
<a id="a1cf30058b31ce7f9b389e8310bb9fc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf30058b31ce7f9b389e8310bb9fc54">&#9670;&nbsp;</a></span>refine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::refine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_to_mark</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark all mesh cells for which the value in <code>criteria</code> exceeds <code>threshold</code> for refinement, but only flag up to <code>max_to_mark</code> cells.</p>
<p>The vector <code>criteria</code> contains a nonnegative value for each active cell, ordered in the canonical order of <a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation::active_cell_iterator</a>.</p>
<p>The cells are only flagged for refinement, they are not actually refined. To do so, you have to call <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a>.</p>
<p>This function does not implement a refinement strategy, it is more a helper function for the actual strategies. </p>

</div>
</div>
<a id="a5eee186cf23024df6854a9990a786703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eee186cf23024df6854a9990a786703">&#9670;&nbsp;</a></span>coarsen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridRefinement::coarsen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark all mesh cells for which the value in <code>criteria</code> is less than <code>threshold</code> for coarsening.</p>
<p>The vector <code>criteria</code> contains a nonnegative value for each active cell, ordered in the canonical order of <a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">Triangulation::active_cell_iterator</a>.</p>
<p>The cells are only flagged for coarsening, they are not actually coarsened. To do so, you have to call <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a>.</p>
<p>This function does not implement a refinement strategy, it is more a helper function for the actual strategies. </p>

</div>
</div>
<a id="a69747f64b7eca6d10665d13edd9ba712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69747f64b7eca6d10665d13edd9ba712">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridRefinement::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNegativeCriteria&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An exception thrown if the vector with cell criteria contains negative values </p>

</div>
</div>
<a id="ad72ab05d12dcbb8ecb4288619757f96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72ab05d12dcbb8ecb4288619757f96c">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridRefinement::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidParameterValue&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One of the threshold parameters causes trouble. Or the refinement and coarsening thresholds overlap. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
