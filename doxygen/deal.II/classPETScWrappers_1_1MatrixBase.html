<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classPETScWrappers_1_1MatrixBase.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PETScWrappers::MatrixBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></li><li class="navelem"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPETScWrappers_1_1MatrixBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PETScWrappers::MatrixBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__PETScWrappers.html">PETScWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="petsc__matrix__base_8h_source.html">deal.II/lac/petsc_matrix_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PETScWrappers::MatrixBase:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPETScWrappers_1_1MatrixBase__inherit__graph.svg" width="619" height="206"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a29f79582d2d2681b5f55167761d84168"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> = <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a></td></tr>
<tr class="separator:a29f79582d2d2681b5f55167761d84168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b34a2b174fb98ddb568d1aa0f52e332"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a4b34a2b174fb98ddb568d1aa0f52e332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae584b9befbadcc9293f710bde79b3d21"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a> = PetscScalar</td></tr>
<tr class="separator:ae584b9befbadcc9293f710bde79b3d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe8c5db4389d2eb35ea78e1b2db6c041"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afe8c5db4389d2eb35ea78e1b2db6c041">MatrixBase</a> ()</td></tr>
<tr class="separator:afe8c5db4389d2eb35ea78e1b2db6c041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312e0617970c8edc2308f6e4eecbdd37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a312e0617970c8edc2308f6e4eecbdd37">MatrixBase</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;)=delete</td></tr>
<tr class="separator:a312e0617970c8edc2308f6e4eecbdd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64360a1de3dd75231370e583d68b10eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a64360a1de3dd75231370e583d68b10eb">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;)=delete</td></tr>
<tr class="separator:a64360a1de3dd75231370e583d68b10eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c5947f3501c5e3280b242dfb69ea7f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a65c5947f3501c5e3280b242dfb69ea7f">~MatrixBase</a> () override</td></tr>
<tr class="separator:a65c5947f3501c5e3280b242dfb69ea7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4172ea26dafecdd3843447342f62a10c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4172ea26dafecdd3843447342f62a10c">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a> d)</td></tr>
<tr class="separator:a4172ea26dafecdd3843447342f62a10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1b895d26bc6c0a0cf96d37d00e5853c4">clear</a> ()</td></tr>
<tr class="separator:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5067751068b7290030fe97cc8cadd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af5067751068b7290030fe97cc8cadd02">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:af5067751068b7290030fe97cc8cadd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af2a6e591d33f2af5e44a20c8b3e30943">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d04e83f54969c8c504da62bdee60a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a90d04e83f54969c8c504da62bdee60a8">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a90d04e83f54969c8c504da62bdee60a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc988c43c687b2af0b7e4352def7f19b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abc988c43c687b2af0b7e4352def7f19b">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:abc988c43c687b2af0b7e4352def7f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae9fe7cc7dd404261b63b7ee651233de1">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a017ad4b1e0e18954db42d489e91ed0bb">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b079c5bf7843592a347a9874752eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a97b079c5bf7843592a347a9874752eef">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a97b079c5bf7843592a347a9874752eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068368a605f2661042e104f0ad3eef47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a068368a605f2661042e104f0ad3eef47">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a068368a605f2661042e104f0ad3eef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8298c20ffaf1ba83c286e119fd53e7d0">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abec5dd7bf11e94aeeeca18e94576c06e">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af918fe8858fea210e01de289340c2468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af918fe8858fea210e01de289340c2468">clear_row</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:af918fe8858fea210e01de289340c2468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c2d67d301ec5cb4181b071168a6783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a25c2d67d301ec5cb4181b071168a6783">clear_rows</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;rows, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:a25c2d67d301ec5cb4181b071168a6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae264ec17db96d955590626c8da8e6aad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:ae264ec17db96d955590626c8da8e6aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8eddd61ef58cb9f312b47b0e3c165f7a">operator()</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j) const</td></tr>
<tr class="separator:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89476484bfd365c60972c76d3a893925"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j) const</td></tr>
<tr class="separator:a89476484bfd365c60972c76d3a893925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a2bb6345b774b4029dc1cc04b6c5ecedf">diag_element</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i) const</td></tr>
<tr class="separator:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d397cb51074c94824c3db0a21e6210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae6d397cb51074c94824c3db0a21e6210">m</a> () const</td></tr>
<tr class="separator:ae6d397cb51074c94824c3db0a21e6210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31319c249e3ff1bf572c79ee0f41bade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a31319c249e3ff1bf572c79ee0f41bade">n</a> () const</td></tr>
<tr class="separator:a31319c249e3ff1bf572c79ee0f41bade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b350e8500ad00885d36508ded03c159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size</a> () const</td></tr>
<tr class="separator:a8b350e8500ad00885d36508ded03c159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca73a7174b92973d2a57e41af737fd1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adca73a7174b92973d2a57e41af737fd1">local_range</a> () const</td></tr>
<tr class="separator:adca73a7174b92973d2a57e41af737fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988bc02bfef4479879867a411eb2b682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a988bc02bfef4479879867a411eb2b682">in_local_range</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> index) const</td></tr>
<tr class="separator:a988bc02bfef4479879867a411eb2b682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadd5aebcdc166b840df3430a23606"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae1aadd5aebcdc166b840df3430a23606">get_mpi_communicator</a> () const =0</td></tr>
<tr class="separator:ae1aadd5aebcdc166b840df3430a23606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcc9652ade95e371d4191e28461eeb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adfcc9652ade95e371d4191e28461eeb8">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:adfcc9652ade95e371d4191e28461eeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0aee7127b31ea26d3847ce7d4d9236ad">row_length</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row) const</td></tr>
<tr class="separator:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1976b38af71b46e0fa5f3b4837f2fd05">l1_norm</a> () const</td></tr>
<tr class="separator:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd06ba7168f27d27bae50b653587fd8f"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afd06ba7168f27d27bae50b653587fd8f">linfty_norm</a> () const</td></tr>
<tr class="separator:afd06ba7168f27d27bae50b653587fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5ab9e8f1061cef606eaeb0993ce3d887">frobenius_norm</a> () const</td></tr>
<tr class="separator:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e0c76f22865de9a597b7342f87463e"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae7e0c76f22865de9a597b7342f87463e">matrix_norm_square</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:ae7e0c76f22865de9a597b7342f87463e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aef113fe7fed539cc6e5a75f457571"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0aef113fe7fed539cc6e5a75f457571">matrix_scalar_product</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:aa0aef113fe7fed539cc6e5a75f457571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bff0bbfcb1159616cb078ae9d68374"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a95bff0bbfcb1159616cb078ae9d68374">trace</a> () const</td></tr>
<tr class="separator:a95bff0bbfcb1159616cb078ae9d68374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4b99bfc37fc183a7d978ec48f83623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aad4b99bfc37fc183a7d978ec48f83623">operator*=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:aad4b99bfc37fc183a7d978ec48f83623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455541189a44467806299d3f0e0d2005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a455541189a44467806299d3f0e0d2005">operator/=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a455541189a44467806299d3f0e0d2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be932238458b6c1cd83b51571891a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5be932238458b6c1cd83b51571891a6a">add</a> (const PetscScalar factor, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;other)</td></tr>
<tr class="separator:a5be932238458b6c1cd83b51571891a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228e08f3caffe58c6213f1a142140d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a228e08f3caffe58c6213f1a142140d3f">vmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a228e08f3caffe58c6213f1a142140d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa53f7571665e69020dd5c1c90cf2e04d">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adb7231c9d5f340181ac3c45827f5b9e4">vmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714cb0c98ae635dd7591b40192dc9240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a714cb0c98ae635dd7591b40192dc9240">Tvmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a714cb0c98ae635dd7591b40192dc9240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab7d09f592d2683c8d9cb7e422dfc2e57">residual</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;x, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;b) const</td></tr>
<tr class="separator:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417ad4470cefee04a01c4595b609d310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a417ad4470cefee04a01c4595b609d310">begin</a> () const</td></tr>
<tr class="separator:a417ad4470cefee04a01c4595b609d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc2141ca2fb58139da5e1f532634958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a6cc2141ca2fb58139da5e1f532634958">end</a> () const</td></tr>
<tr class="separator:a6cc2141ca2fb58139da5e1f532634958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7d876a5651cfc339c93a5406b4f7eb79">begin</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> r) const</td></tr>
<tr class="separator:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748f0b7f03b5b7452a38b92561d2943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0748f0b7f03b5b7452a38b92561d2943">end</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> r) const</td></tr>
<tr class="separator:a0748f0b7f03b5b7452a38b92561d2943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11a01597f3233c1f817a09471c937e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac11a01597f3233c1f817a09471c937e3">operator Mat</a> () const</td></tr>
<tr class="separator:ac11a01597f3233c1f817a09471c937e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85273881d243958293bf3155e605ba67"><td class="memItemLeft" align="right" valign="top">Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a85273881d243958293bf3155e605ba67">petsc_matrix</a> ()</td></tr>
<tr class="separator:a85273881d243958293bf3155e605ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd76b6ce3247735964836a82eedff6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aacd76b6ce3247735964836a82eedff6d">transpose</a> ()</td></tr>
<tr class="separator:aacd76b6ce3247735964836a82eedff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2f6b575f15d540cf10688b30d09941"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9f2f6b575f15d540cf10688b30d09941">is_hermitian</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a9f2f6b575f15d540cf10688b30d09941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad127fd1b40ab452473f96cc298694528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ad127fd1b40ab452473f96cc298694528">write_ascii</a> (const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="separator:ad127fd1b40ab452473f96cc298694528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515e640202d1ad50bd9baa13c404cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7515e640202d1ad50bd9baa13c404cb1">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> alternative_output=false) const</td></tr>
<tr class="separator:a7515e640202d1ad50bd9baa13c404cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7a8873fc01cd20682e079dbb8f225"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0af7a8873fc01cd20682e079dbb8f225">memory_consumption</a> () const</td></tr>
<tr class="separator:a0af7a8873fc01cd20682e079dbb8f225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa059253b9ee3357d06dbd37816a1d22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afa059253b9ee3357d06dbd37816a1d22">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:afa059253b9ee3357d06dbd37816a1d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4656c942eaca0ea491fba37a0a6225eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4656c942eaca0ea491fba37a0a6225eb">DeclException2</a> (ExcWrongMode, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do a &quot;&lt;&lt;(arg1==1 ? &quot;'set'&quot; :(arg1==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt;(arg2==1 ? &quot;'set'&quot; :(arg2==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; mode. You <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a>()'.&quot;)</td></tr>
<tr class="separator:a4656c942eaca0ea491fba37a0a6225eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9795580277a7bc3a4348443768b6c0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9795580277a7bc3a4348443768b6c0fd">prepare_action</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> new_action)</td></tr>
<tr class="separator:a9795580277a7bc3a4348443768b6c0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0e10ef38e7bb5901bc5678a8a4ffd6d">assert_is_compressed</a> ()</td></tr>
<tr class="separator:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add</a> ()</td></tr>
<tr class="separator:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1b00916f856722282dcd9abb408581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9d1b00916f856722282dcd9abb408581">prepare_set</a> ()</td></tr>
<tr class="separator:a9d1b00916f856722282dcd9abb408581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49501300c99d6fea596a39fbe38b8961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a49501300c99d6fea596a39fbe38b8961">mmult</a> (<a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V) const</td></tr>
<tr class="separator:a49501300c99d6fea596a39fbe38b8961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97c266e288f1d409c1b09eae7114792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab97c266e288f1d409c1b09eae7114792">Tmmult</a> (<a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V) const</td></tr>
<tr class="separator:ab97c266e288f1d409c1b09eae7114792"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abfce46e53089351cc7fe6b9ea44e167f"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a></td></tr>
<tr class="separator:abfce46e53089351cc7fe6b9ea44e167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1deda2ab63ef62230745b4ff99bd26d6">last_action</a></td></tr>
<tr class="separator:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa0f173897e0d5d926636e85aa68c7286"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PetscInt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0f173897e0d5d926636e85aa68c7286">column_indices</a></td></tr>
<tr class="separator:aa0f173897e0d5d926636e85aa68c7286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289dc1463501c97a48127414ce5ee1ac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; PetscScalar &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a289dc1463501c97a48127414ce5ee1ac">column_values</a></td></tr>
<tr class="separator:a289dc1463501c97a48127414ce5ee1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aad4d4720fcda9813b7fdcd3f0cb04ac6"><td class="memTemplParams" colspan="2">template&lt;class &gt; </td></tr>
<tr class="memitem:aad4d4720fcda9813b7fdcd3f0cb04ac6"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aad4d4720fcda9813b7fdcd3f0cb04ac6">::BlockMatrixBase</a></td></tr>
<tr class="separator:aad4d4720fcda9813b7fdcd3f0cb04ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>所有在PETSc矩阵类型之上实现的矩阵类的基类。由于在PETSc中，所有的矩阵类型（即顺序和平行，稀疏，阻塞等）都是通过填充一个抽象对象的内容来建立的，而这个抽象对象只能通过一个独立于实际矩阵类型的指针来引用，所以我们可以在这个基类中实现几乎所有的矩阵功能。然后，派生类将只需要提供创建一种或另一种矩阵的功能。 这个类的接口是以deal.II中现有的SparseMatrix类为模型的。它有几乎相同的成员函数，而且通常是可以交换的。然而，由于PETSc只支持单一的标量类型（要么是双数、浮点数，要么是复杂的数据类型），所以它没有模板化，只能与你的PETSc安装中定义的数据类型PetscScalar一起工作。 请注意，只有在矩阵装配后调用了函数 <code>MatAssemblyBegin</code> 和 <code>MatAssemblyEnd</code> 的情况下，PETSc才能保证操作符合你的期望。因此，你需要在实际使用矩阵之前调用 <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">SparseMatrix::compress()</a> 。这也会调用 <code>MatCompress</code> ，通过丢弃未使用的元素来压缩稀疏矩阵的存储格式。PETSc允许在调用这些函数后继续装配矩阵，但由于此后不再有可用的条目，所以最好在装配阶段结束后，在主动使用矩阵之前，只调用一次 <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">SparseMatrix::compress()</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00270">270</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a29f79582d2d2681b5f55167761d84168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f79582d2d2681b5f55167761d84168">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">PETScWrappers::MatrixBase::const_iterator</a> =  <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为迭代器类声明一个别名。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00277">277</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a4b34a2b174fb98ddb568d1aa0f52e332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b34a2b174fb98ddb568d1aa0f52e332">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">PETScWrappers::MatrixBase::size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明容器大小的类型。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00283">283</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="ae584b9befbadcc9293f710bde79b3d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae584b9befbadcc9293f710bde79b3d21">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">PETScWrappers::MatrixBase::value_type</a> =  PetscScalar</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明一个类似于所有其他容器类的别名。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00289">289</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afe8c5db4389d2eb35ea78e1b2db6c041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8c5db4389d2eb35ea78e1b2db6c041">&#9670;&nbsp;</a></span>MatrixBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::MatrixBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>默认的构造函数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00077">77</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a312e0617970c8edc2308f6e4eecbdd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312e0617970c8edc2308f6e4eecbdd37">&#9670;&nbsp;</a></span>MatrixBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::MatrixBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制构造函数。它被删除了，因为在不知道所存储的矩阵的具体种类的情况下复制这个基类，可能会错过重要的细节，而且如果矩阵很大的话，也会很昂贵。 </p>

</div>
</div>
<a id="a65c5947f3501c5e3280b242dfb69ea7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c5947f3501c5e3280b242dfb69ea7f">&#9670;&nbsp;</a></span>~MatrixBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::~MatrixBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>销毁器。虚化，以便人们可以使用指向这个类的指针。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00084">84</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a64360a1de3dd75231370e583d68b10eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64360a1de3dd75231370e583d68b10eb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a>&amp; PETScWrappers::MatrixBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制操作符。它被删除了，因为在不知道所存储的矩阵的具体种类的情况下复制这个基类可能会错过重要的细节，而且如果矩阵很大的话，费用也很高。 </p>

</div>
</div>
<a id="a4172ea26dafecdd3843447342f62a10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4172ea26dafecdd3843447342f62a10c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零时进行。这个操作符的存在只是为了允许明显的符号<code>matrix=0</code>，它将矩阵的所有元素设置为零，但保留了之前使用的稀疏模式。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00111">111</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a1b895d26bc6c0a0cf96d37d00e5853c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b895d26bc6c0a0cf96d37d00e5853c4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00092">92</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="af5067751068b7290030fe97cc8cadd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5067751068b7290030fe97cc8cadd02">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将元素(<em>i,j</em>)设置为 <code>value</code>. 如果现在的对象(来自这个对象的派生类)恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一个新的条目，如果该条目之前不存在的话，这与SparseMatrix类形成了很大的反差，如果该条目不存在则会抛出错误。如果<code>value</code>不是一个有限的数字，就会抛出一个异常。 </p>

</div>
</div>
<a id="af2a6e591d33f2af5e44a20c8b3e30943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a6e591d33f2af5e44a20c8b3e30943">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素设置为<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素写入调用的矩阵中，对矩阵的行和列都使用<code>indices</code>指定的本地到全球索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选的参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="a90d04e83f54969c8c504da62bdee60a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d04e83f54969c8c504da62bdee60a8">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与之前的功能相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的局部到全局的索引。 </p>

</div>
</div>
<a id="abc988c43c687b2af0b7e4352def7f19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc988c43c687b2af0b7e4352def7f19b">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选的参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="ae9fe7cc7dd404261b63b7ee651233de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fe7cc7dd404261b63b7ee651233de1">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将几个元素设置为由<code>values</code>给定的值，在由col_indices给定的列中设置为稀疏矩阵的行。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选的参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="a017ad4b1e0e18954db42d489e91ed0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017ad4b1e0e18954db42d489e91ed0bb">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将 <code>value</code> 添加到元素（<em>i,j</em>）。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一个新的条目，如果该条目之前不存在的话，这与SparseMatrix类非常不同，后者在该条目不存在的情况下会抛出一个错误。如果<code>value</code>不是一个有限的数字，就会抛出一个异常。 </p>

</div>
</div>
<a id="a97b079c5bf7843592a347a9874752eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b079c5bf7843592a347a9874752eef">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素添加到由<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素添加到调用矩阵的相应条目中，使用<code>indices</code>为矩阵的行和列指定的本地到全球索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a068368a605f2661042e104f0ad3eef47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068368a605f2661042e104f0ad3eef47">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="a8298c20ffaf1ba83c286e119fd53e7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8298c20ffaf1ba83c286e119fd53e7d0">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="abec5dd7bf11e94aeeeca18e94576c06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec5dd7bf11e94aeeeca18e94576c06e">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<code>values</code>给出的数值阵列。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类形成鲜明对比，后者在条目不存在的时候会抛出一个错误。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="af918fe8858fea210e01de289340c2468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af918fe8858fea210e01de289340c2468">&#9670;&nbsp;</a></span>clear_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将此<code>行</code>中的所有元素设置为零，将其删除。这个函数并不修改分配的非零条目的数量，它只是将一些条目设置为零。不过，它可能会将它们从稀疏模式中删除（但会保留分配的内存，以备以后再次添加新的条目）。 这个操作用于消除约束（例如由于挂起的节点），并确保我们可以将这个修改写入矩阵，而不需要从矩阵中读取条目（例如非零元素的位置）。</p>
<ul>
<li>如果没有这个操作，消除平行矩阵的约束是一个相当复杂的过程。 第二个参数可以用来将该行的对角线条目设置为一个不同于零的值。默认是将其设置为零。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00127">127</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a25c2d67d301ec5cb4181b071168a6783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c2d67d301ec5cb4181b071168a6783">&#9670;&nbsp;</a></span>clear_rows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与clear_row()相同，只是它同时作用于若干行。 第二个参数可以用来将所有被清除的行的对角线条目设置为不同于0的内容。请注意，所有这些对角线项都得到相同的值</p>
<ul>
<li>如果你想要不同的对角线条目的值，你必须手动设置它们。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00136">136</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae264ec17db96d955590626c8da8e6aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae264ec17db96d955590626c8da8e6aad">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::compress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PETSc矩阵存储了它们自己的稀疏性模式。因此，与我们自己的SparsityPattern类相类似，这个函数压缩了稀疏模式，并允许将得到的矩阵用于所有其他操作，而以前只允许使用汇编函数。因此，一旦你组装了矩阵，就必须调用这个函数。 更多信息请参见 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式对象</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00193">193</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8eddd61ef58cb9f312b47b0e3c165f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eddd61ef58cb9f312b47b0e3c165f7a">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回条目的值（<em>i,j</em>）。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。 与 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类中的相应函数相比，如果相应的条目不存在于该类的稀疏模式中，我们不会抛出一个异常，因为PETSc并不传输这一信息。 因此这个函数完全等同于<code><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el()</a></code>函数。 </p>

</div>
</div>
<a id="a89476484bfd365c60972c76d3a893925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89476484bfd365c60972c76d3a893925">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵条目的值（<em>i,j</em>）。如果这个条目不存在于稀疏模式中，那么就返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，写出的算法与最优解相比很简单，很慢。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00165">165</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a2bb6345b774b4029dc1cc04b6c5ecedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb6345b774b4029dc1cc04b6c5ecedf">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回第<em>i</em>行中的主对角线元素。如果矩阵不是二次的，这个函数会抛出一个错误。 由于我们不能直接访问底层数据结构，这个函数并不比使用el()函数的元素访问快。然而，我们提供这个函数是为了与SparseMatrix类兼容。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00181">181</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae6d397cb51074c94824c3db0a21e6210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d397cb51074c94824c3db0a21e6210">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵的行数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00237">237</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a31319c249e3ff1bf572c79ee0f41bade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31319c249e3ff1bf572c79ee0f41bade">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵中的列数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00250">250</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8b350e8500ad00885d36508ded03c159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b350e8500ad00885d36508ded03c159">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的本地维度，即存储在当前MPI进程中的行数。对于顺序矩阵，这个数字与m()相同，但对于并行矩阵，这个数字可能更小。 要想知道到底哪些元素被存储在本地，可以使用local_range()。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00263">263</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adca73a7174b92973d2a57e41af737fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca73a7174b92973d2a57e41af737fd1">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> &gt; PETScWrappers::MatrixBase::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一对指数，表明该矩阵的哪些行是本地存储的。第一个数字是存储的第一行的索引，第二个数字是本地存储的最后一行之后的那一行的索引。如果这是一个连续的矩阵，那么结果将是一对(0,m())，否则将是一对(i,i+n)，其中<code>n=<a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size()</a></code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00276">276</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a988bc02bfef4479879867a411eb2b682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988bc02bfef4479879867a411eb2b682">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::MatrixBase::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回 <code>index</code> 是否在本地范围内，另见local_range()。 </p>

</div>
</div>
<a id="ae1aadd5aebcdc166b840df3430a23606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aadd5aebcdc166b840df3430a23606">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&amp; PETScWrappers::MatrixBase::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回对与该矩阵一起使用的MPI通信器对象的引用。这个函数必须在派生类中实现。 </p>

<p>Implemented in <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a2fa85242545b5d377c3734526c3c72ee">PETScWrappers::MPI::SparseMatrix</a>, <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a2fa85242545b5d377c3734526c3c72ee">PETScWrappers::SparseMatrix</a>, <a class="el" href="classPETScWrappers_1_1MatrixFree.html#a07805863a4a4cdd6bc7c341603811174">PETScWrappers::MatrixFree</a>, and <a class="el" href="classPETScWrappers_1_1FullMatrix.html#ab37405686b8ea841ce1734de77319a8a">PETScWrappers::FullMatrix</a>.</p>

</div>
</div>
<a id="adfcc9652ade95e371d4191e28461eeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcc9652ade95e371d4191e28461eeb8">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00290">290</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0aee7127b31ea26d3847ce7d4d9236ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aee7127b31ea26d3847ce7d4d9236ad">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>特定行中的条目数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00302">302</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a1976b38af71b46e0fa5f3b4837f2fd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1976b38af71b46e0fa5f3b4837f2fd05">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的l1准则，即 \(|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|\) ，（最大列数之和）。这是一个自然的矩阵准则，与向量的l1准则兼容，即 \(|Mv|_1\leq |M|_1 |v|_1\) 。(参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00338">338</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afd06ba7168f27d27bae50b653587fd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd06ba7168f27d27bae50b653587fd8f">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的linfty-norm，即 \(|M|_infty=max_{all rows i}\sum_{all columns j} |M_ij|\) ，（最大行数之和）。这是一个自然的矩阵规范，与向量的linfty-norm兼容，即 \(|Mv|_infty \leq |M|_infty |v|_infty\) 。(参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00351">351</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5ab9e8f1061cef606eaeb0993ce3d887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab9e8f1061cef606eaeb0993ce3d887">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的frobenius norm，即矩阵中所有条目的平方之和的平方根。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00364">364</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae7e0c76f22865de9a597b7342f87463e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e0c76f22865de9a597b7342f87463e">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量 \(v\) 相对于该矩阵诱导的准则的平方，即 \(\left(v,Mv\right)\) 。这很有用，例如在有限元背景下，一个函数的 \(L_2\) 规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。 很明显，对于这个操作，矩阵需要是二次的。 这个函数的实现没有deal.II中使用的 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类（即原始的，而不是PETSc封装类）的效率高，因为PETSc不支持这个操作，需要一个临时向量。 注意，如果当前对象代表一个并行的分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么给出的向量也必须是一个分布式向量。反之，如果矩阵不是分布式的，那么向量也不可能是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00376">376</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa0aef113fe7fed539cc6e5a75f457571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aef113fe7fed539cc6e5a75f457571">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u,Mv\right)\) 。 这个函数的实现不如deal.II中使用的 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类（即原始函数，而不是PETSc封装类）的效率高，因为PETSc不支持这个操作，需要一个临时矢量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可能是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00385">385</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a95bff0bbfcb1159616cb078ae9d68374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bff0bbfcb1159616cb078ae9d68374">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的轨迹，即矩阵中所有对角线项的总和。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00395">395</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aad4b99bfc37fc183a7d978ec48f83623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4b99bfc37fc183a7d978ec48f83623">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator*= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将整个矩阵乘以一个固定系数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00408">408</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a455541189a44467806299d3f0e0d2005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455541189a44467806299d3f0e0d2005">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator/= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用整个矩阵除以一个固定系数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00419">419</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5be932238458b6c1cd83b51571891a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be932238458b6c1cd83b51571891a6a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将矩阵 <code>other</code> 按系数 <code>factor</code> 的比例添加到当前矩阵中。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00430">430</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a228e08f3caffe58c6213f1a142140d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228e08f3caffe58c6213f1a142140d3f">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M*src</em>与<em>M</em>是这个矩阵。 源和目的不能是同一个向量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00441">441</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa53f7571665e69020dd5c1c90cf2e04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53f7571665e69020dd5c1c90cf2e04d">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M<sup>T</sup>*src</em>与<em>M</em>为这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 源和目的不能是同一个向量。 注意，如果当前对象代表一个并行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00452">452</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adb7231c9d5f340181ac3c45827f5b9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7231c9d5f340181ac3c45827f5b9e4">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>加法 矩阵-向量乘法。在<em>dst</em>上添加<em>M*src</em>，<em>M</em>为该矩阵。 源和目的不能是同一个向量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00463">463</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a714cb0c98ae635dd7591b40192dc9240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714cb0c98ae635dd7591b40192dc9240">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>加法 矩阵-向量乘法。将<em>M<sup>T</sup>*src</em>加到<em>dst</em>，<em>M</em>是这个矩阵。这个函数与vmult_add()的作用相同，但需要转置的矩阵。 来源和目的地不能是同一个向量。 注意，如果当前对象代表一个并行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00474">474</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ab7d09f592d2683c8d9cb7e422dfc2e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d09f592d2683c8d9cb7e422dfc2e57">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个方程<em>Mx=b</em>的残差，其中残差被定义为<em>r=b-Mx</em>。将残差写入 <code>dst</code>. 返回残差向量的<em>l<sub>2</sub></em>准则。 源<em>x</em>和目的<em>dst</em>不能是同一个向量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么所有的向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不能是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00574">574</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a417ad4470cefee04a01c4595b609d310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417ad4470cefee04a01c4595b609d310">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>迭代器从第一个条目开始。这只能在拥有整个矩阵的处理器上调用。在所有其他情况下，请参考以行号为参数的begin()的版本。 </p>

</div>
</div>
<a id="a6cc2141ca2fb58139da5e1f532634958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc2141ca2fb58139da5e1f532634958">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>最后的迭代器。这只能在拥有整个矩阵的处理器上调用。在所有其他情况下，请参考end()的版本，以一个行号作为参数。 </p>

</div>
</div>
<a id="a7d876a5651cfc339c93a5406b4f7eb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d876a5651cfc339c93a5406b4f7eb79">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>迭代器从第 <code>r</code>. 行的第一个条目开始 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<code>end(r)</code>。还要注意的是，在这种情况下，迭代器可能不能被解除引用。 </p>

</div>
</div>
<a id="a0748f0b7f03b5b7452a38b92561d2943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748f0b7f03b5b7452a38b92561d2943">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>行<code>r</code>的最终迭代器。它指向超过行 <code>r</code>, 末尾的第一个元素，或者超过整个稀疏模式的末尾。 请注意，结束迭代器不一定是可被解除引用的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。 </p>

</div>
</div>
<a id="ac11a01597f3233c1f817a09471c937e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11a01597f3233c1f817a09471c937e3">&#9670;&nbsp;</a></span>operator Mat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::operator Mat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>转换操作符，以获得对底层PETSc类型的访问。如果你这样做，你就切断了这个类可能需要的一些信息，所以这个转换操作符应该只在你知道你要做什么的时候使用。特别是，它应该只用于对矩阵的只读操作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00590">590</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a85273881d243958293bf3155e605ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85273881d243958293bf3155e605ba67">&#9670;&nbsp;</a></span>petsc_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Mat &amp; PETScWrappers::MatrixBase::petsc_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对底层PETSc类型的引用。它可以用来修改底层数据，所以只有在你知道你在做什么的时候才使用它。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00596">596</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aacd76b6ce3247735964836a82eedff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd76b6ce3247735964836a82eedff6d">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对一个矩阵进行原地转置。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00602">602</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a4a1057a35382b7c328e6c85b0f5ab35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1057a35382b7c328e6c85b0f5ab35e">&#9670;&nbsp;</a></span>is_symmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>测试矩阵是否是对称的。 默认公差为 \(1000\times32\) -位机器精度。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00614">614</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a9f2f6b575f15d540cf10688b30d09941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2f6b575f15d540cf10688b30d09941">&#9670;&nbsp;</a></span>is_hermitian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_hermitian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>测试一个矩阵是否是赫米特的，即它是其转置的复共轭。默认公差为 \(1000\times32\) -位机器精度。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00624">624</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ad127fd1b40ab452473f96cc298694528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad127fd1b40ab452473f96cc298694528">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::write_ascii </td>
          <td>(</td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用PETSc内部矩阵查看器功能<code>MatView</code>打印PETSc矩阵对象的值。默认格式是打印非零矩阵元素。对于其他有效的查看格式，请参考http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00636">636</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a7515e640202d1ad50bd9baa13c404cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7515e640202d1ad50bd9baa13c404cb1">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印矩阵的元素到给定的输出流。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>要写入的输出流。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternative_output</td><td>这个参数被忽略。它的存在是为了与其他矩阵类中的类似函数兼容。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00651">651</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0af7a8873fc01cd20682e079dbb8f225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af7a8873fc01cd20682e079dbb8f225">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t PETScWrappers::MatrixBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该矩阵在该CPU上所消耗的字节数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00682">682</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afa059253b9ee3357d06dbd37816a1d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa059253b9ee3357d06dbd37816a1d22">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcSourceEqualsDestination&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You are attempting an operation on two matrices that &quot; &quot;are the same&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but the operation requires that the &quot; &quot;two objects are in fact different.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a4656c942eaca0ea491fba37a0a6225eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4656c942eaca0ea491fba37a0a6225eb">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcWrongMode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to do a &quot;&lt;&lt;(arg1==1 ? &quot;'set'&quot; :(arg1==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt;(arg2==1 ? &quot;'set'&quot; :(arg2==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; mode. You <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a>()'.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况。 </p>

</div>
</div>
<a id="a9795580277a7bc3a4348443768b6c0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9795580277a7bc3a4348443768b6c0fd">&#9670;&nbsp;</a></span>prepare_action()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_action </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>new_action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确保此调用后的动作所需的添加/设置模式与当前模式兼容。应该从所有访问矩阵元素的内部函数中调用。 </p>

</div>
</div>
<a id="aa0e10ef38e7bb5901bc5678a8a4ffd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e10ef38e7bb5901bc5678a8a4ffd6d">&#9670;&nbsp;</a></span>assert_is_compressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::assert_is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>内部函数，检查是否有未决的插入/添加操作。否则会抛出一个异常。在调用任何修改矩阵的PETSc内部函数之前，都是有用的。 </p>

</div>
</div>
<a id="aa6e49d52a74cc86386a9aff01fa88c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e49d52a74cc86386a9aff01fa88c74">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于某些矩阵存储格式，特别是PETSc分布式块状矩阵，单个元素的设置和添加操作不能自由混合。相反，当我们想从设置元素切换到添加元素时，我们必须同步操作。BlockMatrixBase通过为每个块调用这个辅助函数来自动同步访问。这个函数确保矩阵处于允许添加元素的状态；如果它之前已经处于这种状态，那么这个函数什么也不做。 </p>

</div>
</div>
<a id="a9d1b00916f856722282dcd9abb408581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1b00916f856722282dcd9abb408581">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与prepare_add()相同，但如果该类中的元素表示法需要这样的操作，则为设置元素准备矩阵。 </p>

</div>
</div>
<a id="a49501300c99d6fea596a39fbe38b8961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49501300c99d6fea596a39fbe38b8961">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>执行矩阵-矩阵乘法 \(C = AB\) 的基础函数，或者，如果给出一个大小与B兼容的向量 \(V\) ，则为 \(C = A \text{diag}(V) B\) ，其中 \(\text{diag}(V)\) 定义了一个带有向量项的对角矩阵。 这个函数假定调用矩阵 \(A\) 和 \(B\) 的大小兼容。 \(C\) 的大小将在本函数中设置。 矩阵 \(C\) 的内容和稀疏模式将被这个函数重置，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00558">558</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ab97c266e288f1d409c1b09eae7114792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97c266e288f1d409c1b09eae7114792">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基准函数，用于执行矩阵与<code>this</code>的转置相乘，即 \(C = A^T B\) ，或者，如果给出一个可选矢量 \(V\) ，其大小与 \(B\) 兼容，则为 \(C = A^T \text{diag}(V) B\) ，其中 \(\text{diag}(V)\) 定义了一个带有矢量项的对角矩阵。 这个函数假设调用矩阵 \(A\) 和 \(B\) 的大小兼容。 \(C\) 的大小将在本函数中设置。 矩阵 \(C\) 的内容和稀疏模式将被这个函数改变，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00566">566</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aad4d4720fcda9813b7fdcd3f0cb04ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4d4720fcda9813b7fdcd3f0cb04ac6">&#9670;&nbsp;</a></span>::BlockMatrixBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ::<a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00900">900</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abfce46e53089351cc7fe6b9ea44e167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfce46e53089351cc7fe6b9ea44e167f">&#9670;&nbsp;</a></span>matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat PETScWrappers::MatrixBase::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个PETSc中的通用矩阵对象。实际的类型是稀疏矩阵，在构造函数中设置。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00817">817</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a1deda2ab63ef62230745b4ff99bd26d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deda2ab63ef62230745b4ff99bd26d6">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> PETScWrappers::MatrixBase::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储最后一个动作是写还是加操作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00823">823</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="aa0f173897e0d5d926636e85aa68c7286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f173897e0d5d926636e85aa68c7286">&#9670;&nbsp;</a></span>column_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PetscInt&gt; PETScWrappers::MatrixBase::column_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个内部的整数数组，当向（大的）稀疏矩阵添加/插入本地数据时，用于存储列索引。 这个变量并不存储矩阵对象的任何 "状态"。相反，它只是被这个类的一些成员函数用作临时缓冲区。与所有的 <code>mutable</code> 成员变量一样，除非有突变器的保护，否则对这个变量的使用不是线程安全的。然而，由于PETSc矩阵操作无论如何都不是线程安全的，所以没有必要试图使事情变得线程安全，所以没有与这个变量相关的突变。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00888">888</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a289dc1463501c97a48127414ce5ee1ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289dc1463501c97a48127414ce5ee1ac">&#9670;&nbsp;</a></span>column_values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;PetscScalar&gt; PETScWrappers::MatrixBase::column_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个内部的双值数组，在向（大的）稀疏矩阵添加/插入本地数据时，用于存储列索引。 与上面 <code>column_indices</code> 变量的注释相同。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00895">895</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a></li>
<li>source/lac/<a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
