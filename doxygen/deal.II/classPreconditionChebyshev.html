<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classPreconditionChebyshev.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PreconditionChebyshev&lt; MatrixType, VectorType, PreconditionerType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPreconditionChebyshev-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PreconditionChebyshev&lt; MatrixType, VectorType, PreconditionerType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo;  &#124; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Preconditioners.html">Preconditioners and Relaxation Operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="precondition_8h_source.html">deal.II/lac/precondition.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PreconditionChebyshev&lt; MatrixType, VectorType, PreconditionerType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPreconditionChebyshev__inherit__graph.svg" width="190" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPreconditionChebyshev_1_1EigenvalueInformation.html">EigenvalueInformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab1a3cf839ba5fba53fc7d441031a50e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#ab1a3cf839ba5fba53fc7d441031a50e4">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ab1a3cf839ba5fba53fc7d441031a50e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af92969d2c22a65faa61d40ab4fff94f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#af92969d2c22a65faa61d40ab4fff94f4">PreconditionChebyshev</a> ()</td></tr>
<tr class="separator:af92969d2c22a65faa61d40ab4fff94f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29ca6897af2daec521d5d4407dca843"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#ae29ca6897af2daec521d5d4407dca843">initialize</a> (const MatrixType &amp;matrix, const <a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data=<a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:ae29ca6897af2daec521d5d4407dca843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad256fafca2741e0d37cc82695f0bb240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#ad256fafca2741e0d37cc82695f0bb240">vmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:ad256fafca2741e0d37cc82695f0bb240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bfb1160c35429d7ed3bb3ccca1c281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a11bfb1160c35429d7ed3bb3ccca1c281">Tvmult</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a11bfb1160c35429d7ed3bb3ccca1c281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45209d9d4c47f6ed1675bd7c6563cfb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a45209d9d4c47f6ed1675bd7c6563cfb3">step</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a45209d9d4c47f6ed1675bd7c6563cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb2f2b8e8637bbed91b327af0490fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a6bb2f2b8e8637bbed91b327af0490fe6">Tstep</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a6bb2f2b8e8637bbed91b327af0490fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794112afe378c506eb955b7b954a0cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a794112afe378c506eb955b7b954a0cf2">clear</a> ()</td></tr>
<tr class="separator:a794112afe378c506eb955b7b954a0cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2450003ef85f7b879f4165c3308c881d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPreconditionChebyshev.html#ab1a3cf839ba5fba53fc7d441031a50e4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a2450003ef85f7b879f4165c3308c881d">m</a> () const</td></tr>
<tr class="separator:a2450003ef85f7b879f4165c3308c881d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d831e00a583321227713af6efd5f850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPreconditionChebyshev.html#ab1a3cf839ba5fba53fc7d441031a50e4">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a3d831e00a583321227713af6efd5f850">n</a> () const</td></tr>
<tr class="separator:a3d831e00a583321227713af6efd5f850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cf24ff83d957daca6be28ffd47f7b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPreconditionChebyshev_1_1EigenvalueInformation.html">EigenvalueInformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a68cf24ff83d957daca6be28ffd47f7b3">estimate_eigenvalues</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a68cf24ff83d957daca6be28ffd47f7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7c774145ba7c91f96a3937cd7cbed196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const MatrixType, <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a7c774145ba7c91f96a3937cd7cbed196">matrix_ptr</a></td></tr>
<tr class="separator:a7c774145ba7c91f96a3937cd7cbed196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a332bf35ca46f19c46b7db33bd9e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorType.html">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a47a332bf35ca46f19c46b7db33bd9e4a">solution_old</a></td></tr>
<tr class="separator:a47a332bf35ca46f19c46b7db33bd9e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5340a84d3dcb8fbb8fc03e0e7df3cc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorType.html">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#ad5340a84d3dcb8fbb8fc03e0e7df3cc4">temp_vector1</a></td></tr>
<tr class="separator:ad5340a84d3dcb8fbb8fc03e0e7df3cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca88a1ace994929ee001cde4cb550cad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorType.html">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#aca88a1ace994929ee001cde4cb550cad">temp_vector2</a></td></tr>
<tr class="separator:aca88a1ace994929ee001cde4cb550cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466d8de8df88e537b97eb4a2a079e446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a466d8de8df88e537b97eb4a2a079e446">data</a></td></tr>
<tr class="separator:a466d8de8df88e537b97eb4a2a079e446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd006b5b18e5cdcbd6f84beb69b42d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#adfd006b5b18e5cdcbd6f84beb69b42d4">theta</a></td></tr>
<tr class="separator:adfd006b5b18e5cdcbd6f84beb69b42d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8943e4eeaf4252685366b9bfc95aa7e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a8943e4eeaf4252685366b9bfc95aa7e5">delta</a></td></tr>
<tr class="separator:a8943e4eeaf4252685366b9bfc95aa7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66930051ab57c14a099d41f3b3de7cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#ae66930051ab57c14a099d41f3b3de7cf">eigenvalues_are_initialized</a></td></tr>
<tr class="separator:ae66930051ab57c14a099d41f3b3de7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0519735257cd1f3e7960739a9632d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreconditionChebyshev.html#a2a0519735257cd1f3e7960739a9632d1">mutex</a></td></tr>
<tr class="separator:a2a0519735257cd1f3e7960739a9632d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt;<br />
class PreconditionChebyshev&lt; MatrixType, VectorType, PreconditionerType &gt;</h3>

<p>Preconditioning with a Chebyshev polynomial for symmetric positive definite matrices. This preconditioner is based on an iteration of an inner preconditioner of type <code>PreconditionerType</code> with coefficients that are adapted to optimally cover an eigenvalue range between the largest eigenvalue \(\lambda_{\max{}}\) down to a given lower eigenvalue \(\lambda_{\min{}}\) specified by the optional parameter <code>smoothing_range</code>. The algorithm is based on the following three-term recurrence: </p><p class="formulaDsp">
\[ x^{n+1} = x^{n} + \rho_n \rho_{n-1} (x^{n} - x^{n-1}) + \frac{\rho_n}{\lambda_{\max{}}-\lambda_{\min{}}} P^{-1} (b-Ax^n). \]
</p>
<p> where the parameter \(\rho_0\) is set to \(\rho_0 = 2 \frac{\lambda_{\max{}}-\lambda_{\min{}}}{\lambda_{\max{}}+\lambda_{\min{}}}\) for the maximal eigenvalue \(\lambda_{\max{}}\) and updated via \(\rho_n = \left(2\frac{\lambda_{\max{}}+\lambda_{\min{}}} {\lambda_{\max{}}-\lambda_{\min{}}} - \rho_{n-1}\right)^{-1}\). The Chebyshev polynomial is constructed to strongly damp the eigenvalue range between \(\lambda_{\min{}}\) and \(\lambda_{\max{}}\) and is visualized e.g. in <a class="el" href="namespaceUtilities_1_1LinearAlgebra.html#a19ce01cf01ee57e2b1237944154646e6">Utilities::LinearAlgebra::chebyshev_filter()</a>.</p>
<p>The typical use case for the preconditioner is a Jacobi preconditioner specified through <a class="el" href="classDiagonalMatrix.html">DiagonalMatrix</a>, which is also the default value for the preconditioner. Note that if the degree variable is set to one, the Chebyshev iteration corresponds to a Jacobi preconditioner (or the underlying preconditioner type) with relaxation parameter according to the specified smoothing range.</p>
<p>Besides the default choice of a pointwise Jacobi preconditioner, this class also allows for more advanced types of preconditioners, for example iterating block-Jacobi preconditioners in DG methods.</p>
<p>Apart from the inner preconditioner object, this iteration does not need access to matrix entries, which makes it an ideal ingredient for matrix-free computations. In that context, this class can be used as a multigrid smoother that is trivially parallel (assuming that matrix-vector products are parallel and the inner preconditioner is parallel). Its use is demonstrated in the step-37 and step-59 tutorial programs.</p>
<h4>Estimation of the eigenvalues</h4>
<p>The Chebyshev method relies on an estimate of the eigenvalues of the matrix which are computed during the first invocation of <a class="el" href="classPreconditionChebyshev.html#ad256fafca2741e0d37cc82695f0bb240">vmult()</a>. The algorithm invokes a conjugate gradient solver (i.e., Lanczos iteration) so symmetry and positive definiteness of the (preconditioned) matrix system are required. The eigenvalue algorithm can be controlled by <a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html#a7cc716583c0d0d179cada4f8db426922">PreconditionChebyshev::AdditionalData::eig_cg_n_iterations</a> specifying how many iterations should be performed. The iterations are started from an initial vector that depends on the vector type. For the classes <a class="el" href="classVector.html">Vector</a> or <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>, which have fast element access, it is a vector with entries <code>(-5.5, -4.5, -3.5, -2.5, ..., 3.5, 4.5, 5.5)</code> with appropriate epilogue and adjusted such that its mean is always zero, which works well for the Laplacian. This setup is stable in parallel in the sense that for a different number of processors but the same ordering of unknowns, the same initial vector and thus eigenvalue distribution will be computed, apart from roundoff errors. For other vector types, the initial vector contains all ones, scaled by the length of the vector, except for the very first entry that is zero, triggering high-frequency content again.</p>
<p>The computation of eigenvalues happens the first time one of the <a class="el" href="classPreconditionChebyshev.html#ad256fafca2741e0d37cc82695f0bb240">vmult()</a>, <a class="el" href="classPreconditionChebyshev.html#a11bfb1160c35429d7ed3bb3ccca1c281">Tvmult()</a>, <a class="el" href="classPreconditionChebyshev.html#a45209d9d4c47f6ed1675bd7c6563cfb3">step()</a> or <a class="el" href="classPreconditionChebyshev.html#a6bb2f2b8e8637bbed91b327af0490fe6">Tstep()</a> functions is called or when <a class="el" href="classPreconditionChebyshev.html#a68cf24ff83d957daca6be28ffd47f7b3">estimate_eigenvalues()</a> is called directly. In the latter case, it is necessary to provide a temporary vector of the same layout as the source and destination vectors used during application of the preconditioner.</p>
<p>The estimates for minimum and maximum eigenvalue are taken from <a class="el" href="classSolverCG.html">SolverCG</a> (even if the solver did not converge in the requested number of iterations). Finally, the maximum eigenvalue is multiplied by a safety factor of 1.2.</p>
<p>Due to the cost of the eigenvalue estimate, this class is most appropriate if it is applied repeatedly, e.g. in a smoother for a geometric multigrid solver, that can in turn be used to solve several linear systems.</p>
<h4>Bypassing the eigenvalue computation</h4>
<p>In some contexts, the automatic eigenvalue computation of this class may result in bad quality, or it may be unstable when used in parallel with different enumerations of the degrees of freedom, making computations strongly dependent on the parallel configuration. It is possible to bypass the automatic eigenvalue computation by setting <a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html#a7cc716583c0d0d179cada4f8db426922">AdditionalData::eig_cg_n_iterations</a> to zero, and provide the variable <a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html#acb1b802cb6958df2a7a07938b842e0bd">AdditionalData::max_eigenvalue</a> instead. The minimal eigenvalue is implicitly specified via <code>max_eigenvalue/smoothing_range</code>.</p>
<h4>Using the <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a> as a solver</h4>
<p>If the range <code>[max_eigenvalue/smoothing_range, max_eigenvalue]</code> contains all eigenvalues of the preconditioned matrix system and the degree (i.e., number of iterations) is high enough, this class can also be used as a direct solver. For an error estimation of the Chebyshev iteration that can be used to determine the number of iteration, see Varga (2009).</p>
<p>In order to use Chebyshev as a solver, set the degree to <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> to force the automatic computation of the number of iterations needed to reach a given target tolerance. In this case, the target tolerance is read from the variable <a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html#a3b9421232bbe3a845131ae07a710abb8">PreconditionChebyshev::AdditionalData::smoothing_range</a> (it needs to be a number less than one to force any iterations obviously).</p>
<p>For details on the algorithm, see section 5.1 of </p><div class="fragment"><div class="line">@book{Varga2009,</div><div class="line">  Title     = {Matrix iterative analysis},</div><div class="line">  Author    = {Varga, R. S.},</div><div class="line">  Publisher = {Springer},</div><div class="line">  Address   = {Berlin},</div><div class="line">  Edition   = {2nd},</div><div class="line">  Year      = {2009},</div><div class="line">}</div></div><!-- fragment --><h4>Requirements on the templated classes</h4>
<p>The class MatrixType must be derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> because a <a class="el" href="classSmartPointer.html">SmartPointer</a> to MatrixType is held in the class. In particular, this means that the matrix object needs to persist during the lifetime of <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>. The preconditioner is held in a shared_ptr that is copied into the <a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a> member variable of the class, so the variable used for initialization can safely be discarded after calling <a class="el" href="classPreconditionChebyshev.html#ae29ca6897af2daec521d5d4407dca843">initialize()</a>. Both the matrix and the preconditioner need to provide <code><a class="el" href="classPreconditionChebyshev.html#ad256fafca2741e0d37cc82695f0bb240">vmult()</a></code> functions for the matrix-vector product and <code><a class="el" href="classPreconditionChebyshev.html#a2450003ef85f7b879f4165c3308c881d">m()</a></code> functions for accessing the number of rows in the (square) matrix. Furthermore, the matrix must provide <code>el(i,i)</code> methods for accessing the matrix diagonal in case the preconditioner type is <a class="el" href="classDiagonalMatrix.html">DiagonalMatrix</a>. Even though it is highly recommended to pass the inverse diagonal entries inside a separate preconditioner object for implementing the Jacobi method (which is the only possible way to operate this class when computing in parallel with MPI because there is no knowledge about the locally stored range of entries that would be needed from the matrix alone), there is a backward compatibility function that can extract the diagonal in case of a serial computation. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l00991">991</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab1a3cf839ba5fba53fc7d441031a50e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a3cf839ba5fba53fc7d441031a50e4">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::<a class="el" href="classPreconditionChebyshev.html#ab1a3cf839ba5fba53fc7d441031a50e4">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l00997">997</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af92969d2c22a65faa61d40ab4fff94f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92969d2c22a65faa61d40ab4fff94f4">&#9670;&nbsp;</a></span>PreconditionChebyshev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::<a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae29ca6897af2daec521d5d4407dca843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29ca6897af2daec521d5d4407dca843">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize function. Takes the matrix which is used to form the preconditioner, and additional flags if there are any. This function works only if the input matrix has an operator <code>el(i,i)</code> for accessing all the elements in the diagonal. Alternatively, the diagonal can be supplied with the help of the <a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a> field.</p>
<p>This function calculates an estimate of the eigenvalue range of the matrix weighted by its diagonal using a modified CG iteration in case the given number of iterations is positive. </p>

</div>
</div>
<a id="ad256fafca2741e0d37cc82695f0bb240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad256fafca2741e0d37cc82695f0bb240">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the action of the preconditioner on <code>src</code>, storing the result in <code>dst</code>. </p>

</div>
</div>
<a id="a11bfb1160c35429d7ed3bb3ccca1c281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bfb1160c35429d7ed3bb3ccca1c281">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the action of the transposed preconditioner on <code>src</code>, storing the result in <code>dst</code>. </p>

</div>
</div>
<a id="a45209d9d4c47f6ed1675bd7c6563cfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45209d9d4c47f6ed1675bd7c6563cfb3">&#9670;&nbsp;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform one step of the preconditioned Richardson iteration. </p>

</div>
</div>
<a id="a6bb2f2b8e8637bbed91b327af0490fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb2f2b8e8637bbed91b327af0490fe6">&#9670;&nbsp;</a></span>Tstep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::Tstep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform one transposed step of the preconditioned Richardson iteration. </p>

</div>
</div>
<a id="a794112afe378c506eb955b7b954a0cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794112afe378c506eb955b7b954a0cf2">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the preconditioner. </p>

</div>
</div>
<a id="a2450003ef85f7b879f4165c3308c881d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2450003ef85f7b879f4165c3308c881d">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPreconditionChebyshev.html#ab1a3cf839ba5fba53fc7d441031a50e4">size_type</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the codomain (or range) space. Note that the matrix is of dimension \(m \times n\). </p>

</div>
</div>
<a id="a3d831e00a583321227713af6efd5f850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d831e00a583321227713af6efd5f850">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPreconditionChebyshev.html#ab1a3cf839ba5fba53fc7d441031a50e4">size_type</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the domain space. Note that the matrix is of dimension \(m \times n\). </p>

</div>
</div>
<a id="a68cf24ff83d957daca6be28ffd47f7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cf24ff83d957daca6be28ffd47f7b3">&#9670;&nbsp;</a></span>estimate_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPreconditionChebyshev_1_1EigenvalueInformation.html">EigenvalueInformation</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::estimate_eigenvalues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute eigenvalue estimates required for the preconditioner.</p>
<p>This function is called automatically on first use of the preconditioner if it is not called by the user. The layout of the vector <code>src</code> is used to create internal temporary vectors and its content does not matter.</p>
<p>Initializes the factors theta and delta based on an eigenvalue computation. If the user set provided values for the largest eigenvalue in <a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a>, no computation is performed and the information given by the user is used. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7c774145ba7c91f96a3937cd7cbed196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c774145ba7c91f96a3937cd7cbed196">&#9670;&nbsp;</a></span>matrix_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const MatrixType, <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt;MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType&gt; &gt; <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::matrix_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the underlying matrix. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l01202">1202</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<a id="a47a332bf35ca46f19c46b7db33bd9e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a332bf35ca46f19c46b7db33bd9e4a">&#9670;&nbsp;</a></span>solution_old</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorType.html">VectorType</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::solution_old</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal vector used for the <code>vmult</code> operation. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l01207">1207</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<a id="ad5340a84d3dcb8fbb8fc03e0e7df3cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5340a84d3dcb8fbb8fc03e0e7df3cc4">&#9670;&nbsp;</a></span>temp_vector1</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorType.html">VectorType</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::temp_vector1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal vector used for the <code>vmult</code> operation. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l01212">1212</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<a id="aca88a1ace994929ee001cde4cb550cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca88a1ace994929ee001cde4cb550cad">&#9670;&nbsp;</a></span>temp_vector2</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorType.html">VectorType</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::temp_vector2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal vector used for the <code>vmult</code> operation. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l01217">1217</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<a id="a466d8de8df88e537b97eb4a2a079e446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466d8de8df88e537b97eb4a2a079e446">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPreconditionChebyshev_1_1AdditionalData.html">AdditionalData</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the additional data passed to the initialize function, obtained through a copy operation. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l01223">1223</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<a id="adfd006b5b18e5cdcbd6f84beb69b42d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd006b5b18e5cdcbd6f84beb69b42d4">&#9670;&nbsp;</a></span>theta</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::theta</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Average of the largest and smallest eigenvalue under consideration. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l01228">1228</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<a id="a8943e4eeaf4252685366b9bfc95aa7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8943e4eeaf4252685366b9bfc95aa7e5">&#9670;&nbsp;</a></span>delta</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::delta</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Half the interval length between the largest and smallest eigenvalue under consideration. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l01234">1234</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<a id="ae66930051ab57c14a099d41f3b3de7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66930051ab57c14a099d41f3b3de7cf">&#9670;&nbsp;</a></span>eigenvalues_are_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::eigenvalues_are_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores whether the preconditioner has been set up and eigenvalues have been computed. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l01240">1240</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<a id="a2a0519735257cd1f3e7960739a9632d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0519735257cd1f3e7960739a9632d1">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType = SparseMatrix&lt;double&gt;, typename VectorType = Vector&lt;double&gt;, typename PreconditionerType = DiagonalMatrix&lt;VectorType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a> <a class="el" href="classPreconditionChebyshev.html">PreconditionChebyshev</a>&lt; MatrixType, <a class="el" href="classVectorType.html">VectorType</a>, PreconditionerType &gt;::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A mutex to avoid that multiple <a class="el" href="classPreconditionChebyshev.html#ad256fafca2741e0d37cc82695f0bb240">vmult()</a> invocations by different threads overwrite the temporary vectors. </p>

<p class="definition">Definition at line <a class="el" href="precondition_8h_source.html#l01246">1246</a> of file <a class="el" href="precondition_8h_source.html">precondition.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="precondition_8h_source.html">precondition.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
