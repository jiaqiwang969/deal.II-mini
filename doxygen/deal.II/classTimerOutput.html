<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTimerOutput.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TimerOutput Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classTimerOutput-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TimerOutput Class Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="timer_8h_source.html">deal.II/base/timer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput_1_1Scope.html">Scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTimerOutput_1_1Section.html">Section</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a643d0e642b80048e91b37109fe9357cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> { <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba0fa935a7c27dab7d6fce45ef1aefd7ea">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbab482c828c039e3342e52b15b90348f4a">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbaed9deac359496981f6275d6d6962e652">never</a>
 }</td></tr>
<tr class="separator:a643d0e642b80048e91b37109fe9357cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3bc552db540d876d14e3c7870fe1f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a> { <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae6399309e843c64b3013b4e22b448e03">total_cpu_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8aa6c17196da93858665c494d442f25a9e">total_wall_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a9657d148a649ea42b0e0e6c9ed2725e0">n_calls</a>
 }</td></tr>
<tr class="separator:aba3bc552db540d876d14e3c7870fe1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2405ae1b041a57d11a61a8cbfad3b487"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> { <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a7163cb728ee352fb0fc3448ba5a5b639">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487abe473bac5884f55978316597255bd3cc">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a23c1c36fef160ee05784b5667f1c2d52">cpu_and_wall_times_grouped</a>
 }</td></tr>
<tr class="separator:a2405ae1b041a57d11a61a8cbfad3b487"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae84f96493f79aa033eb828aac8ede66a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae84f96493f79aa033eb828aac8ede66a">TimerOutput</a> (std::ostream &amp;stream, const <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, const <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:ae84f96493f79aa033eb828aac8ede66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fbaf7e9d78f28c617553a21e3316f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#af8fbaf7e9d78f28c617553a21e3316f4">TimerOutput</a> (<a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;stream, const <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, const <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:af8fbaf7e9d78f28c617553a21e3316f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebd8141aa504f7dd4feb5dbb98e44b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a7aebd8141aa504f7dd4feb5dbb98e44b">TimerOutput</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, std::ostream &amp;stream, const <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, const <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:a7aebd8141aa504f7dd4feb5dbb98e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8f65a32e49e6b10fcc9d286264766"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a46c8f65a32e49e6b10fcc9d286264766">TimerOutput</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;stream, const <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, const <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:a46c8f65a32e49e6b10fcc9d286264766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf19f2a55900e34d6f588dbaf8cfbcc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#acf19f2a55900e34d6f588dbaf8cfbcc7">~TimerOutput</a> ()</td></tr>
<tr class="separator:acf19f2a55900e34d6f588dbaf8cfbcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae730ff220ae414208dc85e76920c3e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a> (const std::string &amp;section_name)</td></tr>
<tr class="separator:ae730ff220ae414208dc85e76920c3e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d27dbc569819f3bbcb5e066e47212ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a> (const std::string &amp;section_name=&quot;&quot;)</td></tr>
<tr class="separator:a4d27dbc569819f3bbcb5e066e47212ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37aba48e5fabc984b5d1b169b58991d"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ac37aba48e5fabc984b5d1b169b58991d">get_summary_data</a> (const <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a> kind) const</td></tr>
<tr class="separator:ac37aba48e5fabc984b5d1b169b58991d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e7d844826bc8716898fb2f86fb9b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a> () const</td></tr>
<tr class="separator:a133e7d844826bc8716898fb2f86fb9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7673798226de7731e3ecdf7c0fb7568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae7673798226de7731e3ecdf7c0fb7568">print_wall_time_statistics</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, const <a class="el" href="classdouble.html">double</a> print_quantile=0.) const</td></tr>
<tr class="separator:ae7673798226de7731e3ecdf7c0fb7568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478c3fbca1d76c07eff9e7af8886dbb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output</a> ()</td></tr>
<tr class="separator:a478c3fbca1d76c07eff9e7af8886dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf249feeb107af9e7f1a93c554cca84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4bf249feeb107af9e7f1a93c554cca84">enable_output</a> ()</td></tr>
<tr class="separator:a4bf249feeb107af9e7f1a93c554cca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017cdef3c18d6050d401dab4f2f64d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a> ()</td></tr>
<tr class="separator:a017cdef3c18d6050d401dab4f2f64d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3d19ce250ef329e652b64173e807dbdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a></td></tr>
<tr class="separator:a3d19ce250ef329e652b64173e807dbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7b62289e3037cb92f8871f68248d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a></td></tr>
<tr class="separator:a4e7b62289e3037cb92f8871f68248d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a982f0c74f0919f61383b17cfc9bcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTimer.html">Timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae3a982f0c74f0919f61383b17cfc9bcf">timer_all</a></td></tr>
<tr class="separator:ae3a982f0c74f0919f61383b17cfc9bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486310cf9dad2c283e1bfb33a72dfc52"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="structTimerOutput_1_1Section.html">Section</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a486310cf9dad2c283e1bfb33a72dfc52">sections</a></td></tr>
<tr class="separator:a486310cf9dad2c283e1bfb33a72dfc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842bcbbb552ca5b4ee76b00936805724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a842bcbbb552ca5b4ee76b00936805724">out_stream</a></td></tr>
<tr class="separator:a842bcbbb552ca5b4ee76b00936805724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ffc02f056b4fbc49d288a665fc6db7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ac3ffc02f056b4fbc49d288a665fc6db7">output_is_enabled</a></td></tr>
<tr class="separator:ac3ffc02f056b4fbc49d288a665fc6db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8b9e00ce8513f00b5ebb5129322e65"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a6b8b9e00ce8513f00b5ebb5129322e65">active_sections</a></td></tr>
<tr class="separator:a6b8b9e00ce8513f00b5ebb5129322e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9b67a6573bfbe4a820a019d7c824e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a0e9b67a6573bfbe4a820a019d7c824e4">mpi_communicator</a></td></tr>
<tr class="separator:a0e9b67a6573bfbe4a820a019d7c824e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75493dc71630440ebc8e1b2ec1fb358c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a75493dc71630440ebc8e1b2ec1fb358c">mutex</a></td></tr>
<tr class="separator:a75493dc71630440ebc8e1b2ec1fb358c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>该类可用于从程序中不同子段的时间测量中生成格式化的输出。它可以创建几个部分来执行程序的某些方面。一个部分可以被多次输入。通过改变OutputFrequency和OutputType中的选项，用户可以选择是在每次加入一个部分时产生输出，还是只在程序结束时产生。此外，还可以显示CPU时间、墙壁时间或两者。 该类被用于大量的收集定时数据的教程程序中。 <a class="el" href="step_77.html">step-77</a> 是一个使用它的相对简单的顺序程序的例子。 <a class="el" href="step_40.html">step-40</a> 和下面提到的其他几个程序将其用于并行计算。</p>
<h3>Usage</h3>
<p>这个类的使用可以是如下的。</p>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line"></div><div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Setup dof system&quot;</span>);</div><div class="line">setup_dofs();</div><div class="line">timer.leave_subsection();</div><div class="line"></div><div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line">assemble_system_1();</div><div class="line">timer.leave_subsection();</div><div class="line"></div><div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">solve_system_1();</div><div class="line">timer.leave_subsection();</div><div class="line"></div><div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line">assemble_system_2();</div><div class="line">timer.leave_subsection();</div><div class="line"></div><div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">solve_system_2();</div><div class="line">timer.leave_subsection();</div><div class="line"></div><div class="line"><span class="comment">// do something else...</span></div></div><!-- fragment --><p> 当运行时，这个程序将返回这样的输出。</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      88.8s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |         2 |      19.7s |        22% |</div><div class="line">| Solve                           |         2 |      3.03s |       3.4% |</div><div class="line">| Setup dof system                |         1 |      3.97s |       4.5% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p> 输出会看到我们进入了装配和解决部分两次，并报告我们在那里花费了多少时间。此外，这个类还测量了TimerOutput对象从开始到终止所花费的总时间。在这种情况下，我们做了很多其他的事情，所以我们测量的函数的时间比例离100很远。</p>
<h3>Using scoped timers</h3>
<p>上面的方案，你必须有对 <a class="el" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">TimerOutput::enter_subsection()</a> 和 <a class="el" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">TimerOutput::leave_subsection()</a> 的调用，如果这些调用之间的部分包含 <code>return</code> 语句或可能抛出异常，那就很尴尬了。在这种情况下，很容易忘记我们还是需要以某种方式在某个地方离开这个部分。一个更简单的方法是使用 "范围
"节。这是一个变量，当你创建它的时候，它就进入了一个部分，当你销毁它的时候，它就离开了这个部分。如果这是一个特定范围（大括号之间的代码块）的局部变量，而你由于 <code>return</code> 语句或异常而离开了这个范围，那么这个变量就会被销毁，定时段也会自动离开。因此，我们可以把上面的代码块写成下面的样子，结果完全一样，但现在是异常安全的。</p>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Setup dof system&quot;</span>);</div><div class="line">  setup_dofs();</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line">  assemble_system_1();</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">  solve_system_1();</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div><div class="line">  assemble_system_2();</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div><div class="line">  solve_system_2();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// do something else...</span></div></div><!-- fragment --><h3>Usage in parallel programs using MPI</h3>
<p>在一个建立在MPI上的并行程序中，以如上所示的方式使用该类会导致这样一种情况：每个进程对相应的部分进行计时，然后在最后输出结果的计时信息。这是很烦人的，因为你会得到大量的输出</p>
<ul>
<li>每个处理器的一组时序信息。 这可以通过只让一个处理器产生屏幕输出来避免，典型的做法是使用ConditionalOStream类型的对象而不是 <code>std::cout</code> 来写入屏幕（例如，见 <a class="el" href="step_17.html">step-17</a> 、 <a class="el" href="step_18.html">step-18</a> 、 <a class="el" href="step_32.html">step-32</a> 和 <a class="el" href="step_40.html">step-40</a> ，它们都使用这种方法）。 这样，只有一个处理器输出计时信息，通常是MPI宇宙中的第一个进程。然而，如果你以上面的代码片段为例，想象一下，如果 <code>setup_dofs()</code> 在零号处理器上是快的，而在其他处理器中至少有一个是慢的；并且如果 <code>assemble_system_1()</code> 做的第一件事是需要所有处理器进行通信，会发生什么。在这种情况下，在零号处理器上，名称为 <code>"Setup dof system"</code> 的计时部分将在零号处理器上产生较短的运行时间，而 <code> "Assemble"</code> 部分将花费很长的时间：不是因为 <code>assemble_system_1()</code> 需要特别长的时间，而是因为在我们计时的处理器上（或者说，我们产生输出的处理器）刚好需要等待很长时间，直到其他处理器最终完成 <code>setup_dofs()</code> 并开始参与 <code>assemble_system_1()</code> 。换句话说，所报告的时间是不可靠的，因为它反映了来自其他处理器的运行时间。此外，本节在零号处理器上的运行时间与本节在其他处理器上的运行时间无关，而是与<em>the previous section</em>在另一个处理器上的运行时间有关。 避免这种情况的第一个方法是，在我们开始和停止计时部分之前，在并行代码中引入一个障碍。这可以确保所有进程都在同一个地方，然后计时信息反映了所有处理器的最大运行时间。为了实现这一点，你需要用一个MPI通信器对象来初始化TimerOutput对象，例如像下面的代码。</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (MPI_COMM_WORLD,</div><div class="line">                   pcout,</div><div class="line">                   <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>,</div><div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div></div><!-- fragment --><p> 这里， <code>pcout</code> 是一个ConditionalOStream类型的对象，确保我们只在单个处理器上产生输出。参见 <a class="el" href="step_32.html">step-32</a> 、 <a class="el" href="step_40.html">step-40</a> 和 <a class="el" href="step_42.html">step-42</a> 的教程程序，了解该类的这种用法。 应对这个问题的第二个变种是打印更多关于记录时间的信息，以便能够理解这种不平衡，而不需要实际添加障碍。虽然这种方法仍然受到不同MPI进程之间不平衡的影响，但是它的输出不是等级0的任意时间，而是MPI结果的最小、平均和最大，使用来自 <a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">Utilities::MPI::MinMaxAvg</a>. 的信息，因为数据也配备了达到最小和最大的等级ID，这种方法允许识别某些减速发生在哪个等级。如果可以容忍MPI等级之间从一个部分到下一个部分的一些不平衡，那么这个策略就比障碍变量更有优势，因为它不会在没有必要的地方同步程序，而是试图显示在各个阶段观察到的不平衡。为了使用这个变体，在没有任何本地打印设置和没有通信器的情况下初始化输出对象。</p>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (pcout,</div><div class="line">                   <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbaed9deac359496981f6275d6d6962e652">TimerOutput::never</a>,</div><div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>);</div></div><!-- fragment --><p> 然后调用</p>
<div class="fragment"><div class="line">timer.print_wall_time_statistics(MPI_COMM_WORLD);</div></div><!-- fragment --><p> 在适当的地方。这里，输出被写入传递给构造函数的 <code>pcout</code> 类型的ConditionalOStream对象中，确保信息只被打印一次。参见 <a class="el" href="step_67.html">step-67</a> 中关于这个变体的使用实例。除了所有MPI等级的基本最小、平均和最大时间外， <a class="el" href="classTimerOutput.html#ae7673798226de7731e3ecdf7c0fb7568">TimerOutput::print_wall_time_statistics()</a> 函数还需要第二个参数来指定定量的输出，例如，最慢和最快等级的10/所花的时间，以获得对统计分布的额外洞察力。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00512">512</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a643d0e642b80048e91b37109fe9357cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643d0e642b80048e91b37109fe9357cb">&#9670;&nbsp;</a></span>OutputFrequency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">TimerOutput::OutputFrequency</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个枚举数据类型，它描述了是否在我们每次退出一个部分时产生输出，只是在最后，两者都是，或者永远不产生。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba0fa935a7c27dab7d6fce45ef1aefd7ea"></a>every_call&#160;</td><td class="fielddoc"><p>每次调用后生成输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726"></a>summary&#160;</td><td class="fielddoc"><p>在结尾处生成摘要输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbab482c828c039e3342e52b15b90348f4a"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>在每次调用后和最后的总结中都生成输出。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbaed9deac359496981f6275d6d6962e652"></a>never&#160;</td><td class="fielddoc"><p>不产生任何输出。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00565">565</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="aba3bc552db540d876d14e3c7870fe1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3bc552db540d876d14e3c7870fe1f8">&#9670;&nbsp;</a></span>OutputData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">TimerOutput::OutputData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个枚举数据类型，描述从定时器获取数据时要返回的数据类型。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae6399309e843c64b3013b4e22b448e03"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>输出CPU时间。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8aa6c17196da93858665c494d442f25a9e"></a>total_wall_time&#160;</td><td class="fielddoc"><p>输出挂钟时间。 </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a9657d148a649ea42b0e0e6c9ed2725e0"></a>n_calls&#160;</td><td class="fielddoc"><p>输出调用次数。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00593">593</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a2405ae1b041a57d11a61a8cbfad3b487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2405ae1b041a57d11a61a8cbfad3b487">&#9670;&nbsp;</a></span>OutputType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">TimerOutput::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个枚举数据类型，描述了每当我们生成输出时，是否显示CPU时间、壁挂时间，或者同时显示CPU和壁挂时间。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a7163cb728ee352fb0fc3448ba5a5b639"></a>cpu_times&#160;</td><td class="fielddoc"><p>输出CPU时间。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2"></a>wall_times&#160;</td><td class="fielddoc"><p>输出挂钟时间。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487abe473bac5884f55978316597255bd3cc"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>在不同的表格中同时输出CPU和挂钟时间。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a23c1c36fef160ee05784b5667f1c2d52"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>在一个表中输出CPU和墙面时钟时间。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00616">616</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae84f96493f79aa033eb828aac8ede66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84f96493f79aa033eb828aac8ede66a">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>流（类型为 std::ostream) ，输出被写入其中。 </td></tr>
    <tr><td class="paramname">output_frequency</td><td>一个变量，表示何时将输出写入给定的流。 </td></tr>
    <tr><td class="paramname">output_type</td><td>一个变量，表示输出应该代表哪种时间（CPU或墙面时间）。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00301">301</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="af8fbaf7e9d78f28c617553a21e3316f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fbaf7e9d78f28c617553a21e3316f4">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>输出被写入的流（ConditionalOstream类型）。 </td></tr>
    <tr><td class="paramname">output_frequency</td><td>表示何时将输出写入给定流的一个变量。 </td></tr>
    <tr><td class="paramname">output_type</td><td>一个变量，表示输出应该代表哪种时间（CPU或墙面时间）。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00313">313</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a7aebd8141aa504f7dd4feb5dbb98e44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebd8141aa504f7dd4feb5dbb98e44b">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数，将MPI通信器作为输入。这样构造的定时器将把MPI网络中所有处理器的CPU时间加起来计算CPU时间，或者取所有处理器的最大值，取决于 <code>output_type</code> 的值。关于这个构造函数的原理和一个例子，请参见该类的文档。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>一个MPI通信器，我们应该在其上积累或以其他方式同步我们在每个MPI进程上产生的计时信息。 </td></tr>
    <tr><td class="paramname">stream</td><td>流（类型为 std::ostream) ，输出被写入其中。 </td></tr>
    <tr><td class="paramname">output_frequency</td><td>表示何时将输出写入给定流的变量。 </td></tr>
    <tr><td class="paramname">output_type</td><td>一个变量，表示输出应该代表哪种时间（CPU或墙面时间）。在这个并行的上下文中，当这个参数选择CPU时间时，那么时间会在参与MPI通信器的所有进程中累积。如果这个参数选择了墙时间，那么报告的时间就是这部分所有处理器运行时间的最大值。后者是通过在启动和停止每个部分的定时器之前放置一个 <code>MPI_Barrier</code> 调用来计算的。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00325">325</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a46c8f65a32e49e6b10fcc9d286264766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c8f65a32e49e6b10fcc9d286264766">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数需要一个MPI通信器作为输入。这样构造的定时器将把MPI网络中所有处理器的CPU时间加起来计算CPU时间，或者取所有处理器的最大值，这取决于 <code>output_type</code> 的值。关于这个构造函数的原理和一个例子，请参见该类的文档。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>一个MPI通信器，我们应该在其上积累或以其他方式同步我们在每个MPI进程上产生的时间信息。 </td></tr>
    <tr><td class="paramname">stream</td><td>输出被写入的流（ConditionalOstream类型）。 </td></tr>
    <tr><td class="paramname">output_frequency</td><td>表示何时将输出写入给定流的一个变量。 </td></tr>
    <tr><td class="paramname">output_type</td><td>一个变量，表示输出应该代表哪种时间（CPU或墙面时间）。在这个并行的上下文中，当这个参数选择CPU时间时，那么时间会在参与MPI通信器的所有进程中累积。如果这个参数选择了墙时间，那么报告的时间就是这部分所有处理器运行时间的最大值。后者是通过在启动和停止每个部分的定时器之前放置一个 <code>MPI_Barrier</code> 调用来计算的）。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00338">338</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="acf19f2a55900e34d6f588dbaf8cfbcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf19f2a55900e34d6f588dbaf8cfbcc7">&#9670;&nbsp;</a></span>~TimerOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::~TimerOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>销毁器。如果写摘要输出的选项被设置，则调用print_summary()。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00351">351</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae730ff220ae414208dc85e76920c3e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae730ff220ae414208dc85e76920c3e45">&#9670;&nbsp;</a></span>enter_subsection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::enter_subsection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>section_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过给定一个字符串的名称来打开一个部分。如果该名称已经存在，则再次进入该部分并累积次数。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00403">403</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a4d27dbc569819f3bbcb5e066e47212ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d27dbc569819f3bbcb5e066e47212ea">&#9670;&nbsp;</a></span>leave_subsection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::leave_subsection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>section_name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>离开一个部分。如果没有给定名称，则留下最后输入的部分。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00445">445</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="ac37aba48e5fabc984b5d1b169b58991d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37aba48e5fabc984b5d1b169b58991d">&#9670;&nbsp;</a></span>get_summary_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::string, <a class="el" href="classdouble.html">double</a> &gt; TimerOutput::get_summary_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获得一张地图，上面有每个小节的指定类型的收集的数据。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00509">509</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a133e7d844826bc8716898fb2f86fb9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e7d844826bc8716898fb2f86fb9b6">&#9670;&nbsp;</a></span>print_summary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::print_summary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印一个格式化的表格，总结各部分所消耗的时间。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00535">535</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="ae7673798226de7731e3ecdf7c0fb7568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7673798226de7731e3ecdf7c0fb7568">&#9670;&nbsp;</a></span>print_wall_time_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::print_wall_time_statistics </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>print_quantile</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印一个格式化的表格，总结各部分所消耗的墙体时间，使用各部分时间的最小值、平均值和最大值以及达到最小值和最大值的MPI等级的统计数据。注意这个调用只有在构造TimerOutput对象时没有MPI_Comm参数时才能提供有用的信息，以使各个部分的运行不受障碍物的干扰。 可选的参数<code>quantile</code>允许在运行时间的分布方面为输出增加两列。如果quantile=0.1，除了最小值和最大值外，还打印10的最低数据的值和等级，以及分布函数的90的值和等级。quantile "的值需要在0（除了最小和最大之外不打印任何量值）和0.5（当给出中位数时）之间。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00844">844</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a478c3fbca1d76c07eff9e7af8886dbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478c3fbca1d76c07eff9e7af8886dbb5">&#9670;&nbsp;</a></span>disable_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::disable_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过调用这个函数，所有的输出都可以被禁用。如果想以灵活的方式控制输出，而又不想在程序中加入大量的<code>if</code>条款，这个函数和enable_output()就很有用。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l01023">1023</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a4bf249feeb107af9e7f1a93c554cca84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf249feeb107af9e7f1a93c554cca84">&#9670;&nbsp;</a></span>enable_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::enable_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果之前用disable_output()禁用了该类的输出，该函数重新启用。如果想以灵活的方式控制输出，而不在程序中加入大量的<code>if</code>子句，这个函数与disable_output()一起使用是很有用的。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l01031">1031</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a017cdef3c18d6050d401dab4f2f64d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017cdef3c18d6050d401dab4f2f64d2e">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>重置记录的定时信息。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l01037">1037</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3d19ce250ef329e652b64173e807dbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d19ce250ef329e652b64173e807dbdd">&#9670;&nbsp;</a></span>output_frequency</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> TimerOutput::output_frequency</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>什么时候向输出流输出信息。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00771">771</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a4e7b62289e3037cb92f8871f68248d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7b62289e3037cb92f8871f68248d7e">&#9670;&nbsp;</a></span>output_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> TimerOutput::output_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>是否显示CPU时间、壁挂时间，或同时显示CPU和壁挂时间。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00777">777</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="ae3a982f0c74f0919f61383b17cfc9bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a982f0c74f0919f61383b17cfc9bcf">&#9670;&nbsp;</a></span>timer_all</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTimer.html">Timer</a> TimerOutput::timer_all</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个用于整体运行时间的计时器对象。如果我们使用的是MPI，这个计时器也会在所有MPI进程中累积。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00784">784</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a486310cf9dad2c283e1bfb33a72dfc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486310cf9dad2c283e1bfb33a72dfc52">&#9670;&nbsp;</a></span>sections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="structTimerOutput_1_1Section.html">Section</a>&gt; TimerOutput::sections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个所有章节及其信息的列表。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00802">802</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a842bcbbb552ca5b4ee76b00936805724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842bcbbb552ca5b4ee76b00936805724">&#9670;&nbsp;</a></span>out_stream</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> TimerOutput::out_stream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>我们要输出的流对象。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00808">808</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="ac3ffc02f056b4fbc49d288a665fc6db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ffc02f056b4fbc49d288a665fc6db7">&#9670;&nbsp;</a></span>output_is_enabled</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TimerOutput::output_is_enabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个布尔变量，用于设置该类的输出目前是开还是关。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00814">814</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a6b8b9e00ce8513f00b5ebb5129322e65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8b9e00ce8513f00b5ebb5129322e65">&#9670;&nbsp;</a></span>active_sections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;std::string&gt; TimerOutput::active_sections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个已经进入而没有退出的部分的列表。该列表按照进入章节的顺序保存，但是如果给leave_subsection()函数一个参数，元素可以在中间被移除。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00820">820</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a0e9b67a6573bfbe4a820a019d7c824e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9b67a6573bfbe4a820a019d7c824e4">&#9670;&nbsp;</a></span>mpi_communicator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> TimerOutput::mpi_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>mpi通信器 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00826">826</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a75493dc71630440ebc8e1b2ec1fb358c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75493dc71630440ebc8e1b2ec1fb358c">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a> TimerOutput::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个锁，确保这个类在与多个线程一起使用时也能给出合理的结果。 </p>

<p class="definition">Definition at line <a class="el" href="timer_8h_source.html#l00832">832</a> of file <a class="el" href="timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="timer_8h_source.html">timer.h</a></li>
<li>source/base/<a class="el" href="timer_8cc_source.html">timer.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
