<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFEEvaluation.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FEEvaluation&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classFEEvaluation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEEvaluation&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__matrixfree.html">Matrix-free infrastructure</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fe__evaluation_8h_source.html">deal.II/matrix_free/fe_evaluation.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FEEvaluation&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFEEvaluation__inherit__graph.svg" width="1442" height="119"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a752a2fd5b5d7b1ccb2058c1bdfef7674"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a752a2fd5b5d7b1ccb2058c1bdfef7674">BaseClass</a> = <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a>&lt; dim, n_components_, Number, false, VectorizedArrayType &gt;</td></tr>
<tr class="separator:a752a2fd5b5d7b1ccb2058c1bdfef7674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f2076e454c90af29ae60d2b8294256"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#aa6f2076e454c90af29ae60d2b8294256">number_type</a> = Number</td></tr>
<tr class="separator:aa6f2076e454c90af29ae60d2b8294256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3983bd07d5058c7af23dc9ca5daeca4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ad3983bd07d5058c7af23dc9ca5daeca4">value_type</a> = typename <a class="el" href="classFEEvaluationAccess.html#a341c39cbf9948d06561b74f9c5050d10">BaseClass::value_type</a></td></tr>
<tr class="separator:ad3983bd07d5058c7af23dc9ca5daeca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a40f0bccb9db6ed543f7800a824f930"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a8a40f0bccb9db6ed543f7800a824f930">gradient_type</a> = typename <a class="el" href="classFEEvaluationAccess.html#a6167b54604de2e9022ec743267e5a25b">BaseClass::gradient_type</a></td></tr>
<tr class="separator:a8a40f0bccb9db6ed543f7800a824f930"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade40e452949cbefd4f7e6d5580af81c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ade40e452949cbefd4f7e6d5580af81c8">FEEvaluation</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;matrix_free, const unsigned <a class="el" href="classint.html">int</a> dof_no=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html#a533b073ea515b343f9d785da2f342066">quad_no</a>=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a>=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html#afa5f9995bfa3e160a8e111837e4293c9">active_fe_index</a>=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html#a15d55c8a88a0a393b7eec7a2843cc9bd">active_quad_index</a>=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:ade40e452949cbefd4f7e6d5580af81c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06293ee7aac4f62c80be6862aa1ae101"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a06293ee7aac4f62c80be6862aa1ae101">FEEvaluation</a> (const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;matrix_free, const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;range, const unsigned <a class="el" href="classint.html">int</a> dof_no=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html#a533b073ea515b343f9d785da2f342066">quad_no</a>=0, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a>=0)</td></tr>
<tr class="separator:a06293ee7aac4f62c80be6862aa1ae101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0dc3f17c28f2db5fd4237b1bf04342"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a1b0dc3f17c28f2db5fd4237b1bf04342">FEEvaluation</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; 1 &gt; &amp;quadrature, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a>=0)</td></tr>
<tr class="separator:a1b0dc3f17c28f2db5fd4237b1bf04342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43079434f0a4acc8907e7a6b2d9b541f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a43079434f0a4acc8907e7a6b2d9b541f">FEEvaluation</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; 1 &gt; &amp;quadrature, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a>=0)</td></tr>
<tr class="separator:a43079434f0a4acc8907e7a6b2d9b541f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a553f3be01a24f863b118a932ef45ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a6a553f3be01a24f863b118a932ef45ee">FEEvaluation</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim &gt; &amp;fe, const <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, false, VectorizedArrayType &gt; &amp;other, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a>=0)</td></tr>
<tr class="separator:a6a553f3be01a24f863b118a932ef45ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94191b8afd866e461d5ea241d59548d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ae94191b8afd866e461d5ea241d59548d">FEEvaluation</a> (const <a class="el" href="classFEEvaluation.html">FEEvaluation</a> &amp;other)</td></tr>
<tr class="separator:ae94191b8afd866e461d5ea241d59548d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fade83f4620d35adcf36ebfc8831431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluation.html">FEEvaluation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a4fade83f4620d35adcf36ebfc8831431">operator=</a> (const <a class="el" href="classFEEvaluation.html">FEEvaluation</a> &amp;other)</td></tr>
<tr class="separator:a4fade83f4620d35adcf36ebfc8831431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e77cd8900f05a73a91ca8edf31f4a91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a5e77cd8900f05a73a91ca8edf31f4a91">reinit</a> (const unsigned <a class="el" href="classint.html">int</a> cell_batch_index)</td></tr>
<tr class="separator:a5e77cd8900f05a73a91ca8edf31f4a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72201adca068e3c1208fdbe1ef32e919"><td class="memTemplParams" colspan="2">template&lt;bool level_dof_access&gt; </td></tr>
<tr class="memitem:a72201adca068e3c1208fdbe1ef32e919"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a72201adca068e3c1208fdbe1ef32e919">reinit</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dim, dim, level_dof_access &gt;&gt; &amp;<a class="el" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a>)</td></tr>
<tr class="separator:a72201adca068e3c1208fdbe1ef32e919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b9569def4f5d94f16112bf92c87cbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a45b9569def4f5d94f16112bf92c87cbb">reinit</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt;::cell_iterator &amp;<a class="el" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a>)</td></tr>
<tr class="separator:a45b9569def4f5d94f16112bf92c87cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c252e9dccc0c4ce07044cac3bdd9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">evaluate</a> (const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag)</td></tr>
<tr class="separator:a710c252e9dccc0c4ce07044cac3bdd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706df1ddc8e95119188be47a04e5625e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a706df1ddc8e95119188be47a04e5625e">evaluate</a> (const <a class="el" href="classbool.html">bool</a> evaluate_values, const <a class="el" href="classbool.html">bool</a> evaluate_gradients, const <a class="el" href="classbool.html">bool</a> evaluate_hessians=false)</td></tr>
<tr class="separator:a706df1ddc8e95119188be47a04e5625e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816110747e83fe4b90bcc4abceea105c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a816110747e83fe4b90bcc4abceea105c">evaluate</a> (const VectorizedArrayType *values_array, const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag)</td></tr>
<tr class="separator:a816110747e83fe4b90bcc4abceea105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f4f4d2a83827a64581756852d9bef9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ad8f4f4d2a83827a64581756852d9bef9">evaluate</a> (const VectorizedArrayType *values_array, const <a class="el" href="classbool.html">bool</a> evaluate_values, const <a class="el" href="classbool.html">bool</a> evaluate_gradients, const <a class="el" href="classbool.html">bool</a> evaluate_hessians=false)</td></tr>
<tr class="separator:ad8f4f4d2a83827a64581756852d9bef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53d5c08f460cfe6c9830ac14a427115"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ab53d5c08f460cfe6c9830ac14a427115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ab53d5c08f460cfe6c9830ac14a427115">gather_evaluate</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;input_vector, const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag)</td></tr>
<tr class="separator:ab53d5c08f460cfe6c9830ac14a427115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3f8ff45455cd59c35c91168d9954c5"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:acc3f8ff45455cd59c35c91168d9954c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#acc3f8ff45455cd59c35c91168d9954c5">gather_evaluate</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;input_vector, const <a class="el" href="classbool.html">bool</a> evaluate_values, const <a class="el" href="classbool.html">bool</a> evaluate_gradients, const <a class="el" href="classbool.html">bool</a> evaluate_hessians=false)</td></tr>
<tr class="separator:acc3f8ff45455cd59c35c91168d9954c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61cbe0d7d6138be040d46ae06a268f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">integrate</a> (const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> integration_flag)</td></tr>
<tr class="separator:ad61cbe0d7d6138be040d46ae06a268f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311c0ac5cf4b8cf2458996d7099a139a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a311c0ac5cf4b8cf2458996d7099a139a">integrate</a> (const <a class="el" href="classbool.html">bool</a> integrate_values, const <a class="el" href="classbool.html">bool</a> integrate_gradients)</td></tr>
<tr class="separator:a311c0ac5cf4b8cf2458996d7099a139a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08f232810f7c2ec9890c0d02c405de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#aa08f232810f7c2ec9890c0d02c405de8">integrate</a> (const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> integration_flag, VectorizedArrayType *values_array)</td></tr>
<tr class="separator:aa08f232810f7c2ec9890c0d02c405de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb8ef59ad57e81197460563e0b479c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#aefb8ef59ad57e81197460563e0b479c1">integrate</a> (const <a class="el" href="classbool.html">bool</a> integrate_values, const <a class="el" href="classbool.html">bool</a> integrate_gradients, VectorizedArrayType *values_array)</td></tr>
<tr class="separator:aefb8ef59ad57e81197460563e0b479c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491779be7bd032d277e41f1dda8dc584"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a491779be7bd032d277e41f1dda8dc584"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a491779be7bd032d277e41f1dda8dc584">integrate_scatter</a> (const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a> evaluation_flag, <a class="el" href="classVectorType.html">VectorType</a> &amp;output_vector)</td></tr>
<tr class="separator:a491779be7bd032d277e41f1dda8dc584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cb7b72e780dd02433e10fec759f29d"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a02cb7b72e780dd02433e10fec759f29d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a02cb7b72e780dd02433e10fec759f29d">integrate_scatter</a> (const <a class="el" href="classbool.html">bool</a> integrate_values, const <a class="el" href="classbool.html">bool</a> integrate_gradients, <a class="el" href="classVectorType.html">VectorType</a> &amp;output_vector)</td></tr>
<tr class="separator:a02cb7b72e780dd02433e10fec759f29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac502951246b5155d586bd090cc9e1572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ac502951246b5155d586bd090cc9e1572">quadrature_point</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:ac502951246b5155d586bd090cc9e1572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68204d97bb4207d522522f0d624213dc"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a68204d97bb4207d522522f0d624213dc">get_first_selected_component</a> () const</td></tr>
<tr class="separator:a68204d97bb4207d522522f0d624213dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b715f55152c25bf40e8a588f2d71e3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a41b715f55152c25bf40e8a588f2d71e3">get_mapping_data_index_offset</a> () const</td></tr>
<tr class="separator:a41b715f55152c25bf40e8a588f2d71e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377d660719169078d812bf611bd75f13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__matrixfree.html#gae024b29b6819e727d47016c6b6b53d8c">internal::MatrixFreeFunctions::GeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a377d660719169078d812bf611bd75f13">get_cell_type</a> () const</td></tr>
<tr class="separator:a377d660719169078d812bf611bd75f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3795cfb954ce2b37a130265c51eba552"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; VectorizedArrayType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a3795cfb954ce2b37a130265c51eba552">get_shape_info</a> () const</td></tr>
<tr class="separator:a3795cfb954ce2b37a130265c51eba552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664645e91bbe5f972a1d9b6c64ab5e9b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a664645e91bbe5f972a1d9b6c64ab5e9b">get_dof_info</a> () const</td></tr>
<tr class="separator:a664645e91bbe5f972a1d9b6c64ab5e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ed5a4e84edf92e69f1474d5f035a92"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a56ed5a4e84edf92e69f1474d5f035a92">JxW</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a56ed5a4e84edf92e69f1474d5f035a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad456112f01b19291e7781fb5efee55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#adad456112f01b19291e7781fb5efee55">inverse_jacobian</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:adad456112f01b19291e7781fb5efee55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264ced911d2818b0a04b8855bb482b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a264ced911d2818b0a04b8855bb482b45">get_normal_vector</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a264ced911d2818b0a04b8855bb482b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c966665f040d92b055833c8011b395a"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a7c966665f040d92b055833c8011b395a">read_cell_data</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &amp;array) const</td></tr>
<tr class="separator:a7c966665f040d92b055833c8011b395a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6891d7f5fe2282a3ff1ca56042d57d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6891d7f5fe2282a3ff1ca56042d57d6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, VectorizedArrayType::size()&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#ae6891d7f5fe2282a3ff1ca56042d57d6">read_cell_data</a> (const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; std::array&lt; T, VectorizedArrayType::size()&gt;&gt; &amp;array) const</td></tr>
<tr class="separator:ae6891d7f5fe2282a3ff1ca56042d57d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152c28d13aca3d409052d7f7a0634eb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a152c28d13aca3d409052d7f7a0634eb0">set_cell_data</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &amp;array, const VectorizedArrayType &amp;value) const</td></tr>
<tr class="separator:a152c28d13aca3d409052d7f7a0634eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7feb6cd1b095d992c54dd5fac244586"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7feb6cd1b095d992c54dd5fac244586"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#ac7feb6cd1b095d992c54dd5fac244586">set_cell_data</a> (<a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; std::array&lt; T, VectorizedArrayType::size()&gt;&gt; &amp;array, const std::array&lt; T, VectorizedArrayType::size()&gt; &amp;value) const</td></tr>
<tr class="separator:ac7feb6cd1b095d992c54dd5fac244586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2729f97a9d471169afe63cede6596a74"><td class="memItemLeft" align="right" valign="top">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a2729f97a9d471169afe63cede6596a74">get_cell_ids</a> () const</td></tr>
<tr class="separator:a2729f97a9d471169afe63cede6596a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d73c4fd5e79970f465b603adf116d6"><td class="memItemLeft" align="right" valign="top">std::array&lt; unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a77d73c4fd5e79970f465b603adf116d6">get_cell_or_face_ids</a> () const</td></tr>
<tr class="separator:a77d73c4fd5e79970f465b603adf116d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575a078b24cb2107fce967db6ebedb1f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a575a078b24cb2107fce967db6ebedb1f">get_internal_dof_numbering</a> () const</td></tr>
<tr class="separator:a575a078b24cb2107fce967db6ebedb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68af54c4af89af574d1304bfc59f2637"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArrayView.html">ArrayView</a>&lt; VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a68af54c4af89af574d1304bfc59f2637">get_scratch_data</a> () const</td></tr>
<tr class="separator:a68af54c4af89af574d1304bfc59f2637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a6490549baa849bf4aaaab72ed4ecb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#aa1a6490549baa849bf4aaaab72ed4ecb">get_quadrature_index</a> () const</td></tr>
<tr class="separator:aa1a6490549baa849bf4aaaab72ed4ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6874c90c1c3f54737636cd30b46ffe47"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a6874c90c1c3f54737636cd30b46ffe47">get_current_cell_index</a> () const</td></tr>
<tr class="separator:a6874c90c1c3f54737636cd30b46ffe47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed217341425d1b85c6d2e67932af9853"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#aed217341425d1b85c6d2e67932af9853">get_active_fe_index</a> () const</td></tr>
<tr class="separator:aed217341425d1b85c6d2e67932af9853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f979d70d5d3e16037ed0f3ae36f6b6f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a6f979d70d5d3e16037ed0f3ae36f6b6f">get_active_quadrature_index</a> () const</td></tr>
<tr class="separator:a6f979d70d5d3e16037ed0f3ae36f6b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0c8e96fd4c18b29c6cddb1e648c66d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a8b0c8e96fd4c18b29c6cddb1e648c66d">get_matrix_free</a> () const</td></tr>
<tr class="separator:a8b0c8e96fd4c18b29c6cddb1e648c66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">1：从向量中读取和写入向量</div></td></tr>
<tr class="memitem:a5c3bf28ebceb0271addfba5b92f475ce"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a5c3bf28ebceb0271addfba5b92f475ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">read_dof_values</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, const unsigned <a class="el" href="classint.html">int</a> first_index=0)</td></tr>
<tr class="separator:a5c3bf28ebceb0271addfba5b92f475ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd35a59ccde6eaab46d1264450b93f5"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a5bd35a59ccde6eaab46d1264450b93f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a5bd35a59ccde6eaab46d1264450b93f5">read_dof_values_plain</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;src, const unsigned <a class="el" href="classint.html">int</a> first_index=0)</td></tr>
<tr class="separator:a5bd35a59ccde6eaab46d1264450b93f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c9d8eac4ca7b3f7d45eda97ea8e2fb"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a13c9d8eac4ca7b3f7d45eda97ea8e2fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a13c9d8eac4ca7b3f7d45eda97ea8e2fb">distribute_local_to_global</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const unsigned <a class="el" href="classint.html">int</a> first_index=0, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask=std::bitset&lt; VectorizedArrayType::size()&gt;().flip()) const</td></tr>
<tr class="separator:a13c9d8eac4ca7b3f7d45eda97ea8e2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459813036810fbdc3c5487309b118fd8"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a459813036810fbdc3c5487309b118fd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a459813036810fbdc3c5487309b118fd8">set_dof_values</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const unsigned <a class="el" href="classint.html">int</a> first_index=0, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask=std::bitset&lt; VectorizedArrayType::size()&gt;().flip()) const</td></tr>
<tr class="separator:a459813036810fbdc3c5487309b118fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc923ce61f6399bcd717ab9f99f62ca0"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:afc923ce61f6399bcd717ab9f99f62ca0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#afc923ce61f6399bcd717ab9f99f62ca0">set_dof_values_plain</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const unsigned <a class="el" href="classint.html">int</a> first_index=0, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask=std::bitset&lt; VectorizedArrayType::size()&gt;().flip()) const</td></tr>
<tr class="separator:afc923ce61f6399bcd717ab9f99f62ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2：访问正交点的数据或聚集矢量数据</div></td></tr>
<tr class="memitem:a0660b27a2a592994dfd2fc917305a3ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a0660b27a2a592994dfd2fc917305a3ac">get_dof_value</a> (const unsigned <a class="el" href="classint.html">int</a> dof) const</td></tr>
<tr class="separator:a0660b27a2a592994dfd2fc917305a3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afd9d62f5762c41973aa0f037dc5099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a3afd9d62f5762c41973aa0f037dc5099">submit_dof_value</a> (const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> val_in, const unsigned <a class="el" href="classint.html">int</a> dof)</td></tr>
<tr class="separator:a3afd9d62f5762c41973aa0f037dc5099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecc76ffeff6b36816f6af20af1398a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:aeecc76ffeff6b36816f6af20af1398a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0efc6f70b305c0585001632063c98b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2c0efc6f70b305c0585001632063c98b">submit_value</a> (const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> val_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:a2c0efc6f70b305c0585001632063c98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132c024aa9243845d3777b227607da6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a132c024aa9243845d3777b227607da6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee54d24ac9e0dcfe9a4571a6b047cd03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aee54d24ac9e0dcfe9a4571a6b047cd03">get_normal_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:aee54d24ac9e0dcfe9a4571a6b047cd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a78655d119bd1bde992619c52b2d2f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">submit_gradient</a> (const <a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a> grad_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:a2a78655d119bd1bde992619c52b2d2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e7e621190fb28eeeffa58311f711ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ad6e7e621190fb28eeeffa58311f711ce">submit_normal_derivative</a> (const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> grad_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:ad6e7e621190fb28eeeffa58311f711ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af637d7fcd92a58cf1e8597269a13e9bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, n_components_, <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, VectorizedArrayType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#af637d7fcd92a58cf1e8597269a13e9bd">get_hessian</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:af637d7fcd92a58cf1e8597269a13e9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba7f7af4354a4bad6bcf7364978ebf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aaba7f7af4354a4bad6bcf7364978ebf2">get_hessian_diagonal</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:aaba7f7af4354a4bad6bcf7364978ebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c652a4de885613efc5e02dd3754342b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a0c652a4de885613efc5e02dd3754342b">get_laplacian</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a0c652a4de885613efc5e02dd3754342b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6a0959de5c408072c48ee3fd2ca057"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a7f6a0959de5c408072c48ee3fd2ca057">get_divergence</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a7f6a0959de5c408072c48ee3fd2ca057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6fe306f7501a59940bfffab2550e6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2b6fe306f7501a59940bfffab2550e6a">get_symmetric_gradient</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:a2b6fe306f7501a59940bfffab2550e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae036687570ee408ffa461f9c7ae685cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1,(dim==2 ? 1 :dim), VectorizedArrayType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ae036687570ee408ffa461f9c7ae685cc">get_curl</a> (const unsigned <a class="el" href="classint.html">int</a> q_point) const</td></tr>
<tr class="separator:ae036687570ee408ffa461f9c7ae685cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a45432b87f3a6fc20ca91b02d2654d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aa0a45432b87f3a6fc20ca91b02d2654d">submit_divergence</a> (const VectorizedArrayType div_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:aa0a45432b87f3a6fc20ca91b02d2654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b29b531d2d7bfc8596b34f68b6abf91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a5b29b531d2d7bfc8596b34f68b6abf91">submit_symmetric_gradient</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorizedArrayType &gt; grad_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:a5b29b531d2d7bfc8596b34f68b6abf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af317b2c1e630b328f7738287d3b07ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#af317b2c1e630b328f7738287d3b07ae6">submit_curl</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim==2 ? 1 :dim, VectorizedArrayType &gt; curl_in, const unsigned <a class="el" href="classint.html">int</a> q_point)</td></tr>
<tr class="separator:af317b2c1e630b328f7738287d3b07ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada523fada873497b00071b8b0bc35005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ada523fada873497b00071b8b0bc35005">integrate_value</a> () const</td></tr>
<tr class="separator:ada523fada873497b00071b8b0bc35005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3：对内部数据的访问</div></td></tr>
<tr class="memitem:a6998ba7c39eeed60574b25f366184d0b"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a6998ba7c39eeed60574b25f366184d0b">begin_dof_values</a> () const</td></tr>
<tr class="separator:a6998ba7c39eeed60574b25f366184d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54213aa80599acf803a3b7c4c487fd38"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a54213aa80599acf803a3b7c4c487fd38">begin_dof_values</a> ()</td></tr>
<tr class="separator:a54213aa80599acf803a3b7c4c487fd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0738826a83db1d28cad958e478f3e27"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ac0738826a83db1d28cad958e478f3e27">begin_values</a> () const</td></tr>
<tr class="separator:ac0738826a83db1d28cad958e478f3e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e58470a54179126fe601d26f0088bdb"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a8e58470a54179126fe601d26f0088bdb">begin_values</a> ()</td></tr>
<tr class="separator:a8e58470a54179126fe601d26f0088bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9651d02f2fe8a7133867c92fc8f327b"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ac9651d02f2fe8a7133867c92fc8f327b">begin_gradients</a> () const</td></tr>
<tr class="separator:ac9651d02f2fe8a7133867c92fc8f327b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f03eb49fe21f5a2eda31c07d3052330"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a1f03eb49fe21f5a2eda31c07d3052330">begin_gradients</a> ()</td></tr>
<tr class="separator:a1f03eb49fe21f5a2eda31c07d3052330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bce79fd87c41b7fee59627b4a452125"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a7bce79fd87c41b7fee59627b4a452125">begin_hessians</a> () const</td></tr>
<tr class="separator:a7bce79fd87c41b7fee59627b4a452125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0a3def7f22c396ce2884e37b4aa788"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2b0a3def7f22c396ce2884e37b4aa788">begin_hessians</a> ()</td></tr>
<tr class="separator:a2b0a3def7f22c396ce2884e37b4aa788"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6abe391d376ebaec28b84ea5c3052101"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a6abe391d376ebaec28b84ea5c3052101">fast_evaluation_supported</a> (const unsigned <a class="el" href="classint.html">int</a> given_degree, const unsigned <a class="el" href="classint.html">int</a> give_n_q_points_1d)</td></tr>
<tr class="separator:a6abe391d376ebaec28b84ea5c3052101"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a082b0d1473bdd532be243d3b03073847"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a082b0d1473bdd532be243d3b03073847">dofs_per_component</a></td></tr>
<tr class="separator:a082b0d1473bdd532be243d3b03073847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89db52bf6207863f14325522f8d229a"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ab89db52bf6207863f14325522f8d229a">dofs_per_cell</a></td></tr>
<tr class="separator:ab89db52bf6207863f14325522f8d229a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8934d6ae273d7b3f91994eddcad239"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a1b8934d6ae273d7b3f91994eddcad239">n_q_points</a></td></tr>
<tr class="separator:a1b8934d6ae273d7b3f91994eddcad239"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab1703665b25c71fb904234e06843b14a"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ab1703665b25c71fb904234e06843b14a">dimension</a> = dim</td></tr>
<tr class="separator:ab1703665b25c71fb904234e06843b14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87ecbe1b7e87f0b45b56d7434061c71"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ad87ecbe1b7e87f0b45b56d7434061c71">n_components</a> = n_components_</td></tr>
<tr class="separator:ad87ecbe1b7e87f0b45b56d7434061c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61bbe0f675fe4561ecad32ef352478e"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#ae61bbe0f675fe4561ecad32ef352478e">static_n_q_points</a></td></tr>
<tr class="separator:ae61bbe0f675fe4561ecad32ef352478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd09f7ef0d2176787b3705d3b124a734"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#afd09f7ef0d2176787b3705d3b124a734">static_dofs_per_component</a></td></tr>
<tr class="separator:afd09f7ef0d2176787b3705d3b124a734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7633347d0c75761dc6c785d7efd7f50f"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#a7633347d0c75761dc6c785d7efd7f50f">tensor_dofs_per_cell</a></td></tr>
<tr class="separator:a7633347d0c75761dc6c785d7efd7f50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda989191e3ba8ff33319ea4c165fb3a"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#abda989191e3ba8ff33319ea4c165fb3a">static_dofs_per_cell</a></td></tr>
<tr class="separator:abda989191e3ba8ff33319ea4c165fb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a27779f5e7ac08bcc8c3fd1d78698ad45"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename VectorOperation &gt; </td></tr>
<tr class="memitem:a27779f5e7ac08bcc8c3fd1d78698ad45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a27779f5e7ac08bcc8c3fd1d78698ad45">read_write_operation</a> (const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;operation, const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;vectors, const std::array&lt; const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const typename VectorType::value_type &gt;&gt; *, n_components_ &gt; &amp;vectors_sm, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask, const <a class="el" href="classbool.html">bool</a> apply_constraints=true) const</td></tr>
<tr class="separator:a27779f5e7ac08bcc8c3fd1d78698ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427af54345534f8d734230ad56d4a367"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename VectorOperation &gt; </td></tr>
<tr class="memitem:a427af54345534f8d734230ad56d4a367"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a427af54345534f8d734230ad56d4a367">read_write_operation_contiguous</a> (const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;operation, const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;vectors, const std::array&lt; const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const typename VectorType::value_type &gt;&gt; *, n_components_ &gt; &amp;vectors_sm, const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;mask) const</td></tr>
<tr class="separator:a427af54345534f8d734230ad56d4a367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b9198e9b8d3306e7b9fc7ebffb7077"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename VectorOperation &gt; </td></tr>
<tr class="memitem:a06b9198e9b8d3306e7b9fc7ebffb7077"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a06b9198e9b8d3306e7b9fc7ebffb7077">read_write_operation_global</a> (const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;operation, const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;vectors) const</td></tr>
<tr class="separator:a06b9198e9b8d3306e7b9fc7ebffb7077"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aacafd9861301674853b127a115d4de1e"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aacafd9861301674853b127a115d4de1e">values_dofs</a> [<a class="el" href="classFEEvaluation.html#ad87ecbe1b7e87f0b45b56d7434061c71">n_components</a>]</td></tr>
<tr class="separator:aacafd9861301674853b127a115d4de1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b01fcfb319697ad15319c44d635358"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aa2b01fcfb319697ad15319c44d635358">values_quad</a></td></tr>
<tr class="separator:aa2b01fcfb319697ad15319c44d635358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c0240702f8a5f1bcd102ef69919b54"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a01c0240702f8a5f1bcd102ef69919b54">gradients_quad</a></td></tr>
<tr class="separator:a01c0240702f8a5f1bcd102ef69919b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7ce5837713e301d3e8c4718fdcce67"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#aca7ce5837713e301d3e8c4718fdcce67">hessians_quad</a></td></tr>
<tr class="separator:aca7ce5837713e301d3e8c4718fdcce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad363fb71770ee9f1b521e5a539993ef3"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ad363fb71770ee9f1b521e5a539993ef3">n_fe_components</a></td></tr>
<tr class="separator:ad363fb71770ee9f1b521e5a539993ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4931bf96a90394aa552231bfc3d4bb80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a4931bf96a90394aa552231bfc3d4bb80">dof_values_initialized</a></td></tr>
<tr class="separator:a4931bf96a90394aa552231bfc3d4bb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2634b8199be6e9fdec0b0ad715209a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a2634b8199be6e9fdec0b0ad715209a39">values_quad_initialized</a></td></tr>
<tr class="separator:a2634b8199be6e9fdec0b0ad715209a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15f3fb86bd795ee059be4accef81ca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#af15f3fb86bd795ee059be4accef81ca8">gradients_quad_initialized</a></td></tr>
<tr class="separator:af15f3fb86bd795ee059be4accef81ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510ed69b6143a1a497c41c93a200a39d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a510ed69b6143a1a497c41c93a200a39d">hessians_quad_initialized</a></td></tr>
<tr class="separator:a510ed69b6143a1a497c41c93a200a39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53e482c5d5eb5b156e79d322f7fdf12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#ad53e482c5d5eb5b156e79d322f7fdf12">values_quad_submitted</a></td></tr>
<tr class="separator:ad53e482c5d5eb5b156e79d322f7fdf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747a9ff4cbaedd9b48f7aa1378e2682c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a747a9ff4cbaedd9b48f7aa1378e2682c">gradients_quad_submitted</a></td></tr>
<tr class="separator:a747a9ff4cbaedd9b48f7aa1378e2682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f9032a1a57f19c6e21915eaee09716"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a></td></tr>
<tr class="separator:a42f9032a1a57f19c6e21915eaee09716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd8d38b99b2e85efbc37570c76d0def"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBase.html#a3cd8d38b99b2e85efbc37570c76d0def">local_dof_indices</a></td></tr>
<tr class="separator:a3cd8d38b99b2e85efbc37570c76d0def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c8dcc076400f538a3c85a5cbec9cb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#ad9c8dcc076400f538a3c85a5cbec9cb3">scratch_data_array</a></td></tr>
<tr class="separator:ad9c8dcc076400f538a3c85a5cbec9cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35283bcccba5587bff326a245d322e7"><td class="memItemLeft" align="right" valign="top">VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#af35283bcccba5587bff326a245d322e7">scratch_data</a></td></tr>
<tr class="separator:af35283bcccba5587bff326a245d322e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533b073ea515b343f9d785da2f342066"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a533b073ea515b343f9d785da2f342066">quad_no</a></td></tr>
<tr class="separator:a533b073ea515b343f9d785da2f342066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d19d2e454832346b9ae547f0330533"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#af0d19d2e454832346b9ae547f0330533">matrix_info</a></td></tr>
<tr class="separator:af0d19d2e454832346b9ae547f0330533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa7522a2f5003b7aefa14209ccd4723"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#adfa7522a2f5003b7aefa14209ccd4723">dof_info</a></td></tr>
<tr class="separator:adfa7522a2f5003b7aefa14209ccd4723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c31ae7463c9952de2b8edb01a942938"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfoStorage.html">internal::MatrixFreeFunctions::MappingInfoStorage</a>&lt;(is_face ? dim - 1 :dim), dim, Number, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a8c31ae7463c9952de2b8edb01a942938">mapping_data</a></td></tr>
<tr class="separator:a8c31ae7463c9952de2b8edb01a942938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5f9995bfa3e160a8e111837e4293c9"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#afa5f9995bfa3e160a8e111837e4293c9">active_fe_index</a></td></tr>
<tr class="separator:afa5f9995bfa3e160a8e111837e4293c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d55c8a88a0a393b7eec7a2843cc9bd"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a15d55c8a88a0a393b7eec7a2843cc9bd">active_quad_index</a></td></tr>
<tr class="separator:a15d55c8a88a0a393b7eec7a2843cc9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0ee194a86f8af161dbb74c8580fc30"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfoStorage.html">internal::MatrixFreeFunctions::MappingInfoStorage</a>&lt;(is_face ? dim - 1 :dim), dim, Number, VectorizedArrayType &gt;::QuadratureDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a0d0ee194a86f8af161dbb74c8580fc30">descriptor</a></td></tr>
<tr class="separator:a0d0ee194a86f8af161dbb74c8580fc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748b05799b1fdcda8e1bef6ac563b119"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a748b05799b1fdcda8e1bef6ac563b119">n_quadrature_points</a></td></tr>
<tr class="separator:a748b05799b1fdcda8e1bef6ac563b119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9ba9049f2df1bc4ef95ae789faf12e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt; VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a5d9ba9049f2df1bc4ef95ae789faf12e">data</a></td></tr>
<tr class="separator:a5d9ba9049f2df1bc4ef95ae789faf12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421376c6f8ddefa1797a58e8f9003e7b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a421376c6f8ddefa1797a58e8f9003e7b">jacobian</a></td></tr>
<tr class="separator:a421376c6f8ddefa1797a58e8f9003e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb54ca45a7f4e02fc77d8651f08af427"><td class="memItemLeft" align="right" valign="top">const VectorizedArrayType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#abb54ca45a7f4e02fc77d8651f08af427">J_value</a></td></tr>
<tr class="separator:abb54ca45a7f4e02fc77d8651f08af427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd6146dc538c94a881eb0a6b216f313"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a7cd6146dc538c94a881eb0a6b216f313">normal_vectors</a></td></tr>
<tr class="separator:a7cd6146dc538c94a881eb0a6b216f313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b06df026ae07f6b6a0b96c7395985d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, VectorizedArrayType &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a2b06df026ae07f6b6a0b96c7395985d9">normal_x_jacobian</a></td></tr>
<tr class="separator:a2b06df026ae07f6b6a0b96c7395985d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b872287e6c00c65b77919e58c2fe64c"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a5b872287e6c00c65b77919e58c2fe64c">quadrature_weights</a></td></tr>
<tr class="separator:a5b872287e6c00c65b77919e58c2fe64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2db8170a4e834313fa1775d50c26a2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a></td></tr>
<tr class="separator:aba2db8170a4e834313fa1775d50c26a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc1a1074ec29081286adcbff30844fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a1dc1a1074ec29081286adcbff30844fe">is_interior_face</a></td></tr>
<tr class="separator:a1dc1a1074ec29081286adcbff30844fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c4f195d4895c0b57af17a71ee6718c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">internal::MatrixFreeFunctions::DoFInfo::DoFAccessIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#ab5c4f195d4895c0b57af17a71ee6718c">dof_access_index</a></td></tr>
<tr class="separator:ab5c4f195d4895c0b57af17a71ee6718c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04643788ab09d99f9d107c4b6879d6b1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a04643788ab09d99f9d107c4b6879d6b1">face_no</a></td></tr>
<tr class="separator:a04643788ab09d99f9d107c4b6879d6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a69d8b541c14cc64cc2626d3884dfb3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a4a69d8b541c14cc64cc2626d3884dfb3">face_orientation</a></td></tr>
<tr class="separator:a4a69d8b541c14cc64cc2626d3884dfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170d149afc7b1e8d7315c3038ddd0aec"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a170d149afc7b1e8d7315c3038ddd0aec">subface_index</a></td></tr>
<tr class="separator:a170d149afc7b1e8d7315c3038ddd0aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c75f69107df221620b6dcbc292065d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__matrixfree.html#gae024b29b6819e727d47016c6b6b53d8c">internal::MatrixFreeFunctions::GeometryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a50c75f69107df221620b6dcbc292065d">cell_type</a></td></tr>
<tr class="separator:a50c75f69107df221620b6dcbc292065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc1956583b69b8f1010da1dbce26403"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classinternal_1_1MatrixFreeFunctions_1_1MappingDataOnTheFly.html">internal::MatrixFreeFunctions::MappingDataOnTheFly</a>&lt; dim, Number, VectorizedArrayType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluationBaseData.html#a6bc1956583b69b8f1010da1dbce26403">mapped_geometry</a></td></tr>
<tr class="separator:a6bc1956583b69b8f1010da1dbce26403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afc33f44fa5f8894cef597acdae4a0940"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEEvaluation.html#afc33f44fa5f8894cef597acdae4a0940">check_template_arguments</a> (const unsigned <a class="el" href="classint.html">int</a> fe_no, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html#a42f9032a1a57f19c6e21915eaee09716">first_selected_component</a>)</td></tr>
<tr class="separator:afc33f44fa5f8894cef597acdae4a0940"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt;<br />
class FEEvaluation&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;</h3>

<p>该类提供了在正交点和单元格积分上评估函数所需的所有功能。在功能上，这个类与FEValues类似，但是，它包括很多专门的函数，使其速度更快（5到500之间，取决于多项式的程度）。对于DG中人脸项的评估，请参见类FEFaceEvaluation。 </p><h3>Usage and initialization</h3>
<h4>Fast usage in combination with <a class="el" href="classMatrixFree.html">MatrixFree</a></h4>
<p>首要的使用方法是通过MatrixFree对象初始化这个类，该对象缓存了所有与自由度和映射信息相关的内容。这样，就有可能使用矢量化的方式，一次为几个单元应用微分算子。 FEEvaluation的能力涵盖了大量的弱形式的积分任务。一般来说，有两类任务是可以完成的。一个是 <code>evaluate</code> 路径，从解向量插值到正交点。</p>
<div class="fragment"><div class="line"><a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree&gt;</a> phi(matrix_free);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a> = cell_range.first;</div><div class="line">   <a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a> &lt; cell_range.second; ++<a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a>)</div><div class="line">{</div><div class="line">  phi.reinit(<a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a>);</div><div class="line">  phi.read_dof_values(vector);</div><div class="line">  phi.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);   <span class="comment">// interpolate values only</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;phi.n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> val = phi.get_value(q);</div><div class="line">      <span class="comment">// do something with val</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>同样，由 <code>矢量代表的有限元解的梯度可以通过</code> <code>phi.get_gradient(q)插值到正交点。read_dof_values()、evaluate()和get_value()的组合与</code> <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> 或 <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValues::get_function_gradients</a> 所做的类似，但一般来说要快得多，因为它利用了张量积，见下面对评估例程的描述，并且可以通过矢量化一次为几个单元做这个操作。 FEEvaluation完成的第二类任务是右手边的积分任务。在有限元计算中，这些任务通常包括将正交点上的一个量（一个函数值，或者一个由有限元空间本身插值的场）与一组测试函数相乘，通过对每个正交点的值进行求和，再乘以正交权重和变换的雅各布行列式，对单元进行积分。如果给定一个通用的Function对象，我们想计算 \(v_i = \int_\Omega \varphi_i f dx\) ，这可以通过以下单元的积分来完成。</p>
<div class="fragment"><div class="line"><a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree&gt;</a> phi(matrix_free);</div><div class="line"><a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;<span class="keyword">function</span> = ...;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a> = cell_range.first;</div><div class="line">   <a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a> &lt; cell_range.second; ++<a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a>)</div><div class="line">{</div><div class="line">  phi.reinit(<a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;phi.n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim,VectorizedArray&lt;double&gt;</a> &gt; p_vect =</div><div class="line">        phi.quadrature_point(q);</div><div class="line">      <span class="comment">// Need to evaluate function for each component in VectorizedArray</span></div><div class="line">      <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> f_value;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;double&gt;::size(); ++v)</div><div class="line">        {</div><div class="line">          <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            p[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = p_vect[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][v];</div><div class="line">          f_value[v] = <span class="keyword">function</span>.value(p);</div><div class="line">        }</div><div class="line">      phi.submit_value(f_value, q);</div><div class="line">    }</div><div class="line">  phi.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">  phi.distribute_local_to_global(dst);</div><div class="line">}</div></div><!-- fragment --><p>在这段代码中，对 <code>phi.submit_value()</code> 的调用在实际积分之前为测试函数的乘法做了准备（在提交调用中，要测试的值也被乘以雅各布的行列式和正交的权重）。在 <code><a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">integrate()</a></code> 调用中，由FEEvaluation对象的每个基础函数（例如二维的FE_Q &lt;2&gt;(1) 的四个线性形状函数）测试的积分贡献被计算出来，这就给出了要加到 <code>dst</code> 向量中的向量条目。需要注意的是，上面的代码需要明确地在向量数组中循环计算函数的分量，这对于与具有双参数的通用Function对象对接是必要的。简单的函数也可以直接用VectorizedArray形式实现，因为VectorizedArray提供了基本的数学运算。 对于评估一个双线性形式，在源向量上的评估与涉及测试函数的积分相结合，被写入结果向量中。这种设置是无矩阵算子求值的背景，在 <a class="el" href="step_37.html">step-37</a> 和 <a class="el" href="step_48.html">step-48</a> 的教程程序中解释过。 请注意，通过 <a class="el" href="classFEEvaluationBase.html#a5c3bf28ebceb0271addfba5b92f475ce">FEEvaluation::read_dof_values</a> 和 <a class="el" href="classFEEvaluationBase.html#a13c9d8eac4ca7b3f7d45eda97ea8e2fb">FEEvaluation::distribute_local_to_global</a> 的两个向量访问，基于 <a class="el" href="classMatrixFree.html#adb324d469b296f2a6921b41208732ddf">MatrixFree::reinit()</a> 调用时指定的AffineConstraints对象，在飞行中解决约束。如果对自由度的值感兴趣（通常只需要正交点的值），可以通过 FEEvaluation::get_dof_value(i), 访问这些值，其中i是基函数的索引。请注意，FEEvaluation中连续元素自由度的编号与FE_Q（或FEValues）中的排序不同，因为FEEvaluation需要以lexicographic顺序访问它们，例如FE_DGQ中使用的就是这种排序。重新索引的成本太高，因为evaluate()和integration()里面的访问是在张量评估部分的关键路径上。在evaluate()调用之前，通过read_dof_values()填充DoF值的一个替代方法是通过set_dof_value()调用手动赋值。同样，如果积分的局部结果应该被进一步处理，而不是通过distribut_local_to_global()分散到一个向量中，我们可以在调用 <a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">integrate()</a>后通过get_dof_value()来访问它。在不同背景下使用积分值的一个例子是快速装配矩阵，如下一小节所示。 对于大多数反复穿过网格的算子评估任务，MatrixFree的实现方式是将预先计算的映射数据（几何描述的雅各布变换）与基函数的即时评估相结合，是最有效的方式。换句话说，该框架在内存使用和对象的初始化之间选择了一种权衡，适合用无矩阵的方式替代矩阵-向量乘积或显式时间积分。 </p><h4>Usage without pre-initialized <a class="el" href="classMatrixFree.html">MatrixFree</a> object</h4>
<p>第二种使用形式是通过FEValues生成的几何信息来初始化FEEvaluation。这允许在不事先初始化MatrixFree对象的情况下，即时应用积分循环。当MatrixFree的内存和初始化成本不可接受时，这可能很有用，例如，在误差计算中，不同数量的正交点应该被用于一次评估。另外，当使用这个类的例程来组装矩阵时，MatrixFree类所暗示的权衡可能是不可取的。在这种情况下，即时初始化必要的几何数据的成本是相当低的，因此避免全局对象MatrixFree是有用的。当以这种方式使用时，会使用让人想起带有单元格迭代器的FEValues的reinit方法。然而，请注意，这种模式的结果是一次只处理一个单元，几何数据在矢量化数组的所有组件中都是重复的。因此，只有在可以对不同的数据进行相同的操作时，矢量化才是有用的，例如在进行矩阵装配时。 作为一个例子，考虑下面的代码来组装对拉普拉斯矩阵的贡献。</p>
<div class="fragment"><div class="line"><a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree&gt;</a> fe_eval (mapping, finite_element,</div><div class="line">                                   <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a>(fe_degree+1), flags);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a> : dof_handler.active_cell_iterators())</div><div class="line">{</div><div class="line">  fe_eval.reinit(<a class="code" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="classFEEvaluation.html#ab89db52bf6207863f14325522f8d229a">dofs_per_cell</a>;</div><div class="line">       i += <a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_items =</div><div class="line">        i+<a class="code" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray&lt;double&gt;::size</a>() &gt; dofs_per_cell ?</div><div class="line">        (dofs_per_cell</div><div class="line"></div><div class="line">- i) :</div><div class="line">        <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;::size</a>();</div><div class="line"></div><div class="line">      <span class="comment">// Set n_items unit vectors</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="classFEEvaluation.html#ab89db52bf6207863f14325522f8d229a">dofs_per_cell</a>; ++j)</div><div class="line">        fe_eval.set_dof_value(<a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a>(), j);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;n_items; ++v)</div><div class="line">        {</div><div class="line">          <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> one_value = <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a>();</div><div class="line">          one_value[v] = 1.;</div><div class="line">          fe_eval.set_dof_value(one_value, i+v);</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="comment">// Apply operator on unit vector to generate the next few matrix</span></div><div class="line">      <span class="comment">// columns</span></div><div class="line">      fe_eval.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>|<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;<a class="code" href="classFEEvaluation.html#a1b8934d6ae273d7b3f91994eddcad239">n_q_points</a>; ++q)</div><div class="line">        {</div><div class="line">          fe_eval.submit_value(10.*fe_eval.get_value(q), q);</div><div class="line">          fe_eval.submit_gradient(fe_eval.get_gradient(q), q);</div><div class="line">        }</div><div class="line">      fe_eval.integrate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>|<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"></div><div class="line">      <span class="comment">// Insert computed entries in matrix</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;n_items; ++v)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;<a class="code" href="classFEEvaluation.html#ab89db52bf6207863f14325522f8d229a">dofs_per_cell</a>; ++j)</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(fe_eval.get_internal_dof_numbering()[j],</div><div class="line">                      fe_eval.get_internal_dof_numbering()[i+v])</div><div class="line">            = fe_eval.get_dof_value(j)[v];</div><div class="line">    }</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>这段代码用上面 <code>i</code> 的循环生成了单元格矩阵的列。这样做的方式如下。FEEvaluation的例程专注于有限元算子的评估，所以对于计算单元矩阵的算子评估，它被应用于单元上的所有单位向量。在单位向量上应用算子可能看起来效率不高，但这里使用的评估例程非常快，以至于它们的工作速度仍然比FEValues可能的要快得多。特别是，复杂度是 <code>(fe_degree+1)<sup>2*dim+1</sup> </code> 而不是 <code>(fe_degree+1)<sup>3*dim</sup> </code> 。 由于矢量化，我们可以一次生成几个单位向量的矩阵列（例如4）。变量 <code>n_items</code> 确保我们正确地做最后一次迭代，其中单元格的数量不被矢量化长度所除。还要注意的是，我们需要得到fe_eval应用的内部自由度编号，因为FEEvaluation内部使用的是自由度的词法编号，如上所述。 </p><h4>Internal data organization</h4>
<p>用于保存局部自由度的求解值以及正交点的内插值、梯度和Hessians的临时数据是由 <a class="el" href="classMatrixFree.html#acf9054eb8149297fe2e062369f0dc618">MatrixFree::acquire_scratch_data()</a> 提供的Scratch数组，在对FEEvaluation的不同调用之间被重复使用。因此，构造一个FEEvaluation对象通常很便宜，不涉及任何昂贵的操作。在构建过程中，只有几十个指向实际数据字段的指针被设置。因此，在每个循环中多次创建一个FEEvaluation时，不会产生负面的性能影响，例如在一个<code>local_cell_operation</code>操作的顶部，该操作被分割成小块用于并行for循环，避免了在 <code><a class="el" href="namespaceWorkStream.html">WorkStream</a></code>. 的循环中需要单独的抓取数据字段。 当在多线程模式下使用FEEvaluation类时，MatrixFree中抓取数据的线程本地存储会自动确保每个线程得到它的私有数据阵列。然而，请注意，当所有的线程并行化是由外部提供的，而不是通过deal.II的例程完成的，如OpenMP，deal.II也必须被编译为支持线程。这是因为deal.II需要知道线程本地存储的符号。FEEvaluation内核已经被验证可以在OpenMP循环中工作。 </p><h4>Vectorization scheme through <a class="el" href="classVectorizedArray.html">VectorizedArray</a></h4>
<p>该类旨在通过显式矢量化来执行现代CPU上存在的单指令多数据（SIMD）指令的所有算术，这些指令在deal.II中通过类VectorizedArray提供，使用配置/编译时可用的最宽矢量宽度。为了保持程序的灵活性，FEEvaluation总是在几个元素上应用矢量化。这通常是最好的妥协，因为在有限元方法中，不同元素上的计算通常是独立的（当然，除了向全局残差向量添加积分贡献的过程），在更复杂的情况下也是如此。例如，稳定参数可以定义为一个单元的所有正交点上的某些量的最大值除以该单元的体积，但不需要将结果与邻接点进行局部混合。使用计算机结构的术语，FEEvaluation的设计依赖于在典型的集成场景下对单元进行操作时不做任何跨线数据交换。 当问题中的单元数不是SIMD向量中数组元素的倍数时，FEEvaluation的实现会在未使用的SIMD通道中填入一些假条目，并将它们带入周围，由于VectorizedArray的长度在编译时是固定的，所以这一选择是必要的。然而，与自动矢量化设置相比，这种方法通常会产生更好的代码，因为在自动矢量化设置中，除了在完全填充的通道上使用的矢量化版本外，还需要另一个未矢量化的代码路径，同时还有一个调度机制。在 <code>read_dof_values</code>, 中，对不完整的一批单元的reinit()调用所产生的空道被设置为零，而 <code>distribute_local_to_global</code> 或 <code>set_dof_values</code> 则简单地忽略了空道中的内容。实际填充的SIMD通道的数量可以通过 <a class="el" href="classMatrixFree.html#a251d5c0f5cc96057223ebbffacd91a03">MatrixFree::n_components_filled()</a>. 来查询。 很明显，在人工通道上进行的计算（没有真实的数据）不应该与有效的结果混合。使用这个类的契约是，用户要确保通道在用户代码中不被交叉，特别是由于事先不清楚哪些单元会在矢量化中被放在一起。例如，除了通过全局向量访问方法或通过被屏蔽的访问 <a class="el" href="classMatrixFree.html#a251d5c0f5cc96057223ebbffacd91a03">MatrixFree::n_components_filled()</a>. ，一个元素上的结果不应该被添加到其他元素上的结果中。 不能保证人工车道上的结果永远是可以安全地添加到其他结果中的零。JxW或Jacobian上的数据是从最后一个有效车道复制的，以避免除以零，这可能引发浮点异常或其他情况下的麻烦。 </p><h3>Description of evaluation routines</h3>
<p>这个类包含了基于张量积正交公式和类似张量积的形状函数的元素的专门评估例程，包括标准的FE_Q或FE_DGQ元素和围绕0.5对称的正交点（像高斯正交），基于截断张量积的FE_DGP元素以及高斯-洛巴托正交元素的更快情况，它给出对角线质量矩阵和内部更快评估。该类的主要优点是在所有正交中评估所有形状函数，或者在 <code>dim (fe_degree+1)<sup>dim+1</sup> </code> 操作中对所有形状函数进行积分，而不是在FEValues的评估例程中的较慢的 <code> (fe_degree+1)<sup>2*dim</sup></code> 复杂性。这是由一种叫做和因子化的算法完成的，该算法在沿坐标方向的评估过程中剔除了常数因子。这个算法是许多谱元算法的基础。 请注意，通过这个类可以进行的许多操作都是从基类FEEvaluationBase继承的，特别是对向量的读写。另外，该类继承了FEEvaluationAccess，实现了对正交点上有限元函数的值、梯度和Hessians的访问。 该类假定所考虑的有限元的形状函数 <em> 不 </em> 依赖于实空间中单元的几何形状。目前，其他有限元不能用无矩阵概念处理。 </p><h4>Degree of finite element as a compile-time parameter</h4>
<p>该类FEEvaluation为两个使用模式。第一个使用模式是将多项式程度作为模板参数来指定。这保证了最大的效率。用和因数法进行评估时，会执行一些嵌套的短1D循环，其长度等于多项式度数加1。如果在编译时知道循环的边界，编译器可以根据其启发式方法认为最有效的方式展开循环。至少最里面的循环几乎总是被完全解开，避免了循环的开销。 然而，将多项式度数（以及正交点的数量）作为模板参数携带，在需要考虑不同的多项式度数的代码中，例如在通过输入文件给出多项式度数的应用代码中，事情就变得更加复杂。第二种使用模式是依靠预编译的代码来处理多项式度数。虽然用户代码可以为单元格使用不同的函数（这些函数会被一些动态调度机制调用，用于不同的度数模板），但deal.II也支持基于传递给初始化的元素中的信息来使用这个类。对于这种使用模式，将多项式程度的模板参数设置为</p>
<ul>
<li>并为正交点的数量选择一个任意的数字。该代码部分包含预编译的模板代码，用于1到6之间的多项式度数和常见的正交公式，其运行速度几乎与模板版本相同。如果所选的度数没有被预编译，一个具有模板专业性的评估器对象将用于</li>
</ul>
<p>-被调用，根据运行时间的界限运行。 下图给出了FEEvaluation的性能概览。它考虑了使用类似于 <a class="el" href="step_37.html">step-37</a> 单精度算术教程程序的代码，用连续有限元评估拉普拉斯的每个自由度所花费的时间。该时间是基于英特尔至强E5-2687W v4单核的实验，运行频率为3.4GHz，在问题大小为1000万左右时测量的。该图列出了计算时间（约0.1秒）除以自由度数。 </p><div class="image">
<img src="fe_evaluation_laplacian_time_per_dof.png" alt="fe_evaluation_laplacian_time_per_dof.png"/>
</div>
<p> 该图显示，模板化的计算核比非模板化的计算核快2.5到3倍。在这个设置上，最快的周转是对多项式5度的计算，每自由度7.4e-9秒，或每秒1.34亿自由度。</p>
<ul>
<li>在一个单核上。非模板化版本在多项式5度时也是最快的，每个自由度2.1e-9秒，或每秒4800万自由度。注意，使用模板<code>degree=-1</code>的FEEvaluation会选择1到6度之间的快速路径，而其他度数则选择慢速路径。 <h4>Pre-compiling code for more polynomial degrees</h4>
</li>
</ul>
<p>也可以为不同的最大多项式度数预先编译FEEvaluation中的代码。这由类 <a class="el" href="structinternal_1_1FEEvaluationFactory.html">internal::FEEvaluationFactory</a> 和<code>nclude/deal.II/matrix_free/evaluation_template_factory.templates.h</code>中的实现控制。通过设置宏<code>FE_EVAL_FACTORY_DEGREE_MAX</code>为所需的整数，并实例化类FEEvaluationFactory和FEFaceEvaluationFactory（后者用于FEFaceEvaluation），为可能更大的度数集创建模板函数的路径。你可以通过调用 <a class="el" href="classFEEvaluation.html#a6abe391d376ebaec28b84ea5c3052101">FEEvaluation::fast_evaluation_supported()</a> 或 <a class="el" href="classFEFaceEvaluation.html#abc9958a53c2aaad1cf773fff6d104ff2">FEFaceEvaluation::fast_evaluation_supported()</a>. 来检查是否对一个给定的度数/n_正交点进行了快速评估/积分。 </p><h3>Handling multi-component systems</h3>
<p>FEEvaluation还允许通过一个关于分量数量的模板参数来处理矢量值问题。</p>
<div class="fragment"><div class="line"><a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,fe_degree,n_q_points_1d,n_components&gt;</a> phi(matrix_free);</div></div><!-- fragment --><p>如果这样使用，可以通过调用从一个 <code>std::vector&lt;VectorType&gt;</code> 的几个组件中收集组件</p>
<div class="fragment"><div class="line">phi.read_dof_values(src, 0);</div></div><!-- fragment --><p>其中的0表示应该使用从 <code>std::vector</code> 中的第2个向量开始的向量，<code>src[0], src[1], ..., src[n_components-1]</code>。 如果MatrixFree数据底层的DoFHandler是基于 <code>n_components项的FESystem，那么读取多成分系统的另一种方式是可能的。在这种情况下，为read_dof_values()和distribut_local_to_global()调用提供一个单一的向量。</code> FEEvaluation在多组件系统中的一个重要属性是在get_value()、get_gradient()或get_dof_value()调用中的多组件布局。在这种情况下，返回的不是标量字段 <a class="el" href="classVectorizedArray.html">VectorizedArray</a> &lt;double&gt; 而是张量。</p>
<div class="fragment"><div class="line"><a class="code" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value</a></div><div class="line"></div><div class="line">-&gt; <a class="code" href="classTensor.html">Tensor&lt;1,n_components,VectorizedArray&lt;double&gt;</a>&gt;</div><div class="line"><a class="code" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient</a></div><div class="line"></div><div class="line">-&gt; <a class="code" href="classTensor.html">Tensor&lt;1,n_components,Tensor&lt;1,dim,VectorizedArray&lt;double&gt;</a>&gt;</div></div><!-- fragment --><p>与此类似，submit_value()和submit_gradient()调用的是张量的值。请注意，存在对 <code>n_components=1和</code> <code>n_components=dim</code>, 的特殊化，它们是通过基类FEEvaluationAccess提供的。在标量情况下，这些提供了上述的标量返回类型。在矢量值的情况下，梯度从<code><a class="el" href="classTensor.html">Tensor</a> &lt;1,dim,<a class="el" href="classTensor.html">Tensor</a>&lt;1,dim,<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;double&gt; &gt; &gt;</code> 转换为<code><a class="el" href="classTensor.html">Tensor</a> &lt;2,dim,<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;double&gt; &gt;</code>. 此外，额外的操作，如diveregence或curl也是可用的。 如果不同的形状函数被结合起来，例如Stokes流中的混合有限元公式，将创建两个FEEvaluation对象，一个用于速度，一个用于压力。然后在正交点上进行组合。</p>
<div class="fragment"><div class="line"><a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,degree_p+1,degree_p+2,dim&gt;</a> velocity (<a class="code" href="classFEEvaluationBaseData.html#a5d9ba9049f2df1bc4ef95ae789faf12e">data</a>, 0);</div><div class="line"><a class="code" href="classFEEvaluation.html">FEEvaluation&lt;dim,degree_p,  degree_p+2,1, &gt;</a> pressure (<a class="code" href="classFEEvaluationBaseData.html#a5d9ba9049f2df1bc4ef95ae789faf12e">data</a>, 1);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a>=cell_range.first; <a class="code" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a>&lt;cell_range.second; ++<a class="code" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a>)</div><div class="line">{</div><div class="line">  velocity.reinit (<a class="code" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a>);</div><div class="line">  velocity.read_dof_values (src.block(0));</div><div class="line">  velocity.evaluate (<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">  pressure.reinit (<a class="code" href="classFEEvaluationBaseData.html#aba2db8170a4e834313fa1775d50c26a2">cell</a>);</div><div class="line">  pressure.read_dof_values (src.block(1));</div><div class="line">  pressure.evaluate (<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;velocity.n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim,VectorizedArray&lt;double&gt;</a> &gt; sym_grad_u =</div><div class="line">        velocity.get_symmetric_gradient (q);</div><div class="line">      <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> pres = pressure.get_value(q);</div><div class="line">      <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> div =</div><div class="line"></div><div class="line">-<a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(sym_grad_u);</div><div class="line">      pressure.submit_value (div, q);</div><div class="line"></div><div class="line">      <span class="comment">// subtract p I</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>=0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        sym_grad_u[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>]</div><div class="line"></div><div class="line">-= pres;</div><div class="line"></div><div class="line">      velocity.submit_symmetric_gradient(sym_grad_u, q);</div><div class="line">   }</div><div class="line"></div><div class="line">  velocity.integrate (<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line">  velocity.distribute_local_to_global (dst.block(0));</div><div class="line">  pressure.integrate (<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">  pressure.distribute_local_to_global (dst.block(1));</div><div class="line">}</div></div><!-- fragment --><p>这段代码假设一个由两个分量组成的BlockVector分别描述了速度和压力分量。为了识别速度和压力的不同DoFHandler对象，FEEvaluation对象的第二个参数为速度指定各自的分量0，为压力指定1。对于矢量值问题的进一步例子，deal.II测试套件也包括一些额外的例子，例如，上面描述的斯托克斯算子可以在https://github.com/dealii/dealii/blob/master/tests/matrix_free/matrix_vector_stokes_noflux.cc </p><h3>Handling several integration tasks and data storage in quadrature points</h3>
<p>FEEvaluation和MatrixFree的设计将几何学与基函数分开。因此，几个DoFHandler对象（或者同一个DoFHandler配备了不同的约束对象）可以共享相同的几何信息，就像上面的Stokes例子一样。所有的几何体在MatrixFree中被缓存一次，所以FEEvaluation不需要做昂贵的初始化调用，而是设置一些指针。这种实现是基于这样的想法：当几个字段被评估时，也只需要一次几何信息，这与FEValues不同，后者为每个字段设置了内部映射数据。例如，如果一个多分量的PDE涉及到一个分量的形状值和另一个分量的形状梯度，如果两者都基于同一个MatrixFree对象，并且更新标志指定 <code>update_values</code> , <code>update_gradients</code> , 和 <code>update_jxw_values</code> 都给出，就不会失去效率。形状值所需数量的选择是通过evaluation()或integration调用中的标志和正交点的访问。</p>
<div class="fragment"><div class="line">phi1.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a>);</div><div class="line">phi2.evaluate(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;phi1.n_q_points; ++q)</div><div class="line">{</div><div class="line">  <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> val1 = phi1.get_value(q);</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1,dim,VectorizedArray&lt;double&gt;</a> &gt; grad2 = phi2.get_gradient(q);</div><div class="line">  <a class="code" href="classPoint.html">Point&lt;dim,VectorizedArray&lt;double&gt;</a> &gt; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = phi1.quadrature_point(q);</div><div class="line">  <span class="comment">// ... some complicated formula combining those three...</span></div><div class="line">}</div></div><!-- fragment --><p>在正交点的循环中，我们可以要求两个FEEvaluation对象中的任何一个提供正交点的位置，这并不重要，因为它们只保留正交点数据的指针。 这一观察结果也转化为在程序中实现不同的微分算子的情况，例如，在算法的一个阶段，质量矩阵的作用，而在另一个阶段，刚度矩阵的作用。只需要一个MatrixFree对象，通过在不同的FEEvaluation对象中使用不同的局部函数和各自的实现来保持充分的效率。换句话说，用户在为MatrixFree的初始化提供update_flags时，不需要为了效率的原因而费心保守</p>
<ul>
<li>除了在 <a class="el" href="classFEEvaluation.html#a5e77cd8900f05a73a91ca8edf31f4a91">FEEvaluation::reinit()</a> 调用里面最多增加一两个 <code>if</code> 语句外，FEEvaluation内部不会产生任何开销。相反，从效率的角度来看，所有调用中必要的最大标志集是完全没有问题的。 对于不同字段的组合，包括来自不同时间步骤的不同解向量，强制要求所有的FEEvaluation对象共享同一个MatrixFree对象。这是因为单元格被 <a class="el" href="classMatrixFree.html#abc204ec41ead1b5060f47ef3a5a066d7">MatrixFree::cell_loop()</a> 循环的方式对于不同的DoFHandler或AffineConstraints参数可能不同。更确切地说，即使在串行中布局是相同的，但在MPI情况下，对于不同的DoFHandler/AffineConstraints的排序没有任何保证。原因是该算法检测需要与MPI进行数据交换的单元，而这些单元对于不同的元素可能会发生变化，例如，具有悬挂节点约束的FE_Q比FE_DGQ元素连接到更多的邻居，而需要数据交换的单元被放在单元循环中的不同位置。当然，如果设置了完全相同的DoFHandler、AffineConstraints和选项（如线程并行的设置），那么顺序就会相同，因为算法是确定性的。 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">该类所使用的dim维度</td><td></td></tr>
    <tr><td class="paramname">fe_degree</td><td>每个坐标方向具有fe_degree+1个自由度的张量积有限元的程度。可以设置为</td></tr>
  </table>
  </dd>
</dl>
</li>
<li>如果在编译时不知道度数，但性能通常会差2-3倍。 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n_q_points_1d</td><td>一维正交公式中的点数，默认为fe_degree+1。 </td></tr>
    <tr><td class="paramname">n_components</td><td>在求解PDEs系统时，向量分量的数量。如果同一个操作被应用于一个PDE的几个分量（例如，一个矢量拉普拉斯方程），它们可以通过一次调用同时应用（而且通常更有效）。默认为1。 </td></tr>
    <tr><td class="paramname">数字</td><td>数字格式，通常为 <code>double</code> 或 <code>float</code>. 默认为 <code>双数</code> </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00071">71</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a752a2fd5b5d7b1ccb2058c1bdfef7674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752a2fd5b5d7b1ccb2058c1bdfef7674">&#9670;&nbsp;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluation.html#a752a2fd5b5d7b1ccb2058c1bdfef7674">BaseClass</a> =  <a class="el" href="classFEEvaluationAccess.html">FEEvaluationAccess</a>&lt;dim, n_components_, Number, false, VectorizedArrayType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>基类的别名。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02154">2154</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aa6f2076e454c90af29ae60d2b8294256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f2076e454c90af29ae60d2b8294256">&#9670;&nbsp;</a></span>number_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluationBase.html#a155a4a32adfd4c256bcac84b13c8a368">number_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个作为模板参数指定的底层数字类型。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02160">2160</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ad3983bd07d5058c7af23dc9ca5daeca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3983bd07d5058c7af23dc9ca5daeca4">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> =  typename <a class="el" href="classFEEvaluationAccess.html#a341c39cbf9948d06561b74f9c5050d10">BaseClass::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>函数值的类型，例如 "n_components=1 "的 "VectorizedArrayType
"或 "n_components=dim "的 "Tensor&lt;1,dim,VectorizedArrayType&gt;"。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02167">2167</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a8a40f0bccb9db6ed543f7800a824f930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a40f0bccb9db6ed543f7800a824f930">&#9670;&nbsp;</a></span>gradient_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a> =  typename <a class="el" href="classFEEvaluationAccess.html#a6167b54604de2e9022ec743267e5a25b">BaseClass::gradient_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>梯度的类型，例如，<code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim,VectorizedArrayType&gt;</code>代表<code>n_components=1</code>或者<code><a class="el" href="classTensor.html">Tensor</a>&lt;2,dim,VectorizedArrayType &gt;</code>代表<code>n_components=dim</code>。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02174">2174</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ade40e452949cbefd4f7e6d5580af81c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade40e452949cbefd4f7e6d5580af81c8">&#9670;&nbsp;</a></span>FEEvaluation() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluation.html">FEEvaluation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_free</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>active_fe_index</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>active_quad_index</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。接受存储在MatrixFree中的所有数据。如果应用于在构建 <code>matrix_free</code>, 过程中选择了一个以上的有限元或一个以上的正交公式的问题，可以通过可选的参数选择合适的组件。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix_free</td><td>包含所有数据的数据对象 </td></tr>
    <tr><td class="paramname">dof_no</td><td>如果matrix_free是用多个DoFHandler对象设置的，这个参数可以选择给定的评估器应该连接到哪个DoFHandler/AffineConstraints对。 </td></tr>
    <tr><td class="paramname">quad_no</td><td>如果matrix_free被设置为多个正交对象，该参数将选择适当的正交公式编号。 </td></tr>
    <tr><td class="paramname">first_selected_component</td><td>如果由dof_no选择的dof_handler使用一个由多个组件组成的FESystem，这个参数允许选择当前评估程序开始的组件。注意，一个评估器不支持在不同的组件中结合不同的形状函数。换句话说，FESystem的同一个基本元素需要为 <code>first_selected_component</code> 和 <code>first_selected_component+n_components_</code> 之间的组件设置。 </td></tr>
    <tr><td class="paramname">active_fe_index</td><td>如果matrix_free是用 hp::FECollections, 的DoFHandler对象设置的，这个参数可以选择给定的评估器应该连接到哪个DoFHandler/AffineConstraints对。 </td></tr>
    <tr><td class="paramname">active_quad_index</td><td>如果matrix_free是用 <a class="el" href="classhp_1_1Collection.html">hp::Collection</a> 对象设置的，该参数选择正交公式的适当编号。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06293ee7aac4f62c80be6862aa1ae101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06293ee7aac4f62c80be6862aa1ae101">&#9670;&nbsp;</a></span>FEEvaluation() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluation.html">FEEvaluation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix_free</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quad_no</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。接受存储在MatrixFree中的所有数据，用于给定的单元格范围，这可以在p-adaptive策略的情况下自动识别active_fe_index和active_quad_index。 其余的参数与上面的构造函数相同。 </p>

</div>
</div>
<a id="a1b0dc3f17c28f2db5fd4237b1bf04342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0dc3f17c28f2db5fd4237b1bf04342">&#9670;&nbsp;</a></span>FEEvaluation() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluation.html">FEEvaluation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数，功能减少，工作方式与FEValues类似。参数与传递给FEValues的构造函数的参数类似，值得注意的是，FEEvaluation期望一个一维的正交公式Quadrature&lt;1&gt;，而不是一个 <code>dim</code> 维的公式。有限元既可以是标量也可以是矢量值，但是这个方法每次总是只选择一个标量基元（按照类模板指定的 <code>n_components</code> 副本）。对于向量值元素，可选的参数 <code>first_selected_component</code> 允许指定用于评估的基础元素的索引。注意，内部数据结构总是假定基元是原始的，目前不支持非原始的。 正如从FEValues中得知的那样，调用带有 <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">Triangulation&lt;dim&gt;::cell_iterator</a> 的reinit方法是必要的，以使当前类的几何和自由度为人所知。如果迭代器包括DoFHandler信息（即它是一个 <a class="el" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;dim&gt;::cell_iterator</a> 或类似的），初始化也允许以 <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler&lt;dim&gt;::active_cell_iterator</a> 类型的标准方式一次从向量中读取或写入一个单元。然而，这种方法比使用MPI的MatrixFree的路径要慢得多，因为必须进行索引转换。由于每次只使用一个单元，这种方法不会在几个元素上进行矢量化（这对矢量操作来说是最有效的），而只可能在元素内进行矢量化，如果评估/整合例程在用户代码内组合的话（例如，计算单元矩阵）。 </p>

</div>
</div>
<a id="a43079434f0a4acc8907e7a6b2d9b541f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43079434f0a4acc8907e7a6b2d9b541f">&#9670;&nbsp;</a></span>FEEvaluation() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluation.html">FEEvaluation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩小功能的构造函数。这个构造函数等同于另一个构造函数，除了它使对象隐含地使用 \(Q_1\) 映射（即，MappingQGeneric(1)类型的对象）。 </p>

</div>
</div>
<a id="a6a553f3be01a24f863b118a932ef45ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a553f3be01a24f863b118a932ef45ee">&#9670;&nbsp;</a></span>FEEvaluation() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluation.html">FEEvaluation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, false, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩小功能的构造函数。类似于其他带有FiniteElement参数的构造函数，但使用另一个FEEvaluationBase对象来提供关于几何的信息。这允许几个FEEvaluation对象共享几何评估，即底层映射和正交点只需要评估一次。当你打算使用与给定对象平行的FEEvaluation对象时，请确保不要传递一个可选的对象，因为否则打算共享的对象可能会产生竞赛条件。 </p>

</div>
</div>
<a id="ae94191b8afd866e461d5ea241d59548d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94191b8afd866e461d5ea241d59548d">&#9670;&nbsp;</a></span>FEEvaluation() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::<a class="el" href="classFEEvaluation.html">FEEvaluation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制构造函数。如果FEEvaluationBase是由映射、fe、正交和更新标志构建的，基于FEValues的底层几何评估将被深度复制，以便允许与线程并行使用。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4fade83f4620d35adcf36ebfc8831431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fade83f4620d35adcf36ebfc8831431">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluation.html">FEEvaluation</a>&amp; <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制赋值运算符。如果FEEvaluationBase是由映射、fe、正交和更新标志构建的，基于FEValues的底层几何评估将被深度复制，以允许与线程并行使用。 </p>

</div>
</div>
<a id="a5e77cd8900f05a73a91ca8edf31f4a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e77cd8900f05a73a91ca8edf31f4a91">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>cell_batch_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将操作指针初始化为当前的单元格批索引。与下面以单元格迭代器为参数的reinit函数和 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 方法不同，与特定单元格相关的信息是在reinit调用中生成的，这个函数非常便宜，因为所有数据都是在 <code>matrix_free</code>, 中预先计算的，只有少数指数需要适当设置。 </p>

</div>
</div>
<a id="a72201adca068e3c1208fdbe1ef32e919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72201adca068e3c1208fdbe1ef32e919">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<div class="memtemplate">
template&lt;bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dim, dim, level_dof_access &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如同FEValues中的惯例，使用TriaIterator对象将数据初始化到当前单元。参数类型为 <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a> 或 <a class="el" href="classDoFHandler.html#ab3149801261133a12128a87b2ec0ca66">DoFHandler::level_cell_iterator</a>. 只有在创建FEEvaluation对象时带有有限元、正交公式和正确的更新标志以及<b>without</b>MatrixFree对象时，该选项才能使用。这种初始化方法失去了使用矢量化的能力，另见FEEvaluation类的描述。当使用这种重启方法时，FEEvaluation也可以从向量中读取数据（但效率比来自MatrixFree的数据低）。 </p>

</div>
</div>
<a id="a45b9569def4f5d94f16112bf92c87cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b9569def4f5d94f16112bf92c87cbb">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像在FEValues中一样使用TriaIterator对象将数据初始化到当前单元。这个选项只有在FEEvaluation对象是用有限元、正交公式和正确的更新标志以及<b>without</b>MatrixFree对象创建的情况下才可用。这种初始化方法失去了使用矢量化的能力，另见FEEvaluation类的描述。当使用这种重启方法时，FEEvaluation可以<b>not</b>从矢量中读取，因为没有DoFHandler信息可用。 </p>

</div>
</div>
<a id="a6abe391d376ebaec28b84ea5c3052101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abe391d376ebaec28b84ea5c3052101">&#9670;&nbsp;</a></span>fast_evaluation_supported()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::fast_evaluation_supported </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>given_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>give_n_q_points_1d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>检查是否支持面部评估/整合。 </p>

</div>
</div>
<a id="a710c252e9dccc0c4ce07044cac3bdd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710c252e9dccc0c4ce07044cac3bdd9b">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估函数值、梯度和从输入矢量中的DoF值到单元格上的正交点的多项式内插的Hessians。 函数参数指定哪些部分应被实际计算。这个函数必须首先被调用，以便访问函数 <code><a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a></code>, <code><a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a></code> 或 <code>get_laplacian提供有用的信息（除非这些值已经被手动设置）。</code> </p>

</div>
</div>
<a id="a706df1ddc8e95119188be47a04e5625e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706df1ddc8e95119188be47a04e5625e">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_hessians</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面一样，但有单独的bool标志。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000061">Deprecated:</a></b></dt><dd>使用evaluate()与EvaluationFlags参数。</dd></dl>

</div>
</div>
<a id="a816110747e83fe4b90bcc4abceea105c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816110747e83fe4b90bcc4abceea105c">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const VectorizedArrayType *&#160;</td>
          <td class="paramname"><em>values_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估从输入数组 <code>values_array中的DoF值到单元格上的正交点的函数值、梯度和多项式内插的Hessians。如果当前的FEEvaluation对象涉及多个部件，</code> <code>values_array</code> 中的排序是第一个部件的所有自由度排在前面，然后是第二个部件的所有自由度，以此类推。函数参数指定哪些部分应被实际计算。这个函数必须先被调用，这样访问函数 <code><a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a></code>, <code><a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a></code> 或 <code>get_laplacian</code> 才能提供有用的信息（除非这些值是手动设置的）。 </p>

</div>
</div>
<a id="ad8f4f4d2a83827a64581756852d9bef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f4f4d2a83827a64581756852d9bef9">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::evaluate </td>
          <td>(</td>
          <td class="paramtype">const VectorizedArrayType *&#160;</td>
          <td class="paramname"><em>values_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_hessians</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面一样，但使用单独的bool标志。</p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>使用evaluate()与EvaluationFlags参数。</dd></dl>

</div>
</div>
<a id="ab53d5c08f460cfe6c9830ac14a427115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53d5c08f460cfe6c9830ac14a427115">&#9670;&nbsp;</a></span>gather_evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::gather_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从输入向量中读取并评估函数值、梯度以及从与当前单元格相关的 <code>input_vector</code> 向量条目到单元格上的正交点的多项式内插的Hessians。函数参数指定哪些部分应被实际计算。这个函数必须首先被调用，以便访问函数 <code><a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a></code>, <code><a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">get_gradient()</a></code> 或 <code>get_laplacian提供有用的信息（除非这些值已经被手动设置）。</code> 这个调用等同于调用read_dof_values()，然后再调用evaluate()，但内部可能会使用一些额外的优化。 </p>

</div>
</div>
<a id="acc3f8ff45455cd59c35c91168d9954c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3f8ff45455cd59c35c91168d9954c5">&#9670;&nbsp;</a></span>gather_evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::gather_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>input_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>evaluate_hessians</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>请使用带有EvaluationFlags参数的 <a class="el" href="classFEEvaluation.html#ab53d5c08f460cfe6c9830ac14a427115">gather_evaluate()</a>函数。</dd></dl>

</div>
</div>
<a id="ad61cbe0d7d6138be040d46ae06a268f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61cbe0d7d6138be040d46ae06a268f1">&#9670;&nbsp;</a></span>integrate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>integration_flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数获取存储在正交点上的值和/或梯度，通过单元上的所有基函数/梯度进行测试，并执行单元积分。两个函数参数 <code>integrate_values</code> 和 <code>integrate_gradients</code> 分别用于启用/禁用提交给数值或梯度槽的贡献求和。结果被写入内部数据域 <code>dof_values</code> （通常由distribut_local_to_global()或set_dof_values()方法写入结果向量中）。 </p>

</div>
</div>
<a id="a311c0ac5cf4b8cf2458996d7099a139a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311c0ac5cf4b8cf2458996d7099a139a">&#9670;&nbsp;</a></span>integrate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated:</a></b></dt><dd>请使用带EvaluationFlags参数的 <a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">integrate()</a> 函数。</dd></dl>

</div>
</div>
<a id="aa08f232810f7c2ec9890c0d02c405de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08f232810f7c2ec9890c0d02c405de8">&#9670;&nbsp;</a></span>integrate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>integration_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorizedArrayType *&#160;</td>
          <td class="paramname"><em>values_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数获取存储在正交点上的值和/或梯度，通过单元上的所有基函数/梯度进行测试，并执行单元积分。两个函数参数 <code>integrate_values</code> 和 <code>integrate_gradients</code> 分别用于启用/禁用提交给数值或梯度槽的贡献的求和。与其他integration()方法相反，这个调用将测试结果存储在给定的数组 <code>values_array</code>, 中，其先前的结果被覆盖，而不是写在begin_dof_values()后面的内部数据结构中。 </p>

</div>
</div>
<a id="aefb8ef59ad57e81197460563e0b479c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb8ef59ad57e81197460563e0b479c1">&#9670;&nbsp;</a></span>integrate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorizedArrayType *&#160;</td>
          <td class="paramname"><em>values_array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000065">Deprecated:</a></b></dt><dd>请使用带EvaluationFlags参数的 <a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">integrate()</a> 函数。</dd></dl>

</div>
</div>
<a id="a491779be7bd032d277e41f1dda8dc584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491779be7bd032d277e41f1dda8dc584">&#9670;&nbsp;</a></span>integrate_scatter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate_scatter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59ae">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>evaluation_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>output_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数获取存储在正交点上的值和/或梯度，通过单元上的所有基函数/梯度进行测试，执行单元积分，并将结果加入与当前单元索引相关的自由度上的全局向量 <code>output_vector</code> 。两个函数参数 <code>integrate_values</code> 和 <code>integrate_gradients</code> 分别用于启用/禁用提交给数值或梯度槽的贡献求和。 这个调用等同于调用 <a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">integrate()</a> 后面的 <a class="el" href="classFEEvaluationBase.html#a13c9d8eac4ca7b3f7d45eda97ea8e2fb">distribute_local_to_global()</a> ，但可能在内部使用一些额外的优化。 </p>

</div>
</div>
<a id="a02cb7b72e780dd02433e10fec759f29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cb7b72e780dd02433e10fec759f29d">&#9670;&nbsp;</a></span>integrate_scatter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::integrate_scatter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>integrate_gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>output_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000066">Deprecated:</a></b></dt><dd>请使用带有EvaluationFlags参数的 <a class="el" href="classFEEvaluation.html#a491779be7bd032d277e41f1dda8dc584">integrate_scatter()</a> 函数。</dd></dl>

</div>
</div>
<a id="ac502951246b5155d586bd090cc9e1572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac502951246b5155d586bd090cc9e1572">&#9670;&nbsp;</a></span>quadrature_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;dim, VectorizedArrayType&gt; <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::quadrature_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回存储在MappingInfo中的实坐标的第q个正交点。 </p>

</div>
</div>
<a id="afc33f44fa5f8894cef597acdae4a0940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc33f44fa5f8894cef597acdae4a0940">&#9670;&nbsp;</a></span>check_template_arguments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::check_template_arguments </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_selected_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>检查关于元素度的模板参数是否与初始化时使用的实际元素相一致。 </p>

</div>
</div>
<a id="a5c3bf28ebceb0271addfba5b92f475ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3bf28ebceb0271addfba5b92f475ce">&#9670;&nbsp;</a></span>read_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于向量 <code>src</code>, 读出当前单元格自由度上的数值，并在内部存储。与没有约束条件时的功能 DoFAccessor::get_interpolated_dof_values 类似，但它也包括来自悬挂节点的约束条件，所以可以把它也看作是与 AffineConstraints::read_dof_values 类似的功能。注意，如果启用了矢量化，几个单元的DoF值会被设置。 如果向量上的某些约束条件是不均匀的，则使用函数read_dof_values_plain代替，并通过调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute</a>. 为向量提供有用的数据，也是在受约束的位置，在线性系统的求解过程中访问向量条目时，临时解应该总是有均匀的约束，这种方法是正确的。 如果给定的向量模板类是块向量（通过模板函数 '<a class="el" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector&lt;VectorType&gt;::value</a>', 确定，该函数检查从 <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>) 或 std::vector&lt;VectorType&gt; 或 std::vector&lt;VectorType&gt;, 派生的向量，该函数从块向量的索引 <code>first_index</code>. 开始读取 <code>n_components</code> 块 对于非块向量， <code>first_index</code> 被忽略了。 </p><dl class="section note"><dt>Note</dt><dd>如果这个类是在没有MatrixFree对象的情况下构建的，并且信息是通过 <a class="el" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;dim&gt;::cell_iterator</a>, 来获取的，那么这个类只使用一个单元，这个函数会提取给定单元上的基础分量的值。这个调用比通过MatrixFree对象完成的调用要慢，并且导致一个结构在基于这些值的评估例程中不能有效地使用矢量化（相反， <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> 相同的副本被工作）。 </dd></dl>

</div>
</div>
<a id="a5bd35a59ccde6eaab46d1264450b93f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd35a59ccde6eaab46d1264450b93f5">&#9670;&nbsp;</a></span>read_dof_values_plain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_dof_values_plain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于矢量 <code>src</code>, 读出当前单元格自由度上的值，并在内部存储。与函数 DoFAccessor::get_interpolated_dof_values. 的功能相似 相对于read_dof_values函数，这个函数从向量中读出普通条目，而不考虑存储的约束。当约束条件已经通过先前调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute</a> 分布在向量上时，这种访问方式是合适的。当要使用不均匀的约束时，这个函数也是必要的，因为MatrixFree只能处理均匀的约束。注意，如果启用了矢量化，几个单元的DoF值会被设置。 如果给定的向量模板类是块向量（通过模板函数 '<a class="el" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector&lt;VectorType&gt;::value</a>', 确定，该函数检查从 <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>) 或 std::vector&lt;VectorType&gt; 或 std::vector&lt;VectorType&gt;, 派生的向量，该函数从块向量的索引 <code>first_index</code>. 开始读取 <code>n_components</code> 块 对于非块向量， <code>first_index</code> 被忽略了。 </p><dl class="section note"><dt>Note</dt><dd>如果这个类是在没有MatrixFree对象的情况下构建的，并且信息是通过 <a class="el" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;dim&gt;::cell_iterator</a>, 来获取的，那么这个类只使用一个单元，这个函数提取给定单元上的基础分量的值。这个调用比通过MatrixFree对象完成的调用要慢，并且导致一个结构在基于这些值的评估例程中不能有效地使用矢量化（相反， <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> 相同的副本被工作）。 </dd></dl>

</div>
</div>
<a id="a13c9d8eac4ca7b3f7d45eda97ea8e2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c9d8eac4ca7b3f7d45eda97ea8e2fb">&#9670;&nbsp;</a></span>distribute_local_to_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>std::bitset&lt;&#160;VectorizedArrayType::size()&gt;().flip()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>获取内部存储在当前单元格的dof值的值，并将它们加到向量中 <code>dst</code>. 该函数在写操作过程中也应用约束。因此，其功能与函数 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a>. 相似。如果启用了矢量化，则会使用几个单元的DoF值。 如果给定的向量模板类是块向量（通过模板函数 '<a class="el" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector&lt;VectorType&gt;::value</a>', 确定，该函数检查从 <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>) 或 std::vector&lt;VectorType&gt; 或 std::vector&lt;VectorType&gt;, 派生的向量，该函数写入块向量的 <code>n_components</code> 块，从索引 <code>first_index</code>. 开始 对于非块向量， <code>first_index</code> 被忽略了。 <code>mask</code> 可以用来抑制对当前单元向量批中包含的一些单元的写入访问，例如，在本地时间步进的情况下，一些单元被排除在调用之外。比特集中的 "true "值意味着将处理相应的车道索引，而 "false
"值则跳过该索引。默认设置是一个包含所有1的比特集，这将把累积的积分写到批次中的所有单元。 </p><dl class="section note"><dt>Note</dt><dd>如果这个类是在没有MatrixFree对象的情况下构建的，并且信息是通过 <a class="el" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;dim&gt;::cell_iterator</a>, 来获取的，那么这个类只使用一个单元格，这个函数会提取给定单元格上的底层组件的值。这个调用比通过MatrixFree对象完成的调用要慢，并且导致一个结构在基于这些值的评估例程中不能有效地使用矢量化（相反， <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> 相同的副本被工作）。 </dd></dl>

</div>
</div>
<a id="a459813036810fbdc3c5487309b118fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459813036810fbdc3c5487309b118fd8">&#9670;&nbsp;</a></span>set_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::set_dof_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>std::bitset&lt;&#160;VectorizedArrayType::size()&gt;().flip()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>获取内部存储在当前单元格的自由度值，并将其写入向量 <code>dst</code>. ，该函数跳过了被约束的自由度。与distribution_local_to_global方法相反，当前单元格给出的位置上的旧值被覆盖。因此，如果一个自由度与一个以上的单元相关联（在连续有限元中很常见），这些值将被覆盖，只有最后写入的值被保留。请注意，在并行环境下，这个函数也可能触及其他MPI进程所拥有的自由度，因此，随后的更新或积累幽灵值（如 <a class="el" href="classMatrixFree.html#a0e9669e4a5cfaceac78f5e26c285c2ea">MatrixFree::loop()</a> 所做的）可能会使这个函数设置的自由度失效。 如果给定的向量模板类是块向量（通过模板函数 '<a class="el" href="group__Vectors.html#gaf1aa9207795db77aaa6d5d0f23e8dbe7">IsBlockVector&lt;VectorType&gt;::value</a>', 确定，该函数检查从 <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>) 或 std::vector&lt;VectorType&gt; 或 std::vector&lt;VectorType&gt;, 派生的向量，该函数从索引 <code>first_index</code>. 开始向块向量的 <code>n_components</code> 块写入。 对于非块向量， <code>first_index</code> 被忽略了。 <code>mask</code> 可以用来抑制对当前单元向量批中包含的一些单元的写入访问，例如，在本地时间步进的情况下，一些单元被排除在调用之外。 比特集中的 "true "值意味着将处理相应的车道索引，而 "false
"值则跳过该索引。默认设置是一个包含所有1的bitset，它将把累积的积分写到批次中的所有单元。 </p><dl class="section note"><dt>Note</dt><dd>如果这个类是在没有MatrixFree对象的情况下构建的，并且信息是通过 <a class="el" href="group__Iterators.html#ga32b2a057d9abd2e1752bf8a3cb88e644">DoFHandler&lt;dim&gt;::cell_iterator</a>, 来获取的，那么这个类只使用一个单一的单元格，这个函数会提取给定单元格上的底层组件的值。这个调用比通过MatrixFree对象完成的调用要慢，并且导致一个结构在基于这些值的评估例程中不能有效地使用矢量化（相反， <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> 相同的副本被工作）。 </dd></dl>

</div>
</div>
<a id="afc923ce61f6399bcd717ab9f99f62ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc923ce61f6399bcd717ab9f99f62ca0">&#9670;&nbsp;</a></span>set_dof_values_plain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::set_dof_values_plain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code>std::bitset&lt;&#160;VectorizedArrayType::size()&gt;().flip()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与set_dof_values()相同，但不解决约束。 </p>

</div>
</div>
<a id="a0660b27a2a592994dfd2fc917305a3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0660b27a2a592994dfd2fc917305a3ac">&#9670;&nbsp;</a></span>get_dof_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_dof_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回索引为 <code>dof的局部自由度的存储值。如果对象是矢量值的，就会给出一个矢量值的返回参数。因此，参数</code> <code>dof</code> 最多可以运行到 <code>dofs_per_component，而不是</code> <code>dofs_per_cell</code> ，因为矢量值FE的不同成分会一起返回。请注意，当矢量化被启用时，来自几个单元的值被分组在一起。如果 <code>set_dof_values</code> 是最后被调用的，那么该值就对应于那里设置的值。如果 <code>integrate</code> 是最后被调用的，那么它就对应于具有给定索引的测试函数的综合函数的值。 请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 </p>

</div>
</div>
<a id="a3afd9d62f5762c41973aa0f037dc5099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afd9d62f5762c41973aa0f037dc5099">&#9670;&nbsp;</a></span>submit_dof_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_dof_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td>
          <td class="paramname"><em>val_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dof</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>向包含自由度分量的字段写入一个值 <code>dof</code>. 向通过 <code>get_dof_value访问的同一字段写入一个值。因此，一旦提交了一个值，从向量中读取的原始数据就会被覆盖。</code> 请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量值情况（n_components == dim）重载了这个操作。 </p>

</div>
</div>
<a id="aeecc76ffeff6b36816f6af20af1398a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecc76ffeff6b36816f6af20af1398a8">&#9670;&nbsp;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用 <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a> 并设置了 <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> 后，返回正交点号 <code>q_point</code> 处的有限元函数值，或者调用 <a class="el" href="classFEEvaluationBase.html#a2c0efc6f70b305c0585001632063c98b">FEEvaluationBase::submit_value()</a>. 时已经存储在那里的值。 如果对象是矢量值的，将给出一个矢量值的返回参数。注意，当矢量化被启用时，来自几个单元的值被分组在一起。 请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量值情况（n_components == dim）重载了这一操作的特殊性。 </p>

</div>
</div>
<a id="a2c0efc6f70b305c0585001632063c98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0efc6f70b305c0585001632063c98b">&#9670;&nbsp;</a></span>submit_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td>
          <td class="paramname"><em>val_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>向包含正交点上的值的字段写一个值，其成分为 <code>q_point</code>. 通过get_value()访问同一个字段。如果在调用设置了 <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a> 的函数 <a class="el" href="classFEEvaluation.html#ad61cbe0d7d6138be040d46ae06a268f1">FEEvaluation::integrate()</a> 之前应用，这将指定由当前单元上的所有基函数测试并整合的值。 请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 </p>

</div>
</div>
<a id="a132c024aa9243845d3777b227607da6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132c024aa9243845d3777b227607da6b">&#9670;&nbsp;</a></span>get_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_gradient </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在用 <a class="el" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a>, 调用 <a class="el" href="classFEEvaluation.html#a710c252e9dccc0c4ce07044cac3bdd9b">FEEvaluation::evaluate()</a> 后，返回正交点 <code>q_point</code> 的有限元函数梯度，或用 <a class="el" href="classFEEvaluationBase.html#a2a78655d119bd1bde992619c52b2d2f8">FEEvaluationBase::submit_gradient()</a>. 调用后，返回存储在那里的值 注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和矢量情况（n_components == dim）重载了该操作，具有特殊性。 </p>

</div>
</div>
<a id="aee54d24ac9e0dcfe9a4571a6b047cd03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee54d24ac9e0dcfe9a4571a6b047cd03">&#9670;&nbsp;</a></span>get_normal_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_normal_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用 FEEvaluation::evaluate(EvaluationFlags::gradients) 面的法线方向后，返回正交点号 <code>q_point</code> 的有限元函数的导数。 \(\boldsymbol \nabla u(\mathbf x_q) \cdot \mathbf n(\mathbf x_q)\) 这个调用等同于调用get_gradient() <a class="el" href="classFEEvaluationBaseData.html#a264ced911d2818b0a04b8855bb482b45">get_normal_vector()</a>，但将使用更有效的内部数据表示。 请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 </p>

</div>
</div>
<a id="a2a78655d119bd1bde992619c52b2d2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a78655d119bd1bde992619c52b2d2f8">&#9670;&nbsp;</a></span>submit_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a>&#160;</td>
          <td class="paramname"><em>grad_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>写一个贡献，这个贡献被梯度测试到包含分量为 <code>q_point</code>. 的正交点上的值的字段，通过get_gradient()访问同一个字段。如果在函数 FEEvaluation::integrate(EvaluationFlags::gradients) 被调用之前应用，这指定了当前单元上所有基函数梯度测试的内容，并对其进行积分。 请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作，并进行了特殊化处理。 </p>

</div>
</div>
<a id="ad6e7e621190fb28eeeffa58311f711ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e7e621190fb28eeeffa58311f711ce">&#9670;&nbsp;</a></span>submit_normal_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_normal_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a>&#160;</td>
          <td class="paramname"><em>grad_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>编写一个贡献，该贡献由梯度测试到包含分量为 <code>q_point的正交点上的值的域。与通过get_gradient()或get_normal_derivative()访问相同的字段。如果在函数</code> FEEvaluation::integrate(EvaluationFlags::gradients) 被调用之前应用，这指定了当前单元上所有基函数梯度的测试内容，并在此基础上进行积分。 </p><dl class="section note"><dt>Note</dt><dd>这个操作将数据写到与submit_gradient()相同的字段。因此，只能使用这两者中的一个。通常情况下，对这个函数的潜在调用的贡献必须加到submit_gradient()的贡献中。 </dd>
<dd>
派生类FEEvaluationAccess为标量情况（n_components == 1）和矢量情况（n_components == dim）重载了这个操作。 </dd></dl>

</div>
</div>
<a id="af637d7fcd92a58cf1e8597269a13e9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af637d7fcd92a58cf1e8597269a13e9bd">&#9670;&nbsp;</a></span>get_hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, n_components_, <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim, VectorizedArrayType&gt; &gt; <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_hessian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用 FEEvaluation::evaluate(EvaluationFlags::hessians). 后，返回正交点号 <code>q_point</code> 处的有限元函数的Hessian。如果只需要Hessian的对角线甚至跟踪，即拉普拉斯，请使用以下其他函数。 请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 </p>

</div>
</div>
<a id="aaba7f7af4354a4bad6bcf7364978ebf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba7f7af4354a4bad6bcf7364978ebf2">&#9670;&nbsp;</a></span>get_hessian_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a7850917bacc47dc16fb1e5bd491f8e04">gradient_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_hessian_diagonal </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用 FEEvaluation::evaluate(EvaluationFlags::hessians). 后，返回正交点编号为 <code>q_point</code> 的有限元函数的对角线。注意，派生类FEEvaluationAccess对该操作进行了重载，并对标量情况（n_components == 1）和矢量情况（n_components == dim）进行了专业化处理。 </p>

</div>
</div>
<a id="a0c652a4de885613efc5e02dd3754342b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c652a4de885613efc5e02dd3754342b">&#9670;&nbsp;</a></span>get_laplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_laplacian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用 FEEvaluation::evaluate(EvaluationFlags::hessians). 后，返回正交点号 <code>q_point</code> 处的有限元函数的拉普拉斯（即Hessian的踪迹）。 与计算全部Hessian的情况相比，当只要求拉普拉斯时，可以节省一些操作。 请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 </p>

</div>
</div>
<a id="a7f6a0959de5c408072c48ee3fd2ca057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6a0959de5c408072c48ee3fd2ca057">&#9670;&nbsp;</a></span>get_divergence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_divergence </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用 <code>evaluate</code>(...,true,...). 后，返回正交点号 <code>q_point</code> 处的矢量值有限元的发散。 </p><dl class="section note"><dt>Note</dt><dd>仅对n_components_==dim有效。 </dd></dl>

</div>
</div>
<a id="a2b6fe306f7501a59940bfffab2550e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6fe306f7501a59940bfffab2550e6a">&#9670;&nbsp;</a></span>get_symmetric_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim, VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_symmetric_gradient </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用 <code>evaluation</code>(...,true,...)后，返回正交点号 <code>q_point</code> 处的矢量值有限元的对称梯度。它对应于<code>0.5 (grad+grad<sup>T</sup>)</code>。 </p><dl class="section note"><dt>Note</dt><dd>只对n_components_==dim有效。 </dd></dl>

</div>
</div>
<a id="ae036687570ee408ffa461f9c7ae685cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae036687570ee408ffa461f9c7ae685cc">&#9670;&nbsp;</a></span>get_curl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, (dim == 2 ? 1 : dim), VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_curl </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用 <code>evaluate</code>(...,true,...)后，返回矢量场的卷积， \(\nabla \times v\) 。 </p><dl class="section note"><dt>Note</dt><dd>只对n_components_==dim有效。 </dd></dl>

</div>
</div>
<a id="aa0a45432b87f3a6fc20ca91b02d2654d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a45432b87f3a6fc20ca91b02d2654d">&#9670;&nbsp;</a></span>submit_divergence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_divergence </td>
          <td>(</td>
          <td class="paramtype">const VectorizedArrayType&#160;</td>
          <td class="paramname"><em>div_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>写入一个贡献，这个贡献被发散测试到包含组件 <code>q_point</code>. 的正交点上的值的字段，访问与通过 <code>get_gradient</code>. 相同的字段，如果在调用函数 <code>integrate</code>(...,true) 之前应用，这指定了由当前单元上的所有基函数梯度测试并整合的内容。 </p><dl class="section note"><dt>Note</dt><dd>只对n_components_==dim有效。 </dd>
<dd>
该操作将数据写到与submit_gradient()相同的字段。因此，只能使用这两者中的一个。通常情况下，对这个函数的潜在调用的贡献必须加到submit_gradient()的贡献的对角线中。 </dd></dl>

</div>
</div>
<a id="a5b29b531d2d7bfc8596b34f68b6abf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b29b531d2d7bfc8596b34f68b6abf91">&#9670;&nbsp;</a></span>submit_symmetric_gradient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_symmetric_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, VectorizedArrayType &gt;&#160;</td>
          <td class="paramname"><em>grad_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>写入一个贡献，该贡献被对称梯度测试到包含正交点上的值的字段，其分量为 <code>q_point</code>. 通过 <code>get_symmetric_gradient</code>. 访问同一字段 如果在函数 <code>integrate</code>(...,true) 被调用之前应用，这指定了对称梯度，它被当前单元上的所有基函数对称梯度测试并整合到。 </p><dl class="section note"><dt>Note</dt><dd>只对n_components_==dim有效。 </dd>
<dd>
该操作将数据写到与submit_gradient()相同的字段。因此，只能使用这两者中的一个。通常情况下，对这个函数的潜在调用的贡献必须加到submit_gradient()的rank-2张量的相应条目中。 </dd></dl>

</div>
</div>
<a id="af317b2c1e630b328f7738287d3b07ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af317b2c1e630b328f7738287d3b07ae6">&#9670;&nbsp;</a></span>submit_curl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::submit_curl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim==2 ? 1 :dim, VectorizedArrayType &gt;&#160;</td>
          <td class="paramname"><em>curl_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>写下包含正交点上的值的curl的分量 <code>q_point</code>. 通过 <code>get_gradient</code>. 访问同一数据域 </p><dl class="section note"><dt>Note</dt><dd>只对n_components_==dim有效。 </dd>
<dd>
该操作将数据写到与submit_gradient()相同的字段。因此，只能使用这两者中的一个。通常情况下，对这个函数的潜在调用的贡献必须加到submit_gradient()的rank-2张量的相应条目中。 </dd></dl>

</div>
</div>
<a id="ada523fada873497b00071b8b0bc35005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada523fada873497b00071b8b0bc35005">&#9670;&nbsp;</a></span>integrate_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEEvaluationBase.html#a70be2ab5016a1d389fba2a2bfdef3cde">value_type</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::integrate_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>取正交点的值，乘以雅各布行列式和正交权重（JxW），并对单元上所有正交点的值进行求和。其结果是一个标量，代表函数在单元上的积分。如果使用了一个矢量元素，结果的分量仍然是分开的。此外，如果启用了矢量化，几个单元的积分值将包含在返回的VectorizedArray字段的槽中。 </p><dl class="section note"><dt>Note</dt><dd>如果FEEvaluation对象被初始化为一批单元，在SIMD向量VectorizedArray中并非所有的通道都代表实际数据，这个方法在虚拟数据（从最后一个有效通道复制的）上执行计算，将没有意义。因此，用户需要确保在任何计算中不明确地使用它，比如在对几个单元格的结果求和时。 </dd></dl>

</div>
</div>
<a id="a6998ba7c39eeed60574b25f366184d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6998ba7c39eeed60574b25f366184d0b">&#9670;&nbsp;</a></span>begin_dof_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_dof_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向dof值的第一个字段的只读指针。这是read_dof_values()函数写进的数据字段。首先是第一个组件的dof值，然后是第二个组件的所有值，以此类推。这与这个类中使用的内部数据结构有关。一般来说，使用get_dof_value()函数来代替比较安全。 </p>

</div>
</div>
<a id="a54213aa80599acf803a3b7c4c487fd38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54213aa80599acf803a3b7c4c487fd38">&#9670;&nbsp;</a></span>begin_dof_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_dof_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向dof值的第一个字段的读写指针。 这是read_dof_values()函数写进的数据字段。首先是第一个组件的dof值，然后是第二个组件的所有值，以此类推。这与这个类中使用的内部数据结构有关。一般来说，使用get_dof_value()函数来代替比较安全。 </p>

</div>
</div>
<a id="ac0738826a83db1d28cad958e478f3e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0738826a83db1d28cad958e478f3e27">&#9670;&nbsp;</a></span>begin_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向正交点上函数值第一域的只读指针。首先是第一个分量的所有正交点上的函数值，然后是第二个分量的所有数值，以此类推。这与本类中使用的内部数据结构有关。调用 <code>evaluate</code> 后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_value()函数反而更安全，它在内部完成所有的转换。 </p>

</div>
</div>
<a id="a8e58470a54179126fe601d26f0088bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e58470a54179126fe601d26f0088bdb">&#9670;&nbsp;</a></span>begin_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向正交点上的函数值的第一个字段的读和写指针。首先是第一个分量的所有正交点上的函数值，然后是第二个分量的所有数值，以此类推。这与本类中使用的内部数据结构有关。调用 <code>evaluate</code> 后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_value()函数反而更安全，它在内部完成所有的转换。 </p>

</div>
</div>
<a id="ac9651d02f2fe8a7133867c92fc8f327b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9651d02f2fe8a7133867c92fc8f327b">&#9670;&nbsp;</a></span>begin_gradients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_gradients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向正交点上的函数梯度的第一个字段的只读指针。首先是所有正交点上第一个分量的梯度的x分量，然后是y分量，以此类推。接下来是第二个分量的x分量，以此类推。这与本类中使用的内部数据结构有关。调用 <code>evaluate</code> 后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_gradient()函数反而更安全，它在内部完成所有的变换。 </p>

</div>
</div>
<a id="a1f03eb49fe21f5a2eda31c07d3052330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f03eb49fe21f5a2eda31c07d3052330">&#9670;&nbsp;</a></span>begin_gradients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_gradients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向正交点上函数梯度第一域的读写指针。首先是所有正交点上第一个分量的梯度的x分量，然后是y分量，以此类推。接下来是第二个分量的x分量，以此类推。这与本类中使用的内部数据结构有关。调用 <code>evaluate</code> 后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_gradient()函数反而更安全，它在内部完成所有的变换。 </p>

</div>
</div>
<a id="a7bce79fd87c41b7fee59627b4a452125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bce79fd87c41b7fee59627b4a452125">&#9670;&nbsp;</a></span>begin_hessians() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_hessians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个只读指针，指向正交点上的函数 hessians 的第一个字段。首先是所有正交点上第一个分量的 hessians 的 xx-分量，然后是 yy-分量，zz-分量（3D），然后是 xy-分量，以此类推。接下来是第二个分量的xx-分量，以此类推。这与本类中使用的内部数据结构有关。调用 <code>evaluate</code> 后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_laplacian()或get_hessian()函数来代替比较安全，它在内部完成所有的变换。 </p>

</div>
</div>
<a id="a2b0a3def7f22c396ce2884e37b4aa788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0a3def7f22c396ce2884e37b4aa788">&#9670;&nbsp;</a></span>begin_hessians() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::begin_hessians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个读写指针，指向正交点上的函数hesians的第一个字段。首先是所有正交点上第一个分量的 hessians 的 xx-分量，然后是 yy-分量，zz-分量（3D），然后是 xy-分量，以此类推。接下来是第二个分量的xx-分量，以此类推。这与本类中使用的内部数据结构有关。调用 <code>evaluate</code> 后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_laplacian()或get_hessian()函数来代替比较安全，它在内部完成所有的变换。 </p>

</div>
</div>
<a id="a68204d97bb4207d522522f0d624213dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68204d97bb4207d522522f0d624213dc">&#9670;&nbsp;</a></span>get_first_selected_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::get_first_selected_component </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回第一个选定的分量。 </p>

</div>
</div>
<a id="a27779f5e7ac08bcc8c3fd1d78698ad45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27779f5e7ac08bcc8c3fd1d78698ad45">&#9670;&nbsp;</a></span>read_write_operation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType , typename VectorOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_write_operation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const typename VectorType::value_type &gt;&gt; *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>apply_constraints</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个统一的函数，根据给定的模板操作从向量中读出和写入向量。它可以对 <code>read_dof_values</code>, <code>distribute_local_to_global</code>, 和 <code>set_dof_values</code>. 进行操作，一次对几个向量进行操作。 </p>

</div>
</div>
<a id="a427af54345534f8d734230ad56d4a367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427af54345534f8d734230ad56d4a367">&#9670;&nbsp;</a></span>read_write_operation_contiguous()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType , typename VectorOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_write_operation_contiguous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const typename VectorType::value_type &gt;&gt; *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors_sm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::bitset&lt; VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个统一的函数，基于给定的模板操作从向量中读出和写入向量，用于DG型方案，其中单元格上的所有自由度是连续的。它可以一次对多个向量进行read_dof_values()、distribut_local_to_global()和set_dof_values()的操作，具体取决于n_components。 </p>

</div>
</div>
<a id="a06b9198e9b8d3306e7b9fc7ebffb7077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b9198e9b8d3306e7b9fc7ebffb7077">&#9670;&nbsp;</a></span>read_write_operation_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType , typename VectorOperation &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::read_write_operation_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html">VectorOperation</a> &amp;&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classVectorType.html">VectorType</a> *, n_components_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>vectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个统一的函数，在我们没有底层MatrixFree对象的情况下，根据给定的模板操作从向量中读取和写入向量。它可以对 <code>read_dof_values</code>, <code>distribute_local_to_global</code>, 和 <code>set_dof_values</code>. 进行操作。 它一次对几个向量进行操作，取决于n_components。 </p>

</div>
</div>
<a id="a41b715f55152c25bf40e8a588f2d71e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b715f55152c25bf40e8a588f2d71e3">&#9670;&nbsp;</a></span>get_mapping_data_index_offset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_mapping_data_index_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code><a class="el" href="classFEEvaluation.html#a5e77cd8900f05a73a91ca8edf31f4a91">reinit()</a>函数所调用的单元格在几何字段中的索引偏移。这个索引可以用来访问一个字段的索引，这个字段的压缩行为与几何体的Jacobian相同，例如，存储一个有效的系数tensors，将系数与几何体结合起来，以降低内存传输，作为可用的数据字段。</code> </p>

</div>
</div>
<a id="a377d660719169078d812bf611bd75f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377d660719169078d812bf611bd75f13">&#9670;&nbsp;</a></span>get_cell_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__matrixfree.html#gae024b29b6819e727d47016c6b6b53d8c">internal::MatrixFreeFunctions::GeometryType</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_cell_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code><a class="el" href="classFEEvaluation.html#a5e77cd8900f05a73a91ca8edf31f4a91">reinit()</a></code> 函数被调用的单元格的类型。 有效值是 <code>cartesian</code> 用于笛卡尔单元（允许相当大的数据压缩）， <code>affine</code> 用于具有仿射映射的单元， <code>general</code> 用于没有应用任何压缩存储的一般单元。 </p>

</div>
</div>
<a id="a3795cfb954ce2b37a130265c51eba552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3795cfb954ce2b37a130265c51eba552">&#9670;&nbsp;</a></span>get_shape_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;VectorizedArrayType&gt;&amp; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_shape_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前正在使用的ShapeInfo对象的引用。 </p>

</div>
</div>
<a id="a664645e91bbe5f972a1d9b6c64ab5e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664645e91bbe5f972a1d9b6c64ab5e9b">&#9670;&nbsp;</a></span>get_dof_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a>&amp; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_dof_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前正在使用的DoFInfo对象的引用。 </p>

</div>
</div>
<a id="a56ed5a4e84edf92e69f1474d5f035a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ed5a4e84edf92e69f1474d5f035a92">&#9670;&nbsp;</a></span>JxW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::JxW </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回从单位到实数单元的雅各布系数乘以正交权重的行列式。 </p>

</div>
</div>
<a id="adad456112f01b19291e7781fb5efee55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad456112f01b19291e7781fb5efee55">&#9670;&nbsp;</a></span>inverse_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;2, dim, VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::inverse_jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回定义为 \(J_{ij} = d x_i / d\hat x_j\) 的单位到实数单元之间映射的雅各布系数的反转和转置版本 \(J^{-\mathrm T}\) 。返回张量的 \((i,j)\) 项包含 \(d\hat x_j/dx_i\) ，即列是指参考空间坐标，行是指实单元坐标。因此，返回的张量代表一个协变变换，在 <a class="el" href="classFEEvaluationBase.html#a132c024aa9243845d3777b227607da6b">FEEvaluationBase::get_gradient()</a> 函数中用于通过乘法 \(J^{-\mathrm T} \hat{\nabla} u_h\) 将单元格梯度转换为实单元格上的梯度。 </p>

</div>
</div>
<a id="a264ced911d2818b0a04b8855bb482b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264ced911d2818b0a04b8855bb482b45">&#9670;&nbsp;</a></span>get_normal_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_normal_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个面的单位法向量。注意，一个面的两边都使用相同方向的法向量。对于在FaceToCellTopology中被列举为 "内部 "并在构造函数中被选择为 "is_interior_face=true
"的面，这对应于外部法向量，而对于在FaceToCellTopology中被列举为 "外部 "并在构造函数中被选择为 "is_interior_face=false
"的面，作为单一法向量的结果，法向量指向该元素中。 </p><dl class="section note"><dt>Note</dt><dd>只在<code>is_face == true</code>的情况下实现。 </dd></dl>

</div>
</div>
<a id="a7c966665f040d92b055833c8011b395a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c966665f040d92b055833c8011b395a">&#9670;&nbsp;</a></span>read_cell_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::read_cell_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>提供一个统一的接口来访问长度为 <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a> + <a class="el" href="classMatrixFree.html#a0c08e4ba63acbb93d0f3a1441b88d61c">MatrixFree::n_ghost_cell_batches()</a> 的向量Array字段中的数据，用于单元（普通读取）和面（间接寻址）。 </p>

</div>
</div>
<a id="ae6891d7f5fe2282a3ff1ca56042d57d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6891d7f5fe2282a3ff1ca56042d57d6">&#9670;&nbsp;</a></span>read_cell_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, VectorizedArrayType::size()&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::read_cell_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; std::array&lt; T, VectorizedArrayType::size()&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上述相同，只是对于任意数据类型的VectorizedArrayType的长度 std::array 。 </p>

</div>
</div>
<a id="a152c28d13aca3d409052d7f7a0634eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152c28d13aca3d409052d7f7a0634eb0">&#9670;&nbsp;</a></span>set_cell_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::set_cell_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; VectorizedArrayType &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorizedArrayType &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为单元格（明读）和面（间接寻址）提供一个统一的接口来设置长度为 <a class="el" href="classMatrixFree.html#a8c9d964339b466bdcb661552e731e222">MatrixFree::n_cell_batches()</a> + <a class="el" href="classMatrixFree.html#a0c08e4ba63acbb93d0f3a1441b88d61c">MatrixFree::n_ghost_cell_batches()</a> 的矢量Array字段中的数据。 </p>

</div>
</div>
<a id="ac7feb6cd1b095d992c54dd5fac244586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7feb6cd1b095d992c54dd5fac244586">&#9670;&nbsp;</a></span>set_cell_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::set_cell_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; std::array&lt; T, VectorizedArrayType::size()&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, VectorizedArrayType::size()&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>和上面一样，只是对于任意数据类型的VectorizedArrayType的长度为 std::array 。 </p>

</div>
</div>
<a id="a2729f97a9d471169afe63cede6596a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2729f97a9d471169afe63cede6596a74">&#9670;&nbsp;</a></span>get_cell_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_cell_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个FEEvaluation或FEFaceEvaluation所关联的单元格的id。 </p>

</div>
</div>
<a id="a77d73c4fd5e79970f465b603adf116d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d73c4fd5e79970f465b603adf116d6">&#9670;&nbsp;</a></span>get_cell_or_face_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;unsigned <a class="el" href="classint.html">int</a>, VectorizedArrayType::size()&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_cell_or_face_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回与此FEEvaluation/FEFaceEvaluation相关的单元格/面的id。 </p>

</div>
</div>
<a id="a575a078b24cb2107fce967db6ebedb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575a078b24cb2107fce967db6ebedb1f">&#9670;&nbsp;</a></span>get_internal_dof_numbering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt;&amp; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_internal_dof_numbering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回FEEvaluation的评估程序中局部自由度的编号，以有限元的标准编号为准。 </p>

</div>
</div>
<a id="a68af54c4af89af574d1304bfc59f2637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68af54c4af89af574d1304bfc59f2637">&#9670;&nbsp;</a></span>get_scratch_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayView.html">ArrayView</a>&lt;VectorizedArrayType&gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_scratch_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个ArrayView到内部内存，供临时使用。注意，在evaluation()和integration()调用过程中，这部分内存会被覆盖，所以不要认为它在这些调用中是稳定的。你可以写入的最大容量是3*dofs_per_cell+2*n_q_points。 </p>

</div>
</div>
<a id="aa1a6490549baa849bf4aaaab72ed4ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a6490549baa849bf4aaaab72ed4ecb">&#9670;&nbsp;</a></span>get_quadrature_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_quadrature_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前单元格的正交公式的编号。 </p>

</div>
</div>
<a id="a6874c90c1c3f54737636cd30b46ffe47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6874c90c1c3f54737636cd30b46ffe47">&#9670;&nbsp;</a></span>get_current_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_current_cell_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前单元格或面的索引。 </p>

</div>
</div>
<a id="aed217341425d1b85c6d2e67932af9853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed217341425d1b85c6d2e67932af9853">&#9670;&nbsp;</a></span>get_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_active_fe_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该类的活动FE索引，以便在hp-情况下有效地进行索引。 </p>

</div>
</div>
<a id="a6f979d70d5d3e16037ed0f3ae36f6b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f979d70d5d3e16037ed0f3ae36f6b6f">&#9670;&nbsp;</a></span>get_active_quadrature_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_active_quadrature_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该类的活动正交索引，以便在hp情况下有效地进行索引。 </p>

</div>
</div>
<a id="a8b0c8e96fd4c18b29c6cddb1e648c66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0c8e96fd4c18b29c6cddb1e648c66d">&#9670;&nbsp;</a></span>get_matrix_free()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt;dim, Number, VectorizedArrayType&gt;&amp; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::get_matrix_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回底层的MatrixFree对象。 </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab1703665b25c71fb904234e06843b14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1703665b25c71fb904234e06843b14a">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>作为模板参数给出的尺寸。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02180">2180</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ad87ecbe1b7e87f0b45b56d7434061c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87ecbe1b7e87f0b45b56d7434061c71">&#9670;&nbsp;</a></span>n_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::n_components = n_components_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>作为模板参数给定的评估器的解决方案组件的数量。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02186">2186</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ae61bbe0f675fe4561ecad32ef352478e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61bbe0f675fe4561ecad32ef352478e">&#9670;&nbsp;</a></span>static_n_q_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::static_n_q_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(n_q_points_1d, dim)</div></div><!-- fragment --><p>从给定的模板参数<code>n_q_points_1d</code>确定的正交点的静态数量。请注意，如果给定了<code>fe_degree=-1</code>，并且使用了运行时的循环长度而不是编译时的循环长度，那么实际的正交点数量<code>n_q_points</code>可能不同。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02192">2192</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="afd09f7ef0d2176787b3705d3b124a734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd09f7ef0d2176787b3705d3b124a734">&#9670;&nbsp;</a></span>static_dofs_per_component</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::static_dofs_per_component</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim)</div></div><!-- fragment --><p>根据给定的模板参数<code>fe_degree</code>确定的标量分量的静态自由度数。请注意，如果给定了<code>fe_degree=-1</code>，或者如果底层的类型比通常的FE_Q或FE_DGQ更复杂，如FE_DGP，那么实际的自由度<code>dofs_per_component</code>可能会不同。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02199">2199</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a7633347d0c75761dc6c785d7efd7f50f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7633347d0c75761dc6c785d7efd7f50f">&#9670;&nbsp;</a></span>tensor_dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::tensor_dofs_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="classFEEvaluation.html#afd09f7ef0d2176787b3705d3b124a734">static_dofs_per_component</a> * <a class="code" href="classFEEvaluation.html#ad87ecbe1b7e87f0b45b56d7434061c71">n_components</a></div></div><!-- fragment --><p>根据给定的模板参数<code>fe_degree</code>确定的所有组件的静态自由度数。请注意，如果给定了<code>fe_degree=-1</code>，或者如果底层的类型比通常的FE_Q或FE_DGQ更复杂，比如FE_DGP，那么实际的自由度<code>dofs_per_cell</code>可能会不同。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02206">2206</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="abda989191e3ba8ff33319ea4c165fb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda989191e3ba8ff33319ea4c165fb3a">&#9670;&nbsp;</a></span>static_dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::static_dofs_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="classFEEvaluation.html#afd09f7ef0d2176787b3705d3b124a734">static_dofs_per_component</a> * <a class="code" href="classFEEvaluation.html#ad87ecbe1b7e87f0b45b56d7434061c71">n_components</a></div></div><!-- fragment --><p>根据给定的模板参数<code>fe_degree</code>确定的所有组件的静态自由度数。请注意，如果给定了<code>fe_degree=-1</code>，或者如果底层的类型比通常的FE_Q或FE_DGQ更复杂，比如FE_DGP，那么实际的自由度<code>dofs_per_cell</code>可能会不同。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02213">2213</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a082b0d1473bdd532be243d3b03073847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082b0d1473bdd532be243d3b03073847">&#9670;&nbsp;</a></span>dofs_per_component</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::dofs_per_component</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>底层评价对象的单元上的单个组件的自由度数。通常接近static_dofs_per_component，但这个数字取决于实际选择的元素，因此不是静态的。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02490">2490</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ab89db52bf6207863f14325522f8d229a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89db52bf6207863f14325522f8d229a">&#9670;&nbsp;</a></span>dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::dofs_per_cell</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>单元上的自由度数量在当前评估对象的所有元件上累积。通常接近static_dofs_per_cell = static_dofs_per_component*n_components，但这个数字取决于所选择的实际元素，因此不是静态的。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02498">2498</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a1b8934d6ae273d7b3f91994eddcad239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8934d6ae273d7b3f91994eddcad239">&#9670;&nbsp;</a></span>n_q_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int fe_degree, int n_q_points_1d, int n_components_, typename Number, typename VectorizedArrayType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluation.html">FEEvaluation</a>&lt; dim, fe_degree, n_q_points_1d, n_components_, Number, VectorizedArrayType &gt;::n_q_points</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用中的正交点的数量。如果1d中的正交点数量是作为模板给出的，这个数字只是该值的<code>dim</code>-次幂。如果元素度数被设置为</p>
<p>-（元素度的动态选择），正交点的静态值就不准确了，必须用这个值来代替。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l02506">2506</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aacafd9861301674853b127a115d4de1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacafd9861301674853b127a115d4de1e">&#9670;&nbsp;</a></span>values_dofs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::values_dofs[<a class="el" href="classFEEvaluation.html#ad87ecbe1b7e87f0b45b56d7434061c71">n_components</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个字段存储了局部自由度的值（例如，从矢量中读出后，但在应用单元格变换前或在将它们分配到结果矢量中之前）。get_dof_value()和submit_dof_value()方法从这个字段读取或写入。 这个数组的值存储在 <code>scratch_data_array</code>. 的起始部分。由于其作为线程本地内存的访问，该内存可以在不同的调用之间得到重复使用。相对于在堆栈上请求内存，这种方法允许非常大的多项式程度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01096">1096</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aa2b01fcfb319697ad15319c44d635358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b01fcfb319697ad15319c44d635358">&#9670;&nbsp;</a></span>values_quad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::values_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个字段存储了应用单元格变换后或积分前正交点上的有限元函数的值。 <a class="el" href="classFEEvaluationBase.html#aeecc76ffeff6b36816f6af20af1398a8">get_value()</a>和submit_value()方法访问这个字段。 这个数组的值存储在 <code>scratch_data_array</code>. 的起始部分。由于其作为线程本地内存的访问，内存可以在不同的调用之间得到重复使用。相对于在堆栈上请求内存，这种方法允许非常大的多项式程度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01105">1105</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a01c0240702f8a5f1bcd102ef69919b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c0240702f8a5f1bcd102ef69919b54">&#9670;&nbsp;</a></span>gradients_quad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::gradients_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个字段存储了应用单元格变换后或积分前正交点上的有限元函数的梯度。get_gradient()和submit_gradient()方法（以及一些特殊的方法如get_symmetric_gradient()或get_divergence()）访问这个字段。 这个数组的值存储在 <code>scratch_data_array</code>. 的起始部分。由于它作为线程本地内存的访问，内存可以在不同的调用之间得到重复使用。相对于在堆栈上请求内存，这种方法允许非常大的多项式程度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01113">1113</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aca7ce5837713e301d3e8c4718fdcce67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7ce5837713e301d3e8c4718fdcce67">&#9670;&nbsp;</a></span>hessians_quad</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::hessians_quad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个字段存储了应用单元格变换后正交点上的有限元函数的Hessians。get_hessian(), <a class="el" href="classFEEvaluationBase.html#a0c652a4de885613efc5e02dd3754342b">get_laplacian()</a>, <a class="el" href="classFEEvaluationBase.html#aaba7f7af4354a4bad6bcf7364978ebf2">get_hessian_diagonal()</a>方法访问这个字段。 这个数组的值存储在 <code>scratch_data_array</code>. 的起始部分。由于其作为线程本地内存的访问，该内存可以在不同的调用之间得到重复使用。相对于在堆栈上请求内存，这种方法允许非常大的多项式程度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01122">1122</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ad363fb71770ee9f1b521e5a539993ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad363fb71770ee9f1b521e5a539993ef3">&#9670;&nbsp;</a></span>n_fe_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::n_fe_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储在MatrixFree存储类中检测到的有限元中的组件数量，以便与模板参数进行比较。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01128">1128</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a4931bf96a90394aa552231bfc3d4bb80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4931bf96a90394aa552231bfc3d4bb80">&#9670;&nbsp;</a></span>dof_values_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::dof_values_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调试信息，跟踪dof值在访问前是否已被初始化。当使用未初始化的数据时，用于控制异常。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01134">1134</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a2634b8199be6e9fdec0b0ad715209a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2634b8199be6e9fdec0b0ad715209a39">&#9670;&nbsp;</a></span>values_quad_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::values_quad_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调试信息，跟踪正交点的值在访问前是否已经被初始化。用于控制使用未初始化数据时的异常情况。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01140">1140</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="af15f3fb86bd795ee059be4accef81ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15f3fb86bd795ee059be4accef81ca8">&#9670;&nbsp;</a></span>gradients_quad_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::gradients_quad_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调试信息，跟踪正交点上的梯度是否在访问前被初始化。用于控制使用未初始化数据时的异常情况。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01146">1146</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a510ed69b6143a1a497c41c93a200a39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510ed69b6143a1a497c41c93a200a39d">&#9670;&nbsp;</a></span>hessians_quad_initialized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::hessians_quad_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调试信息，跟踪正交点上的Hessians在访问前是否已经被初始化。用于控制使用未初始化数据时的异常情况。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01152">1152</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ad53e482c5d5eb5b156e79d322f7fdf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53e482c5d5eb5b156e79d322f7fdf12">&#9670;&nbsp;</a></span>values_quad_submitted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::values_quad_submitted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调试信息跟踪正交点上的值是否在实际盯住积分之前被提交给了积分。用于控制使用未初始化数据时的异常情况。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01158">1158</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a747a9ff4cbaedd9b48f7aa1378e2682c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747a9ff4cbaedd9b48f7aa1378e2682c">&#9670;&nbsp;</a></span>gradients_quad_submitted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::gradients_quad_submitted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>调试信息，跟踪正交点的梯度在积分实际被盯住之前是否已被提交用于积分。 用于控制使用未初始化数据时的异常情况。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01165">1165</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a42f9032a1a57f19c6e21915eaee09716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f9032a1a57f19c6e21915eaee09716">&#9670;&nbsp;</a></span>first_selected_component</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::first_selected_component</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于一个有多个基元的FiniteElement，选择这个数据结构应该从哪个分量开始。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01171">1171</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a3cd8d38b99b2e85efbc37570c76d0def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd8d38b99b2e85efbc37570c76d0def">&#9670;&nbsp;</a></span>local_dof_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int n_components_, typename Number, bool is_face = false, typename VectorizedArrayType = VectorizedArray&lt;Number&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&gt; <a class="el" href="classFEEvaluationBase.html">FEEvaluationBase</a>&lt; dim, n_components_, Number, is_face, VectorizedArrayType &gt;::local_dof_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当初始化时没有给出MatrixFree对象时，需要一个临时数据结构来读取自由度。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l01177">1177</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ad9c8dcc076400f538a3c85a5cbec9cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c8dcc076400f538a3c85a5cbec9cb3">&#9670;&nbsp;</a></span>scratch_data_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::scratch_data_array</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是所有数据字段的一般阵列。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00325">325</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="af35283bcccba5587bff326a245d322e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35283bcccba5587bff326a245d322e7">&#9670;&nbsp;</a></span>scratch_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::scratch_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是 scratch_data_array 中用户可见的部分，只显示 scratch_data_array 的最后一部分。第一部分被 values_dofs, values_quad 等消耗了。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00333">333</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a533b073ea515b343f9d785da2f342066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533b073ea515b343f9d785da2f342066">&#9670;&nbsp;</a></span>quad_no</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::quad_no</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>本单元格的正交公式的编号。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00339">339</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="af0d19d2e454832346b9ae547f0330533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d19d2e454832346b9ae547f0330533">&#9670;&nbsp;</a></span>matrix_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt;dim, Number, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::matrix_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向基础数据的指针。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00345">345</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="adfa7522a2f5003b7aefa14209ccd4723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa7522a2f5003b7aefa14209ccd4723">&#9670;&nbsp;</a></span>dof_info</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html">internal::MatrixFreeFunctions::DoFInfo</a>* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::dof_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向底层DoF指数和约束描述的指针，用于构造时指定的组件。也包含在matrix_info中，但是如果我们存储一个对它的引用，可以简化代码。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00351">351</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a8c31ae7463c9952de2b8edb01a942938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c31ae7463c9952de2b8edb01a942938">&#9670;&nbsp;</a></span>mapping_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfoStorage.html">internal::MatrixFreeFunctions::MappingInfoStorage</a>&lt; (is_face ? dim - 1 : dim), dim, Number, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::mapping_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向结构中指定的正交公式从单位到实数单元的基础转换数据的指针。也包含在matrix_info中，但如果我们存储对它的引用，可以简化代码。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00361">361</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="afa5f9995bfa3e160a8e111837e4293c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5f9995bfa3e160a8e111837e4293c9">&#9670;&nbsp;</a></span>active_fe_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::active_fe_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该类的活动FE索引，用于在hp情况下的有效索引。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00367">367</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a15d55c8a88a0a393b7eec7a2843cc9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d55c8a88a0a393b7eec7a2843cc9bd">&#9670;&nbsp;</a></span>active_quad_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::active_quad_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该类的活动正交索引，用于在hp情况下的有效索引。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00373">373</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a0d0ee194a86f8af161dbb74c8580fc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0ee194a86f8af161dbb74c8580fc30">&#9670;&nbsp;</a></span>descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1MappingInfoStorage.html">internal::MatrixFreeFunctions::MappingInfoStorage</a>&lt; (is_face ? dim - 1 : dim), dim, Number, VectorizedArrayType&gt;::QuadratureDescriptor* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::descriptor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向构造时指定的底层正交公式的指针。 也包含在matrix_info中，但是如果我们存储一个对它的引用，可以简化代码。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00384">384</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a748b05799b1fdcda8e1bef6ac563b119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748b05799b1fdcda8e1bef6ac563b119">&#9670;&nbsp;</a></span>n_quadrature_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::n_quadrature_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当前评估环境中正交点的数量。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00390">390</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a5d9ba9049f2df1bc4ef95ae789faf12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9ba9049f2df1bc4ef95ae789faf12e">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1ShapeInfo.html">internal::MatrixFreeFunctions::ShapeInfo</a>&lt;VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向单元格形状数据的指针，即构成张量积的正交点的值、梯度和一维的Hessians。也包含在matrix_info中，但是如果我们存储一个对它的引用，可以简化代码。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00396">396</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a421376c6f8ddefa1797a58e8f9003e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421376c6f8ddefa1797a58e8f9003e7b">&#9670;&nbsp;</a></span>jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;2, dim, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::jacobian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向当前单元格的雅各布信息的指针。只有在非卡尔蒂斯单元上才设置为有用的值。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00402">402</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="abb54ca45a7f4e02fc77d8651f08af427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb54ca45a7f4e02fc77d8651f08af427">&#9670;&nbsp;</a></span>J_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorizedArrayType* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::J_value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向当前单元格的雅各布行列式的指针。如果在笛卡尔单元或具有恒定雅各布系数的单元上，这只是雅各布行列式，否则就是雅各布行列式乘以正交权。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00408">408</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a7cd6146dc538c94a881eb0a6b216f313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd6146dc538c94a881eb0a6b216f313">&#9670;&nbsp;</a></span>normal_vectors</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::normal_vectors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向面的法向量的指针。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00414">414</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a2b06df026ae07f6b6a0b96c7395985d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b06df026ae07f6b6a0b96c7395985d9">&#9670;&nbsp;</a></span>normal_x_jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, dim, VectorizedArrayType&gt;* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::normal_x_jacobian</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向面的法向量乘以雅各布式的指针。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00420">420</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a5b872287e6c00c65b77919e58c2fe64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b872287e6c00c65b77919e58c2fe64c">&#9670;&nbsp;</a></span>quadrature_weights</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::quadrature_weights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向基础正交公式的正交权重的指针。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00426">426</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="aba2db8170a4e834313fa1775d50c26a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2db8170a4e834313fa1775d50c26a2">&#9670;&nbsp;</a></span>cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用reinit()后，存储我们当前正在处理的单元格的编号。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00432">432</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a1dc1a1074ec29081286adcbff30844fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc1a1074ec29081286adcbff30844fe">&#9670;&nbsp;</a></span>is_interior_face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::is_interior_face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据定义的法线方向，保存一个面是内部还是外部面的信息的标志。 不用于单元格。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00439">439</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="ab5c4f195d4895c0b57af17a71ee6718c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c4f195d4895c0b57af17a71ee6718c">&#9670;&nbsp;</a></span>dof_access_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinternal_1_1MatrixFreeFunctions_1_1DoFInfo.html#a05d58d76ae885e59efcf6a0c307d744e">internal::MatrixFreeFunctions::DoFInfo::DoFAccessIndex</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::dof_access_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储FEFaceEvaluation对象当前所指向的索引（内部面、外部面、与单元格相关的数据）。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00445">445</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a04643788ab09d99f9d107c4b6879d6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04643788ab09d99f9d107c4b6879d6b1">&#9670;&nbsp;</a></span>face_no</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::face_no</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在<code>is_face==true'的情况下，存储给定单元格内一个面的当前编号，使用</code>0'到`2*dim'之间的值。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00451">451</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a4a69d8b541c14cc64cc2626d3884dfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a69d8b541c14cc64cc2626d3884dfb3">&#9670;&nbsp;</a></span>face_orientation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::face_orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储给定的面相对于标准方向的方向，如果在标准方向，则为0。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00457">457</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a170d149afc7b1e8d7315c3038ddd0aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170d149afc7b1e8d7315c3038ddd0aec">&#9670;&nbsp;</a></span>subface_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::subface_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储给定面的子面索引。通常情况下，这个变量的值为 <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> ，以表示对整个面的整合，但如果当前的物理面有一个更精细的邻居，它就是一个子面，必须适当地缩放ShapeInfo中的条目。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00465">465</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a50c75f69107df221620b6dcbc292065d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c75f69107df221620b6dcbc292065d">&#9670;&nbsp;</a></span>cell_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__matrixfree.html#gae024b29b6819e727d47016c6b6b53d8c">internal::MatrixFreeFunctions::GeometryType</a> <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::cell_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在调用reinit()后，存储我们当前正在处理的单元格的类型。有效值是 <code>cartesian</code>, <code>affine</code> 和 <code>general</code>, ，它们对MappingInfo中的雅各布变换的内部存储方式有不同的影响。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00473">473</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<a id="a6bc1956583b69b8f1010da1dbce26403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc1956583b69b8f1010da1dbce26403">&#9670;&nbsp;</a></span>mapped_geometry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number, bool is_face, typename VectorizedArrayType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;internal::MatrixFreeFunctions:: MappingDataOnTheFly&lt;dim, Number, VectorizedArrayType&gt; &gt; <a class="el" href="classFEEvaluationBaseData.html">FEEvaluationBaseData</a>&lt; dim, Number, is_face, VectorizedArrayType &gt;::mapped_geometry</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>可以用各自的构造函数在空中生成FEValues的几何数据。 </p>

<p class="definition">Definition at line <a class="el" href="fe__evaluation_8h_source.html#l00481">481</a> of file <a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/matrix_free/<a class="el" href="fe__evaluation_8h_source.html">fe_evaluation.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
