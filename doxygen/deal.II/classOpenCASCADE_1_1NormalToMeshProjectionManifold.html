<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classOpenCASCADE_1_1NormalToMeshProjectionManifold.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a></li><li class="navelem"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">NormalToMeshProjectionManifold</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classOpenCASCADE_1_1NormalToMeshProjectionManifold-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="opencascade_2manifold__lib_8h_source.html">deal.II/opencascade/manifold_lib.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classOpenCASCADE_1_1NormalToMeshProjectionManifold__inherit__graph.svg" width="227" height="306"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> = std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face &gt;</td></tr>
<tr class="separator:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeff36847ec5e33a8c3991e5b8f1d1000"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#aeff36847ec5e33a8c3991e5b8f1d1000">NormalToMeshProjectionManifold</a> (const TopoDS_Shape &amp;<a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a755848f8afbc45f2678fbd83e13f07fa">sh</a>, const <a class="el" href="classdouble.html">double</a> <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a69c47c9668f39a2c99a9570ffc1aaaa9">tolerance</a>=1e-7)</td></tr>
<tr class="separator:aeff36847ec5e33a8c3991e5b8f1d1000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2962f36ba381305e0cfae7f549b17024"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a2962f36ba381305e0cfae7f549b17024">clone</a> () const override</td></tr>
<tr class="separator:a2962f36ba381305e0cfae7f549b17024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd1803613a175dd616669290bb12629"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">project_to_manifold</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;candidate) const override</td></tr>
<tr class="separator:a9dd1803613a175dd616669290bb12629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ade4bf6598dda23e36f95a46fa026e7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a6ade4bf6598dda23e36f95a46fa026e7">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const override</td></tr>
<tr class="separator:a6ade4bf6598dda23e36f95a46fa026e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bffbfe9f60ee0cf9d8bb9bfd7f8384"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a10bffbfe9f60ee0cf9d8bb9bfd7f8384">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; new_points) const override</td></tr>
<tr class="separator:a10bffbfe9f60ee0cf9d8bb9bfd7f8384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eec4132f6d653dea1380f7d587ecdf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#ab5eec4132f6d653dea1380f7d587ecdf">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x2) const override</td></tr>
<tr class="separator:ab5eec4132f6d653dea1380f7d587ecdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab60f221758b3a32a596dde96fc1188c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">normal_vector</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const override</td></tr>
<tr class="separator:aab60f221758b3a32a596dde96fc1188c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355608da9555e9e88ea4b2af47be1c26"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a355608da9555e9e88ea4b2af47be1c26">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, typename <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const override</td></tr>
<tr class="separator:a355608da9555e9e88ea4b2af47be1c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774ebed8185bc73b049665b62df23e90"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html#a774ebed8185bc73b049665b62df23e90">get_periodicity</a> () const</td></tr>
<tr class="separator:a774ebed8185bc73b049665b62df23e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing normal vectors</div></td></tr>
<tr class="memitem:a684ad0b97b0f225eb4eb7ee04ab41d7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a684ad0b97b0f225eb4eb7ee04ab41d7e">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const</td></tr>
<tr class="separator:a684ad0b97b0f225eb4eb7ee04ab41d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing the location of points.</div></td></tr>
<tr class="memitem:a8a2c4e2d796956ec3eb825bb0bdae59f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a8a2c4e2d796956ec3eb825bb0bdae59f">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const <a class="el" href="classdouble.html">double</a> w) const</td></tr>
<tr class="separator:a8a2c4e2d796956ec3eb825bb0bdae59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be8b4b185d2469dcdfff826ff854cd7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a9be8b4b185d2469dcdfff826ff854cd7">get_new_point_on_line</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;line) const</td></tr>
<tr class="separator:a9be8b4b185d2469dcdfff826ff854cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f18f34e5f98fea7cbd40bd3245f0aee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a6f18f34e5f98fea7cbd40bd3245f0aee">get_new_point_on_quad</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;quad) const</td></tr>
<tr class="separator:a6f18f34e5f98fea7cbd40bd3245f0aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b1f7a138589989fe84984e12f3d945"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a87b1f7a138589989fe84984e12f3d945">get_new_point_on_hex</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:a87b1f7a138589989fe84984e12f3d945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238d0f0a7f973ff25f4cab4ec21e9b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a238d0f0a7f973ff25f4cab4ec21e9b56">get_new_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face) const</td></tr>
<tr class="separator:a238d0f0a7f973ff25f4cab4ec21e9b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e9a7899b69fbe5fdf7961f9c4c7374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a39e9a7899b69fbe5fdf7961f9c4c7374">get_new_point_on_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:a39e9a7899b69fbe5fdf7961f9c4c7374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a755848f8afbc45f2678fbd83e13f07fa"><td class="memItemLeft" align="right" valign="top">const TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a755848f8afbc45f2678fbd83e13f07fa">sh</a></td></tr>
<tr class="separator:a755848f8afbc45f2678fbd83e13f07fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c47c9668f39a2c99a9570ffc1aaaa9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a69c47c9668f39a2c99a9570ffc1aaaa9">tolerance</a></td></tr>
<tr class="separator:a69c47c9668f39a2c99a9570ffc1aaaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim&gt;<br />
class OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</h3>

<p>A <a class="el" href="classManifold.html">Manifold</a> object based on <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> TopoDS_Shape where new points are first computed by averaging the surrounding points in the same way as <a class="el" href="classFlatManifold.html">FlatManifold</a> does, and then projecting them using <a class="el" href="namespaceOpenCASCADE.html">OpenCASCADE</a> utilities onto the manifold along a direction which is an estimation of the surrounding points (hence mesh cell) normal.</p>
<p>The direction normal to the mesh is particularly useful because it is the direction in which the mesh is missing nodes. For instance, during the refinement of a cell a new node is initially created around the baricenter of the cell. This location somehow ensures a uniform distance from the nodes of the old cell. Projecting such cell baricenter onto the CAD surface in the direction normal to the original cell will then retain uniform distance from the points of the original cell. Of course, at the stage of mesh generation, no dof handler nor finite element are defined, and such direction has to be estimated. For the case in which 8 surrounding points are present, 4 different triangles are identified with the points assigned, and the normals of such triangles are averaged to obtain the approximation of the normal to the cell.</p>
<p>The case in which 2 surrounding points are present (i.e.:a cell edge is being refined) is of course more tricky. The average of the CAD surface normals at the 2 surrounding points is first computed, and then projected onto the plane normal to the segment linking the surrounding points. This again is an attempt to have the new point with equal distance with respect to the surrounding points</p>
<p>This class only operates with CAD faces and makes the assumption that the shape you pass to it contains at least one face. If that is not the case, an Exception is thrown. In debug mode there is a sanity check to make sure that the surrounding points (the ones used in <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">project_to_manifold()</a>) actually live on the <a class="el" href="classManifold.html">Manifold</a>, i.e., calling <a class="el" href="namespaceOpenCASCADE.html#a7b8558aff32262f94308c0e577bee067">OpenCASCADE::closest_point()</a> on those points leaves them untouched. If this is not the case, an ExcPointNotOnManifold is thrown.</p>
<p>Notice that this type of <a class="el" href="classManifold.html">Manifold</a> descriptor may fail to give results if the triangulation to be refined is close to the boundary of the given TopoDS_Shape, or when the normal direction estimated from the surrounding points does not intersect the shape. An exception is thrown when this happens. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8h_source.html#l00228">228</a> of file <a class="el" href="opencascade_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a79eb483936cd38a0a9d42bf2071ee9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb483936cd38a0a9d42bf2071ee9ce">&#9670;&nbsp;</a></span>FaceVertexNormals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> =  std::array&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_face&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself.</p>
<p>For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00307">307</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeff36847ec5e33a8c3991e5b8f1d1000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff36847ec5e33a8c3991e5b8f1d1000">&#9670;&nbsp;</a></span>NormalToMeshProjectionManifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">NormalToMeshProjectionManifold</a> </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classManifold.html">Manifold</a> object which will project points on the TopoDS_Shape <code>sh</code>, along a direction which is approximately normal to the mesh cell. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2962f36ba381305e0cfae7f549b17024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2962f36ba381305e0cfae7f549b17024">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clone the current <a class="el" href="classManifold.html">Manifold</a>. </p>

<p>Reimplemented from <a class="el" href="classFlatManifold.html#a767f5dded58e58793c10bc50ce858ba6">FlatManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9dd1803613a175dd616669290bb12629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd1803613a175dd616669290bb12629">&#9670;&nbsp;</a></span>project_to_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a>&lt; dim, spacedim &gt;::project_to_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform the actual projection onto the manifold. This function, in debug mode, checks that each of the <code>surrounding_points</code> is within tolerance from the given TopoDS_Shape. If this is not the case, an exception is thrown. </p>

<p>Reimplemented from <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a6ade4bf6598dda23e36f95a46fa026e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ade4bf6598dda23e36f95a46fa026e7">&#9670;&nbsp;</a></span>get_new_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Let the new point be the average sum of surrounding vertices.</p>
<p>This particular implementation constructs the weighted average of the surrounding points, and then calls internally the function <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">project_to_manifold()</a>. The reason why we do it this way, is to allow lazy programmers to implement only the <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">project_to_manifold()</a> function for their own <a class="el" href="classManifold.html">Manifold</a> classes which are small (or trivial) perturbations of a flat manifold. This is the case whenever the coarse mesh is a decent approximation of the manifold geometry. In this case, the middle point of a cell is close to true middle point of the manifold, and a projection may suffice.</p>
<p>For most simple geometries, it is possible to get reasonable results by deriving your own <a class="el" href="classManifold.html">Manifold</a> class from <a class="el" href="classFlatManifold.html">FlatManifold</a>, and write a new interface only for the project_to_manifold function. You will have good approximations also with large deformations, as long as in the coarsest mesh size you are trying to refine, the middle point is not too far from the manifold mid point, i.e., as long as the coarse mesh size is small enough. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a10bffbfe9f60ee0cf9d8bb9bfd7f8384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bffbfe9f60ee0cf9d8bb9bfd7f8384">&#9670;&nbsp;</a></span>get_new_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of rows in <code>weights</code> must match the length of <code>new_points</code>.</p>
<p>For this particular implementation, the interpolation of the <code>surrounding_points</code> according to the <code>weights</code> is simply performed in Cartesian space. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#a3d90f7b0e6f66ce0b84676d9aeacfc4e">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ab5eec4132f6d653dea1380f7d587ecdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5eec4132f6d653dea1380f7d587ecdf">&#9670;&nbsp;</a></span>get_tangent_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector that, at \(\mathbf x_1\), is tangential to the geodesic that connects two points \(\mathbf x_1,\mathbf x_2\). For the current class, we assume that the manifold is flat, so the geodesic is the straight line between the two points, and we return \(\mathbf x_2-\mathbf x_1\). The normalization of the vector is chosen so that it fits the convention described in <a class="el" href="classManifold.html#a6bd82ff6170512f65ad5c43e8440c23a">Manifold::get_tangent_vector()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If you use this class as a stepping stone to build a manifold that only "slightly" deviates from a flat manifold, by overloading the <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">project_to_manifold()</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The first point that describes the geodesic, and the one at which the "direction" is to be evaluated. </td></tr>
    <tr><td class="paramname">x2</td><td>The second point that describes the geodesic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "direction" vector tangential to the geodesic. Here, this is \(\mathbf x_2-\mathbf x_1\), possibly modified by the periodicity of the domain as set in the constructor, to use the "shortest" connection between the points through the periodic boundary as necessary. </dd></dl>

<p>Reimplemented from <a class="el" href="classManifold.html#a6bd82ff6170512f65ad5c43e8440c23a">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aab60f221758b3a32a596dde96fc1188c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab60f221758b3a32a596dde96fc1188c">&#9670;&nbsp;</a></span>normal_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector to the given face at point p taking into account that quadrilateral faces of hexahedral cells in 3d may not be planar. In those cases, the face is assumed to have a geometry described by a bilinear function, and the normal vector is computed by embedding this bilinear form into a Cartesian space with a flat metric. </p>

<p>Reimplemented from <a class="el" href="classManifold.html#af0087568e69730a3acc7b42535ab3337">Manifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a355608da9555e9e88ea4b2af47be1c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355608da9555e9e88ea4b2af47be1c26">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face taking into account that quadrilateral faces of hexahedral cells in 3d may not be planar. In those cases, the face is assumed to have a geometry described by a bilinear function, and the normal vector is computed by embedding this bilinear form into a Cartesian space with a flat metric. </p>

</div>
</div>
<a id="a684ad0b97b0f225eb4eb7ee04ab41d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684ad0b97b0f225eb4eb7ee04ab41d7e">&#9670;&nbsp;</a></span>get_normals_at_vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward.</p>
<p>This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">normal_vector()</a> on each vertex.</p>
<p>Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

</div>
</div>
<a id="a774ebed8185bc73b049665b62df23e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774ebed8185bc73b049665b62df23e90">&#9670;&nbsp;</a></span>get_periodicity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;&amp; <a class="el" href="classFlatManifold.html">FlatManifold</a>&lt; dim, spacedim &gt;::get_periodicity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodicity of this <a class="el" href="classManifold.html">Manifold</a>. </p>

</div>
</div>
<a id="a8a2c4e2d796956ec3eb825bb0bdae59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2c4e2d796956ec3eb825bb0bdae59f">&#9670;&nbsp;</a></span>get_intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an intermediate point between two given points. Overloading this function allows the default pair-wise reduction implementation of the method <a class="el" href="classFlatManifold.html#a6ade4bf6598dda23e36f95a46fa026e7">get_new_point()</a> that takes a <a class="el" href="classQuadrature.html">Quadrature</a> object as input to work properly.</p>
<p>An implementation of this function should returns a parametric curve on the manifold, joining the points <code>p1</code> and <code>p2</code>, with parameter <code>w</code> in the interval [0,1]. In particular <code>get_intermediate_point(p1, p2, 0.0)</code> should return <code>p1</code> and <code>get_intermediate_point(p1, p2, 1.0)</code> should return <code>p2</code>.</p>
<p>In its default implementation, this function calls the <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">project_to_manifold()</a> method with the convex combination of <code>p1</code> and <code>p2</code>. User classes can get away by simply implementing the <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">project_to_manifold()</a> method. </p>

<p>Reimplemented in <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, 3 &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim_A, spacedim_A, chartdim_A &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim1, intermediate_dim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim2, spacedim, intermediate_dim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, dim, dim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, 3, 3 &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>, and <a class="el" href="classSphericalManifold.html#ac583ee1989abe66f8b9ead2c4cc79e38">SphericalManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9be8b4b185d2469dcdfff826ff854cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be8b4b185d2469dcdfff826ff854cd7">&#9670;&nbsp;</a></span>get_new_point_on_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary).</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a6f18f34e5f98fea7cbd40bd3245f0aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f18f34e5f98fea7cbd40bd3245f0aee">&#9670;&nbsp;</a></span>get_new_point_on_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a87b1f7a138589989fe84984e12f3d945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b1f7a138589989fe84984e12f3d945">&#9670;&nbsp;</a></span>get_new_point_on_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a238d0f0a7f973ff25f4cab4ec21e9b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238d0f0a7f973ff25f4cab4ec21e9b56">&#9670;&nbsp;</a></span>get_new_point_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="a39e9a7899b69fbe5fdf7961f9c4c7374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e9a7899b69fbe5fdf7961f9c4c7374">&#9670;&nbsp;</a></span>get_new_point_on_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a755848f8afbc45f2678fbd83e13f07fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755848f8afbc45f2678fbd83e13f07fa">&#9670;&nbsp;</a></span>sh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TopoDS_Shape <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a>&lt; dim, spacedim &gt;::sh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The topological shape which is used internally to project points. You can construct such a shape by calling the <a class="el" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">OpenCASCADE::read_IGES()</a> function, which will create a TopoDS_Shape with the geometry contained in the IGES file. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8h_source.html#l00263">263</a> of file <a class="el" href="opencascade_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<a id="a69c47c9668f39a2c99a9570ffc1aaaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c47c9668f39a2c99a9570ffc1aaaa9">&#9670;&nbsp;</a></span>tolerance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdouble.html">double</a> <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">OpenCASCADE::NormalToMeshProjectionManifold</a>&lt; dim, spacedim &gt;::tolerance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relative tolerance used by this class to compute distances. </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2manifold__lib_8h_source.html#l00268">268</a> of file <a class="el" href="opencascade_2manifold__lib_8h_source.html">manifold_lib.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/opencascade/<a class="el" href="opencascade_2manifold__lib_8h_source.html">manifold_lib.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
