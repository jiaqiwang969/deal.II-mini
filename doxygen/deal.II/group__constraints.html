<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__constraints.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Constraints on degrees of freedom</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Constraints on degrees of freedom<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Constraints on degrees of freedom:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__constraints.svg" width="498" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html">AffineConstraints&lt; number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
稀疏模式生成</h2></td></tr>
<tr class="memitem:gaf78e864edbfba7e0a7477457bfb96b26"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number  = double&gt; </td></tr>
<tr class="memitem:gaf78e864edbfba7e0a7477457bfb96b26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gaf78e864edbfba7e0a7477457bfb96b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20db030885dbb33cb55f9a92d5e7804b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number  = double&gt; </td></tr>
<tr class="memitem:ga20db030885dbb33cb55f9a92d5e7804b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga20db030885dbb33cb55f9a92d5e7804b">DoFTools::make_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;coupling, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:ga20db030885dbb33cb55f9a92d5e7804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2627e9bde96b98d4fcf95b629e4fd4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga7b2627e9bde96b98d4fcf95b629e4fd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga7b2627e9bde96b98d4fcf95b629e4fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee18d72bf380f091c0fe21081e35768d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:gaee18d72bf380f091c0fe21081e35768d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaee18d72bf380f091c0fe21081e35768d">DoFTools::make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs=true, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gaee18d72bf380f091c0fe21081e35768d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebdabb3b4e2882a6ee130c7d8115a0df"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:gaebdabb3b4e2882a6ee130c7d8115a0df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaebdabb3b4e2882a6ee130c7d8115a0df">DoFTools::make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, SparsityPatternType &amp;sparsity, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;cell_integrals_mask, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;face_integrals_mask, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>)</td></tr>
<tr class="separator:gaebdabb3b4e2882a6ee130c7d8115a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0600dbcf28ec5bf58de34e21e1fb4b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga5a0600dbcf28ec5bf58de34e21e1fb4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5a0600dbcf28ec5bf58de34e21e1fb4b">DoFTools::make_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_row, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_col, SparsityPatternType &amp;sparsity)</td></tr>
<tr class="separator:ga5a0600dbcf28ec5bf58de34e21e1fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52de1b60d79f9ef5e0c642d7da16f0a8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:ga52de1b60d79f9ef5e0c642d7da16f0a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga52de1b60d79f9ef5e0c642d7da16f0a8">DoFTools::make_flux_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, SparsityPatternType &amp;sparsity, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classbool.html">bool</a> keep_constrained_dofs, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;couplings, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;face_couplings, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id, const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;face_has_flux_coupling=&amp;internal::always_couple_on_faces&lt; dim, spacedim &gt;)</td></tr>
<tr class="separator:ga52de1b60d79f9ef5e0c642d7da16f0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f970db3b035e9813fc7201a2d18d032"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ga9f970db3b035e9813fc7201a2d18d032"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga9f970db3b035e9813fc7201a2d18d032">DoFTools::make_boundary_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:ga9f970db3b035e9813fc7201a2d18d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dd70fabd9fe942ce3c127e6510024e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </td></tr>
<tr class="memitem:gab3dd70fabd9fe942ce3c127e6510024e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gab3dd70fabd9fe942ce3c127e6510024e">DoFTools::make_boundary_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_ids, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, SparsityPatternType &amp;sparsity)</td></tr>
<tr class="separator:gab3dd70fabd9fe942ce3c127e6510024e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
悬空节点和其他约束</h2></td></tr>
<tr class="memitem:ga3b4ea7dfd313e388d868c4e4aa685799"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga3b4ea7dfd313e388d868c4e4aa685799"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints)</td></tr>
<tr class="separator:ga3b4ea7dfd313e388d868c4e4aa685799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae648a4b093f351b25eba50e8567b6ef"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gaae648a4b093f351b25eba50e8567b6ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaae648a4b093f351b25eba50e8567b6ef">DoFTools::compute_intergrid_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned <a class="el" href="classint.html">int</a> coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned <a class="el" href="classint.html">int</a> fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;coarse_to_fine_grid_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints)</td></tr>
<tr class="separator:gaae648a4b093f351b25eba50e8567b6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1126ff8e1542c36e6fcc2d825006d7f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gae1126ff8e1542c36e6fcc2d825006d7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gae1126ff8e1542c36e6fcc2d825006d7f">DoFTools::compute_intergrid_transfer_representation</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;coarse_grid, const unsigned <a class="el" href="classint.html">int</a> coarse_component, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;fine_grid, const unsigned <a class="el" href="classint.html">int</a> fine_component, const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;coarse_to_fine_grid_map, std::vector&lt; std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, float &gt;&gt; &amp;transfer_representation)</td></tr>
<tr class="separator:gae1126ff8e1542c36e6fcc2d825006d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
杂项</h2></td></tr>
<tr class="memitem:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_id, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga06c0301bc74dd4c67a3d1db1000647f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326f0868782800e5fa9d8e90c9cef135"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga326f0868782800e5fa9d8e90c9cef135"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga326f0868782800e5fa9d8e90c9cef135">DoFTools::make_zero_boundary_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;zero_boundary_constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga326f0868782800e5fa9d8e90c9cef135"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
间接对LinearOperator施加约束</h2></td></tr>
<tr class="memitem:ga814d426ef355ed315bb57cea21a7630a"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga814d426ef355ed315bb57cea21a7630a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga814d426ef355ed315bb57cea21a7630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga52c9bbeff68309fdc7e4975eddba5eea">project_to_constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga4787b401a7e601750d85b8b4fc84c8a5">constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;linop)</td></tr>
<tr class="separator:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1985f642cfa97d522ffe9d21d2313ce2">constrained_right_hand_side</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;linop, const Range &amp;right_hand_side)</td></tr>
<tr class="separator:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814d426ef355ed315bb57cea21a7630a"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga814d426ef355ed315bb57cea21a7630a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga814d426ef355ed315bb57cea21a7630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga52c9bbeff68309fdc7e4975eddba5eea">project_to_constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga4787b401a7e601750d85b8b4fc84c8a5">constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;linop)</td></tr>
<tr class="separator:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1985f642cfa97d522ffe9d21d2313ce2">constrained_right_hand_side</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;linop, const Range &amp;right_hand_side)</td></tr>
<tr class="separator:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
内插和投影</h2></td></tr>
<tr class="memitem:ga5e6b9de5ad09eb5009075618f08eb129"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga5e6b9de5ad09eb5009075618f08eb129"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5e6b9de5ad09eb5009075618f08eb129">VectorTools::interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga5e6b9de5ad09eb5009075618f08eb129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5255de72726a1fa50c4653ce59e6a438"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga5255de72726a1fa50c4653ce59e6a438"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5255de72726a1fa50c4653ce59e6a438">VectorTools::interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga5255de72726a1fa50c4653ce59e6a438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39e86be1bee406512895d2b0377da87"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:gaa39e86be1bee406512895d2b0377da87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa39e86be1bee406512895d2b0377da87">VectorTools::interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaa39e86be1bee406512895d2b0377da87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f61567fa003b5448fce53e0eec4b79"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:gaf2f61567fa003b5448fce53e0eec4b79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf2f61567fa003b5448fce53e0eec4b79">VectorTools::interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaf2f61567fa003b5448fce53e0eec4b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a2c72e6d0bc19fb346d51767e48c89"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga32a2c72e6d0bc19fb346d51767e48c89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga32a2c72e6d0bc19fb346d51767e48c89">VectorTools::project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:ga32a2c72e6d0bc19fb346d51767e48c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf550f1f801988790bf89c099e7ff2fb0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:gaf550f1f801988790bf89c099e7ff2fb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf550f1f801988790bf89c099e7ff2fb0">VectorTools::project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:gaf550f1f801988790bf89c099e7ff2fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190b302dc1ee7c89727c94c083d132d2"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number &gt; </td></tr>
<tr class="memitem:ga190b302dc1ee7c89727c94c083d132d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga190b302dc1ee7c89727c94c083d132d2">VectorTools::project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, number &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:ga190b302dc1ee7c89727c94c083d132d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d845992528893a53ad7f37a15d0aaa"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number &gt; </td></tr>
<tr class="memitem:gac0d845992528893a53ad7f37a15d0aaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gac0d845992528893a53ad7f37a15d0aaa">VectorTools::project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, number &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gac0d845992528893a53ad7f37a15d0aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac8ab38430250535a694205a7372f5a7"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaac8ab38430250535a694205a7372f5a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaac8ab38430250535a694205a7372f5a7">VectorTools::project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:gaac8ab38430250535a694205a7372f5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff48f8eaf46c5618b95eefa23081449e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaff48f8eaf46c5618b95eefa23081449e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaff48f8eaf46c5618b95eefa23081449e">VectorTools::project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gaff48f8eaf46c5618b95eefa23081449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fdd3b0f9e4e4ad02cf932901bd0659"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga54fdd3b0f9e4e4ad02cf932901bd0659"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga54fdd3b0f9e4e4ad02cf932901bd0659">VectorTools::compute_nonzero_normal_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ga54fdd3b0f9e4e4ad02cf932901bd0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d16c332aaa652e8905a6f48208e4500"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga0d16c332aaa652e8905a6f48208e4500"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ga0d16c332aaa652e8905a6f48208e4500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b73118e3a950d33515ae649b9014d04"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga1b73118e3a950d33515ae649b9014d04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1b73118e3a950d33515ae649b9014d04">VectorTools::compute_nonzero_tangential_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ga1b73118e3a950d33515ae649b9014d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad396065c624ae6c5d843e22fb75c3c36"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gad396065c624ae6c5d843e22fb75c3c36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gad396065c624ae6c5d843e22fb75c3c36">VectorTools::compute_normal_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:gad396065c624ae6c5d843e22fb75c3c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>本模块处理自由度的约束问题。处理约束的中心类是AffineConstraints类。 约束通常来自几个方面，例如。</p>
<ul>
<li>如果你有迪里希特型边界条件， \(u|_{\partial\Omega}=g\) ，通常通过要求边界上的自由度有特定的值来执行，例如 \(x_{12}=42\) ，如果边界条件 \(g(\mathbf x)\) 要求自由度12位置的有限元解 \(u(\mathbf x)\) 有42值。这样的约束是由那些接受AffineConstraints参数的 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a> 函数版本产生的（尽管也有其他处理Dirichlet条件的方法，使用 <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>, 见例如 <a class="el" href="step_3.html">step-3</a> 和 <a class="el" href="step_4.html">step-4</a> ）。</li>
<li>如果你有边界条件，设定了解决方案的某一部分数值，例如没有法向通量， \(\mathbf n \cdot \mathbf u=0\) （如发生在流动问题中，由 <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a> 函数处理）或规定的切向分量， \(\mathbf{n}\times\mathbf{u}= \mathbf{n}\times\mathbf{f}\) （如发生在电磁问题中，由 VectorTools::project_boundary_values_curl_conforming 函数处理）。对于前一种情况，例如，设想我们在法线矢量具有 \(\frac 1{\sqrt{14}} (1,2,3)^T\) 形式的顶点，在这个顶点的流场的 \(x\) -、 \(y\) -和 \(z\) 分量与自由度12、28和40相关。那么无正态流条件意味着我们需要有条件 \(\frac 1{\sqrt{14}} (x_{12}+2x_{28}+3x_{40})=0\) 。 规定的切向分量会导致类似的约束，尽管右手边经常有一些东西。</li>
<li>如果你有悬挂节点约束，例如在这样的网格中。 <div class="image">
<img src="hanging_nodes.png" alt="hanging_nodes.png"/>
</div>
 我们假设右下角的两个红色自由度之一是 \(x_{12}\) ，其左右两边的黄色邻居是 \(x_{28}\) 和 \(x_{40}\) 。那么，要求有限元函数是连续的，就相当于要求 \(x_{12}= \frac 12 (x_{28}+x_{40})\) 。类似的情况发生在hp自适应有限元方法的背景下。 例如，当在网格的两个标记单元上使用Q1和Q2元素（即使用FE_Q(1)和FE_Q(2)）时 <div class="image">
<img src="hp-refinement-simple.png" alt="hp-refinement-simple.png"/>
<div class="caption">
有三个约束：首先 \(x_{12}= \frac 12 (x_{28}+x_{40})\)#50 ，然后 \(x_{12}= \frac 12 (x_{28}+x_{40})\)#51 ，最后是身份 \(x_{12}= \frac 12 (x_{28}+x_{40})\)#52 。即使所有的单元格都使用相同的有限元，也会出现类似的约束条件作为悬挂节点。在所有这些情况下，你将使用 DoFTools::make_hanging_node_constraints 函数来计算这种约束。</div></div>
</li>
<li><p class="startli">其他线性约束，例如，当你试图为一个问题施加某个平均值时，否则就没有唯一的解决方案。在 <a class="el" href="step_11.html">step-11</a> 的教程程序中给出了这样一个例子。 在所有这些例子中，对自由度的约束是线性的，而且可能是不均匀的。换句话说，它们总是具有 \(x_{i_1} = \sum_{j=2}^M a_{i_j} x_{i_j} + b_i\) 的形式。处理存储和使用这些约束的deal.II类是AffineConstraints。</p>
<h3>Eliminating constraints</h3>
<p class="startli">在建立全局系统矩阵和右手边时，可以不考虑约束条件，即简单地在单元上循环，将局部贡献加入全局矩阵和右手边对象。为了进行实际计算，你必须对线性系统进行 "浓缩"：消除受约束的自由度并将适当的值分配给无约束的自由度。这改变了有限元计算中使用的稀疏矩阵的稀疏模式，因此是一个相当昂贵的操作。事情的一般方案是，你建立你的系统，使用 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> 函数消除（浓缩）约束节点，然后你解决剩余的系统，最后你使用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 函数从无约束节点的值中计算出约束节点的值。请注意， <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> 函数适用于线性系统的矩阵和右手边，而 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 函数则适用于解向量。 这种先建立线性系统，再消除约束自由度的方案效率很低，如果约束条件多，矩阵满，即特别是对3d和/或高阶或hp-finite元素，则是一个瓶颈。此外，它不可能在一个进程可能无法接触到矩阵元素的情况下实现的并行计算。因此，我们提供了建立线性系统的第二种方法，使用下面讨论的 <a class="el" href="classAffineConstraints.html#ad210f57f792afd7f51c72c546f22e298">AffineConstraints::add_entries_local_to_global()</a> 和 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 函数。得到的线性系统与调用 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> 函数后得到的线性系统是等价的。</p>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>这两种应用约束的方式都是将矩阵对角线的值设置为与矩阵中其他项相同大小的<em>positive</em>项。因此，你需要设置你的问题，使描述主要矩阵贡献的弱形式不是<em>negative definite</em>。否则，像CG这样的迭代求解器会崩溃，或者像GMRES那样慢得多。</dd>
<dd>
虽然这两种方式是<em>equivalent</em>，即通过任何一种方式计算的线性系统的解是相同的，但线性系统本身不一定具有相同的矩阵和右侧向量条目。具体来说，由于我们计算的方式不同，对应于受限自由度的矩阵对角线和右手边条目可能不同；但是，它们总是以这样的方式选择，即线性系统的解是相同的。 <h4>Condensing matrices and sparsity patterns</h4>
</dd></dl>
<p>如上所述，使用约束条件的第一种方式是在不考虑约束条件的情况下建立线性系统，然后将其 "浓缩 "掉。浓缩一个矩阵分四个步骤进行。</p>
<ul>
<li>首先是建立稀疏模式（例如，使用 <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a>); ）。</li>
<li>那么浓缩矩阵的稀疏模式是由原始稀疏模式和约束条件组成的。</li>
<li>第三，全局矩阵的组装。</li>
<li><p class="startli">第四，矩阵最终被浓缩。 在浓缩过程中，我们实际上没有改变稀疏模式、矩阵和向量的行数或列数。相反，凝结函数将非零条目添加到矩阵的稀疏模式中（其中有受限节点），矩阵的凝结过程将产生额外的非零元素。在浓缩过程本身中，受约束的行和列被分配到无约束节点的行和列中。受约束的自由度保持原位。为了不干扰求解过程，这些行和列用零和主对角线上的一个适当的正值来填充（我们选择其他对角线元素大小的平均值，以确保新的对角线条目具有与其他条目相同的大小顺序；这保留了矩阵的缩放特性）。右手边的相应数值被设置为零。这样一来，受约束的节点在方程组求解时将始终得到零值，并且不会再与其他节点耦合。 与创建一个新的、更小的矩阵相比，保留矩阵中的条目有一个好处，即只需要一个矩阵和稀疏模式，因此需要的内存更少。此外，浓缩过程的成本较低，因为不是所有的而是只有矩阵中的受限值必须被复制。另一方面，求解过程将花费更长的时间，因为矩阵向量的乘法会在受约束的行中产生乘以零的结果。此外，矢量的大小更大，对于那些使用较大数量的辅助矢量的迭代求解方法（例如使用显式正交程序的方法）来说，会导致更多的内存消耗。尽管如此，这个过程由于其较低的内存消耗而更有效率。 浓缩函数存在于不同的参数类型中。SparsityPattern, <a class="el" href="classSparseMatrix.html">SparseMatrix</a> 和 BlockSparseMatrix。请注意，对于 <a class="el" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">PETScWrappers::SparseMatrix()</a> 类型的参数或其他PETSc或Trilinos矩阵封装类，没有任何版本。这是因为相对来说，要得到PETSc矩阵的稀疏结构的表示，并有效地修改它们是很困难的；这一点尤其适用于矩阵实际分布在一个计算机集群中的情况。如果你想使用PETSc/Trilinos矩阵，你可以复制一个已经浓缩的deal.II矩阵，或者以已经浓缩的形式组装PETSc/Trilinos矩阵，见下面的讨论。</p>
<h4>Condensing vectors</h4>
<p class="startli">浓缩向量的工作原理与上面描述的矩阵的工作原理完全相同。请注意，缩合是一个等价的操作，也就是说，对一个向量或矩阵做一次以上的缩合操作与只做一次的结果相同：一旦一个对象被缩合，进一步的缩合操作就不会再改变它了。 与矩阵凝结函数相反，矢量凝结函数存在于PETSc和Trilinos矢量的变体中。然而，使用它们通常很昂贵，应该避免。你应该使用与上述相同的技术来避免使用它们。</p>
<h4>Avoiding explicit condensation</h4>
<p class="startli">有时，人们希望在一个线性系统建立之后，根本就避免对它进行显式凝结。想这样做有两个主要原因。 </p><ul>
<li>
缩合是一个昂贵的操作，特别是当有许多约束条件和/或矩阵有许多非零项时。对于三维或高多项式程度的计算，以及hp-finite element方法来说，这两种情况都很典型，例如见 <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>。这是hp教程程序中讨论的情况， <a class="el" href="step_27.html">step_27 </a>step-27"  "，以及 <a class="el" href="step_22.html">step-22</a> 和 <a class="el" href="step_31.html">step_31 </a>step-31"  "。 </li>
<li>
你使用的矩阵可能没有 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> 函数（例如，PETSc和Trilinos封装类就是这种情况，我们无法访问矩阵的底层表示，因此无法有效地实现 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> 操作）。这种情况在 <a class="el" href="step_17.html">step-17</a> 、 <a class="el" href="step_18.html">step-18</a> 、 <a class="el" href="step_31.html">step-31</a> 和 <a class="el" href="step_32.html">step-32</a> 中讨论。 </li>
</ul>
<p>在这种情况下，一种可能性是在将局部条目转移到全局矩阵和向量的时刻就将其分配到最终目的地，同样在最初设置的时候就在浓缩的形式中建立一个稀疏的模式。 AffineConstraints类也为这些操作提供了支持。例如， <a class="el" href="classAffineConstraints.html#ad210f57f792afd7f51c72c546f22e298">AffineConstraints::add_entries_local_to_global()</a> 函数将非零条目添加到一个稀疏模式对象中。它不仅添加了一个给定的条目，而且还添加了所有的条目，如果当前的条目对应于以后要消除的受限自由度，我们就必须写到这些条目。类似地，在将局部贡献复制到全局矩阵或向量时，可以使用 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 函数直接分配向量和矩阵中的条目。这些调用使得后续调用 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> 变得没有必要。关于它们的使用例子，请看上面提到的教程程序。 注意，尽管它们的名字描述了函数的真正作用， <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 函数必须应用于矩阵和右手边的向量，而下面讨论的 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 函数则应用于求解线性系统后的向量。</p>
<h3>Distributing constraints</h3>
<p class="startli">在求解浓缩方程组后，解向量必须被 "分配"：通过调用 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> 对原始线性系统的修改，导致一个线性系统对所有无约束的自由度都能正确求解，但对有约束的自由度的值却没有定义。为了得到这些自由度的正确值，你需要将无约束的值也 "分配 "给它们的有约束的同事。这是由 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 函数完成的。分布的操作在某种意义上撤销了凝结过程，但应该注意的是，它不是逆向操作。基本上，分布将受约束的节点的值设置为从约束中计算出来的值，给定的是无约束的节点的值加上可能的不均匀性。</p>
<h3>Treatment of inhomogeneous constraints</h3>
<p class="startli">如果一些约束线有不均匀性（如果约束来自于不均匀边界条件的实现，这就是典型的情况），情况就会比仅仅由于悬挂节点的约束更复杂一些。这是因为消除矩阵中的非对角线值会在向量中消除的行中产生贡献。这意味着，不均匀性只能用同时作用于矩阵和向量的函数来处理。这意味着，如果在没有任何矩阵的情况下调用相应的凝结函数（或者如果矩阵之前已经被凝结过），所有的不均匀性都会被忽略。 使用AffineConstraints类来实现Dirichlet边界条件在 <a class="el" href="step_22.html">step-22</a> 教程程序中讨论。另一个利用AffineConstraints的例子是 <a class="el" href="step_41.html">step-41</a> 。这里的情况要复杂一些，因为我们有一些不在边界上的约束。在创建AffineConstraints对象后，有两种方法来应用不均匀约束。 第一种方法。</p>
</li>
<li>将 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 函数应用于系统矩阵和右侧，参数use_inhomogeneities_for_rhs = false（即默认）。</li>
<li>使用 <a class="el" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">AffineConstraints::set_zero()</a> 函数将不均匀约束部分的解设为零（或者从等于零的解矢量开始）。</li>
<li>解决()线性系统</li>
<li>将 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 应用于解决方案中 第二种方法。</li>
<li>使用参数use_inhomogeneities_for_rhs = true的 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 函数，并将其应用于系统矩阵和右手方</li>
<li>将解的有关分量设置为不均匀的约束值（例如使用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a>) ）。</li>
<li>解决()线性系统</li>
<li>根据求解器现在你必须对解应用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 函数，因为求解器可以改变解中的约束值。对于一个基于Krylov的求解器来说，这应该不是严格意义上的需要，但是仍然有可能在不均匀值和解的值之间存在机器精度的差异，而且如果你有额外的约束，例如来自悬挂节点的约束，你可能无论如何都想调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 。 当然，这两种方法都导致了相同的最终答案，但方式不同。使用第一种方法（即在 <code>use_inhomogeneities_for_rhs = false</code> 中使用 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>), 时，我们建立的线性系统在所有那些自由度受到约束的地方，右手边的条目都是零，在这些线的矩阵对角线上有一些正值。因此，线性系统的解向量对于不均匀约束的自由度会有一个零值，我们需要调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 来给这些自由度以正确的非零值。 另一方面，在第二种方法中，对于不均匀约束自由度的矩阵对角线元素和相应的右手边条目，使线性系统的解已经具有正确的值（例如，如果约束条件是 \(x_{13}=42\) ，那么如果矩阵除了对角线条目外是空的，则行 \(13\) ，而 \(b_{13}/A_{13,13}=42\) ，这样 \(Ax=b\) 的解必须如愿满足 \(x_{13}=42\) ）。因此，我们不需要在求解后调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 来修复解的不均匀约束成分，尽管这样做也无妨。 还有一个问题，即采取哪种方法，以及为什么我们需要将第一种方法中的解向量的值设为零。这两个问题的答案都与迭代求解器解决线性系统的方式有关。为此，考虑到我们通常在残差下降到右手边法线的某个分数以下时停止迭代，或者说，在初始残差的某个分数以下时停止迭代。现在考虑这个问题。</li>
<li>在第一种方法中，受限自由度的右手边条目为零，也就是说，右手边的准则实际上只包括我们关心的那些部分。另一方面，如果我们从一个解向量开始，而这个解向量在受约束的条目中不为零，那么初始残差就会非常大，因为目前解向量中的值与线性系统的解（在这些部分中为零）不匹配。 因此，如果我们一旦将初始残差减少了某一系数就停止迭代，那么我们可能在一次迭代后就达到了阈值，因为受限自由度被迭代求解器在一次迭代中就解决了。如果初始残差是由这些自由度主导的，那么我们在第一步就看到了急剧的减少，尽管在这短短的一次迭代中我们在线性系统的其余部分并没有真正取得什么进展。我们可以通过以下方式来避免这个问题：一旦残差的规范达到<em>norm of the right hand side</em>的某个分数就停止迭代，或者我们可以将解的成分设置为零（从而减少初始残差），然后迭代直到达到<em>norm of the initial residual</em>的某个分数。</li>
<li><p class="startli">在第二种方法中，如果迭代中的起始向量为零，我们会遇到同样的问题，因为此时残差可能被受限自由度所支配，其值与我们在解中希望的值不一致。我们可以通过调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> <em>before</em>求解线性系统（必要时在求解后再进行第二次），将解向量的相应元素设置为正确的值，从而再次规避这个问题。 除了这些考虑，考虑我们有 \(x_{3}=\tfrac 12 x_1 + \tfrac 12\) 这种不均匀约束的情况，例如，从 \(x_{3}=\tfrac 12 (x_1 + x_2)\) 形式的悬挂节点约束，其中 \(x_2\) 本身被边界值约束到 \(x_2=1\) 。在这种情况下，AffineConstraints容器当然不能找出 \(x_3\) 的最终值，因此，不能正确设置解向量的第三分量。因此，第二种方法将不起作用，你应该采取第一种方法。</p>
<h3>Dealing with conflicting constraints</h3>
<p class="startli">有些情况下，自由度受到不止一种方式的约束，有时是相互冲突的方式。例如，考虑下面的情况。 </p><div class="image">
<img src="conflicting_constraints.png" alt="conflicting_constraints.png"/>
</div>
<p> 这里，蓝色标记的自由度 \(x_0\) 是一个悬挂节点。如果我们使用三线有限元，即FE_Q(1)，那么它将带有约束条件 \(x_0=\frac 12 (x_{1}+x_{2})\) 。另一方面，它在边界上，如果我们施加了边界条件 \(u|_{\partial\Omega}=g\) ，那么我们将有约束 \(x_0=g_0\) ，其中 \(g_0\) 是这个自由度位置上的边界函数 \(g(\mathbf x)\) 的值。 那么，哪一个会赢？或者说：哪一个<em>should</em>赢？这个问题没有好的答案。</p>
</li>
<li>如果悬挂的节点约束是最终执行的约束，那么对于一般的边界函数，所得到的解不再满足边界条件 \(g\) 。</li>
<li>如果反其道而行之，在这一点上，解决方案将不满足悬挂节点的约束，因此将不满足所选元素的规则性属性（例如，尽管使用 \(Q_1\) 元素，但将不连续）。</li>
</ul>
<p>-如果你考虑弯曲的边界，情况就会变得完全没有希望，因为那时边的中点（即悬挂的节点）一般不在母边上。因此，无论两个竞争约束的优先级如何，解决方案都不会是 \(H^1\) 符合要求的。如果悬空节点约束获胜，那么解决方案将既不符合要求，也没有正确的边界值。换句话说，"正确
  "的解决方案是什么并不完全清楚。在大多数情况下，这并不重要：无论是哪种情况，由不符合性或不正确的边界值引入的误差最差也会与离散化的整体误差处于同一等级。 也就是说，如果你知道你想要的是什么，你应该怎么做。</p>
<ul>
<li>如果你想让悬挂的节点约束获胜，那么首先通过 <a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints()</a> 函数建立这些约束。 然后用 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> 将边界值插值到同一个AffineConstraints对象中。如果后一个函数遇到一个已经被约束的边界节点，它将简单地忽略这个节点的边界值，不触及约束。</li>
<li><p class="startli">如果你想让边界值约束获胜，就像上面那样建立悬空节点约束，并使用这些约束用 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 函数来组装矩阵（或者，另一种方法是组装矩阵，然后对其使用 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> ）。在第二步，使用 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> 函数返回 std::map ，并将其作为 <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> 的输入，将边界节点设置为正确的值。 两种行为也可以通过建立两个独立的AffineConstraints对象，并以特定的第二个参数调用 <a class="el" href="classAffineConstraints.html#a09d267ebb328a639eb9f3d68b1fa7ffb">AffineConstraints::merge()</a> 函数来实现。</p>
<h3>Applying constraints indirectly with a <a class="el" href="classLinearOperator.html">LinearOperator</a></h3>
<p class="startli">有时候，直接压缩或消除线性方程组中的约束是不可取的，也是不可能的。特别是如果没有底层矩阵对象可以被压缩（或在装配过程中照顾到约束）。如果系统是由LinearOperator描述的，通常就是这种情况。 在这种情况下，我们可以用修改后的系统 </p><p class="formulaDsp">
\[ (C^T A C + Id_c) \tilde x = C^T (b - A\,k) \]
</p>
<p>代替[1]（M. S. Shephard.作为直接刚度装配过程的一部分，通过变换应用的线性多点约束。&lt;i&gt;International Journal for Numerical Methods in Engineering 20(11):2107-2112, 1985). 这里， \(A\) 是一个给定的（无约束的）系统矩阵，对于它，我们只假设可以应用于一个向量，但不一定可以访问单个矩阵条目。 \(b\) 是线性方程组 \(A\,x=b\) 的相应右手边。矩阵 \(C\) 描述了存储在AffineConstraints对象中的线性约束的同质部分，向量 \(k\) 是相应的不均匀性的向量。更确切地说，应用于向量 \(x\) 的 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 操作是 </p><p class="formulaDsp">
\[ x \leftarrow C\,x+k. \]
</p>
<p>的操作。最后， \(Id_c\) 表示约束自由度子空间上的身份。 然后通过分配约束条件来恢复服从这些约束的 \(A\,x=b\) 的相应解。 \(x=C\tilde x+k\) . 整个系统可以通过以下代码片段来设置和解决。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="constrained__linear__operator_8h.html">deal.II/lac/constrained_linear_operator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="comment">// system_matrix</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- unconstrained and assembled system matrix</div><div class="line"><span class="comment">// right_hand_side</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- unconstrained and assembled right hand side</div><div class="line"><span class="comment">// affine_constraints</span></div><div class="line"></div><div class="line">- an <a class="code" href="classAffineConstraints.html">AffineConstraints</a> <span class="keywordtype">object</span></div><div class="line"><span class="comment">// solver</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- an appropriate, iterative solver</div><div class="line"><span class="comment">// preconditioner</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- a preconditioner</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_a = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(system_matrix);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_amod = <a class="code" href="group__constraints.html#ga4787b401a7e601750d85b8b4fc84c8a5">constrained_linear_operator</a>(affine_constraints, op_a);</div><div class="line">Vector&lt;double&gt; rhs_mod = <a class="code" href="group__constraints.html#ga1985f642cfa97d522ffe9d21d2313ce2">constrained_right_hand_side</a>(affine_constraints,</div><div class="line">                                                   op_a,</div><div class="line">                                                   right_hand_side);</div><div class="line"></div><div class="line">solver.solve(op_amod, solution, rhs_mod, preconditioner);</div><div class="line">affine_constraints.distribute(solution);</div></div><!-- fragment --> </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf78e864edbfba7e0a7477457bfb96b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf78e864edbfba7e0a7477457bfb96b26">&#9670;&nbsp;</a></span>make_sparsity_pattern() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename SparsityPatternType , typename number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;number&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算建立在给定 <code>dof_handler</code> 上的矩阵的哪些条目可能是非零的，并创建一个代表这些非零位置的稀疏模式对象。 这个函数通过<em>simulating</em>计算全局系统矩阵中非零项的可能位置，在实际组装矩阵的过程中，人们会将这些条目写入全局系统矩阵。为此，该函数假设每个有限元基函数只有在其自由度与该单元的内部、面、边或顶点相关时，才是该单元的非零值。 因此，从两个具有（全局）指数 \(i\) 和 \(j\) 的基函数 \(\varphi_i\) 和 \(\varphi_j\) 计算出来的矩阵条目 \(A_{ij}\) （例如，使用双线性形式 \(A_{ij}=a(\varphi_i,\varphi_j)\) ）只有在这些形状函数对应于至少一个共同单元上定义的自由度时才可能是非零。因此，这个函数只是在所有单元中循环，找出所有自由度的全局指数，并假定所有与这些指数相联系的矩阵条目将导致一个非零矩阵条目。然后，这些将被添加到稀疏模式中。 由于这个生成稀疏性模式的过程没有考虑到以后要解决的方程，所以产生的稀疏性模式是对称的。 这种算法对每个单元上的形状函数不加区分，也就是说，它只是将一个单元上的所有自由度与一个单元上的所有其他自由度进行耦合。这通常是一种情况，而且总是一种安全的假设。然而，如果你对运算符的结构有所了解，知道它不会将某些形状函数与某些测试函数耦合，那么你可以通过调用下面描述的当前函数的变体来获得更稀疏的稀疏模式，该变体允许指定哪些向量分量与其他向量分量耦合。 上面描述的方法基于这样的假设：自由度之间的耦合只发生在形状函数至少在一个单元上重叠的情况下。这是最常见的涉及保形元素的有限元公式的情况。然而，对于诸如非连续Galerkin有限元方法这样的公式，双线性形式包含了单元之间的界面条款，这些条款将生活在一个单元上的形状函数与生活在相邻单元上的形状函数相耦合。当前函数不会看到这些耦合，因此不会在稀疏模式中分配条目。然后，你会在矩阵组装过程中遇到麻烦，因为你试图向矩阵条目中写入疏散模式中没有分配到的空间。 这可以通过调用 <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern()</a> 函数来避免，该函数考虑了相邻单元上自由度之间的耦合。 在其他情况下，双线性形式包含非局部项，例如在处理积分方程时。这些情况需要不同的方法来建立稀疏模式，这取决于问题的确切表述。那么，你必须自己做这件事。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>描述哪些自由度存在于哪些单元的DoFHandler对象。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sparsity_pattern</td><td>要填入条目的稀疏性模式。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">约束</td><td>上述生成条目的过程完全是每个单元的局部。因此，稀疏性模式没有规定只有在消除悬空节点或其他约束时才会被写入的矩阵条目。它们必须通过后续调用 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a>. 来处理。另外，在创建稀疏模式时，自由度的约束已经被考虑在内。为此，将AffineConstraints对象作为第三个参数传递给当前函数。这样就不需要调用 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> 了。这个过程在 <a class="el" href="step_6.html">step-6</a> 、 <a class="el" href="step_27.html">step-27</a> 和其他教程程序中都有解释。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep_constrained_dofs</td><td>如果约束条件已经通过传递AffineConstraints对象在该函数中得到了处理，那么如果这些条目在实际装配该疏散模式的矩阵时也不会被写入，那么就可以放弃疏散模式中的一些非对角线条目。具体来说，当使用 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, 的装配方法时，没有条目会被写入那些对应于受限自由度的矩阵行或列中。在这种情况下，你可以将参数 <code>keep_constrained_dofs设置为</code> <code>false</code> 来避免在稀疏模式中分配这些条目。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subdomain_id</td><td>如果指定的话，疏散模式只建立在子域_id等于给定参数的单元上。这在矩阵和稀疏模式（例如 <a class="el" href="classTrilinosWrappers_1_1SparsityPattern.html">TrilinosWrappers::SparsityPattern</a>) ）可能是分布式的，并且不是每个MPI进程都需要构建整个稀疏模式的并行环境中很有用；在这种情况下，如果每个进程只构建与它负责的子域_id相对应的那部分稀疏模式就足够了。这个特征在 <a class="el" href="step_32.html">step-32</a> 中使用。（对于 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 类型的对象通常不需要这个参数，因为当前函数无论如何只在本地拥有的单元上循环；因此，这个参数通常只在你想把子域_id用于指示哪个处理器拥有一个单元以外的事情时才有意义，例如一个单元属于域的哪个几何成分）。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>稀疏模式的实际类型可以是SparsityPattern、DynamicSparsityPattern、BlockSparsityPattern、BlockDynamicSparsityPattern，或者其他任何满足类似要求的类。假设疏散模式的大小与自由度的数量相匹配，并且如果疏散模式是 "静态 " 的，则有足够的未使用的非零条目来填充疏散模式（关于这意味着什么的更多信息，请参见 <a class="el" href="group__Sparsity.html">Sparsity patterns</a> ）。这个函数生成的非零条目被添加到对象以前可能的内容中，也就是说，以前添加的条目不会被删除。 </dd>
<dd>
如果稀疏模式由SparsityPattern类型的对象表示（而不是例如DynamicSparsityPattern），你需要记住在生成模式后使用 <a class="el" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">SparsityPattern::compress()</a> 。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00064">64</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga20db030885dbb33cb55f9a92d5e7804b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20db030885dbb33cb55f9a92d5e7804b">&#9670;&nbsp;</a></span>make_sparsity_pattern() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename SparsityPatternType , typename number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coupling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;number&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算建立在给定的 <code>dof_handler</code> 上的矩阵的哪些条目可能是非零的，并创建一个代表这些非零位置的稀疏模式对象。 这个函数是以前的make_sparsity_pattern()函数的一个简单的变化（关于所有常用参数的描述见那里），但它为矢量有限元提供了功能，允许更具体地确定哪些变量在哪个方程中耦合。 例如，如果你想解决斯托克斯方程。 </p><p class="formulaDsp">
\begin{align*} -\Delta \mathbf u + \nabla p &amp;= 0,\\ \text{div}\ u &amp;= 0 \end{align*}
</p>
<p> *在两个空间维度上，使用稳定的Q2/Q1混合元素（使用FESystem类），那么你不希望所有的自由度在每个方程中耦合。更具体地说，在第一个方程中，只有 \(u_x\) 和 \(p\) 出现；在第二个方程中，只有 \(u_y\) 和 \(p\) 出现；而在第三个方程中，只有 \(u_x\) 和 \(u_y\) 出现。(注意，这个讨论只谈及解变量的矢量分量和不同的方程，而与自由度无关，事实上也与任何一种离散化无关)。我们可以用以下的 "耦合 "模式来描述这一点。 </p><p class="formulaDsp">
\[ \left[ \begin{array}{ccc} 1 &amp; 0 &amp; 1 \\ 0 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 0 \end{array} \right] \]
</p>
<p> 其中 "1 "表示两个变量（即FES系统的矢量分量）在各自的方程中耦合，而 "0 "表示没有耦合。 这些零意味着在通过标准的有限元公式进行离散化时，我们将不会向矩阵中写入条目，例如，将压力测试函数与压力形状函数耦合（与上述其他零类似）。那么为矩阵中的这些条目和稀疏模式分配内存就是一种浪费，你可以通过创建一个像上面那样的掩码来避免这种情况，该掩码向计算稀疏模式的（当前）函数描述这一点。如上所述，上面显示的掩码是指组成FES系统的组件，而不是自由度或形状函数。 这个函数被设计成通过 <code>couplings</code> 参数接受耦合模式，如上图所示，该参数包含::Coupling类型的值。它就像前面的函数一样建立矩阵结构，但如果不是由耦合模式指定的，就不创建矩阵元素。如果耦合是对称的，那么产生的稀疏模式也将是对称的。 如果使用中的有限元的一些或全部形状函数在一个以上的分量中是非零的（用交易二的话说：它们是 <a class="el" href="DEALGlossary.html#GlossPrimitive">非原始有限元</a>），就会有一个复杂的情况。 在这种情况下，采取对应于第一个非零分量的耦合元素，并忽略该分量的其他耦合元素。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00125">125</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga7b2627e9bde96b98d4fcf95b629e4fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b2627e9bde96b98d4fcf95b629e4fd4">&#9670;&nbsp;</a></span>make_flux_sparsity_pattern() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算建立在给定 <code>dof_handler</code> 上的矩阵的哪些条目可能是非零的，并创建一个代表这些非零位置的稀疏模式对象。这个函数是上述make_sparsity_pattern()函数的一个变体，它假定你想用来生成矩阵的双线性形式也包含了单元格之间<em>faces</em>的积分项（即，它包含了单元格之间的 "通量"，解释了这个函数的名称）。 这个函数对非连续加尔金方法很有用，标准的make_sparsity_pattern()函数只会为一个单元上的所有自由度与同一单元上的所有其他自由度耦合创建非零条目；然而，在DG方法中，每个单元上的所有或部分自由度也与通过共同面连接到当前单元的其他单元的自由度耦合。当前函数还创建了由这些额外耦合产生的矩阵中的非零条目。换句话说，与make_sparsity_pattern()所做的工作相比，这个函数计算了一个严格的非零项的超级集合。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>描述哪些自由度存在于哪些单元上的DoFHandler对象。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sparsity_pattern</td><td>要填入的稀疏度模式。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>稀疏度模式的实际类型可以是SparsityPattern、DynamicSparsityPattern、BlockSparsityPattern、BlockDynamicSparsityPattern或任何其他满足类似要求的类。假设疏散模式的大小与自由度的数量相匹配，并且如果疏散模式是 "静态 " 的，则有足够的未使用的非零条目来填充疏散模式（关于这意味着什么的更多信息，请参见 <a class="el" href="group__Sparsity.html">Sparsity patterns</a> ）。这个函数生成的非零条目被添加到对象以前可能的内容中，也就是说，以前添加的条目不会被删除。 </dd>
<dd>
如果稀疏模式由SparsityPattern类型的对象表示（而不是例如DynamicSparsityPattern），你需要记住在生成模式后使用 <a class="el" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">SparsityPattern::compress()</a> 。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00699">699</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="gaee18d72bf380f091c0fe21081e35768d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee18d72bf380f091c0fe21081e35768d">&#9670;&nbsp;</a></span>make_flux_sparsity_pattern() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数的作用与其他make_flux_sparsity_pattern()函数基本相同，但允许指定一些额外的参数。这些参数的含义与上述第一个make_sparsity_pattern()函数中讨论的相同。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00529">529</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="gaebdabb3b4e2882a6ee130c7d8115a0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebdabb3b4e2882a6ee130c7d8115a0df">&#9670;&nbsp;</a></span>make_flux_sparsity_pattern() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_integrals_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_integrals_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数的作用与另一个make_flux_sparsity_pattern()函数基本相同，但允许指定耦合矩阵，说明在你离散化的每个方程中，解变量的哪些成分是耦合的。这与上面第二个make_sparsity_pattern()函数中讨论的完全类似。 事实上，这个函数需要两个这样的掩码，一个是描述哪些变量在构成双线性方程的单元积分中相互耦合，哪些变量在面积分中相互耦合。如果你把只由1组成的掩码传递给这两个掩码，那么你将得到与你调用上述make_sparsity_pattern()函数中的第一个相同的稀疏性模式。通过将这些掩码中的一些条目设置为0，你可以得到一个更稀疏的稀疏模式。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l01372">1372</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga3b4ea7dfd313e388d868c4e4aa685799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4ea7dfd313e388d868c4e4aa685799">&#9670;&nbsp;</a></span>make_hanging_node_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_hanging_node_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l01787">1787</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="ga06c0301bc74dd4c67a3d1db1000647f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06c0301bc74dd4c67a3d1db1000647f3">&#9670;&nbsp;</a></span>make_zero_boundary_constraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_zero_boundary_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>zero_boundary_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为 <code>zero_boundary_constraints</code> 添加约束，对应于在给定的边界指标上强制执行零边界条件。 这个函数约束了边界给定部分的所有自由度。 在 <a class="el" href="step_36.html">step-36</a> 中使用了这个函数的一个变体，参数不同。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dof</td><td>要工作的DoFHandler。 </td></tr>
    <tr><td class="paramname">boundary_id</td><td>应该被计算约束的那部分边界的指标。如果这个数字等于 <a class="el" href="namespacenumbers.html#a1745778880e38cde9ef045471f4757fd">numbers::invalid_boundary_id</a> ，那么该域的所有边界都将被处理。 </td></tr>
    <tr><td class="paramname">zero_boundary_constraints</td><td>约束对象，约束条件将被写入其中。由于零边界值而产生的新约束将被简单地添加，保留之前存在的任何其他约束。然而，这只有在该对象以前的内容由不在这里处理的边界上的自由度的约束组成时才有效。如果以前有位于边界上的自由度的约束，那么这将构成冲突。参见 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块，以处理个别自由度上存在冲突约束的情况。 </td></tr>
    <tr><td class="paramname">component_mask</td><td>一个可选的组件掩码，将这个函数的功能限制在一个FES系统的子集上。对于非 <a class="el" href="DEALGlossary.html#GlossPrimitive">原始 </a> 形状函数，任何属于形状函数的自由度都会受到影响，其中至少有一个非零分量受到分量屏蔽的影响（见 <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ）。 如果省略这个参数，有限元中所有在边界上有自由度的分量将被考虑。 @ @ "" </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l03450">3450</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="ga326f0868782800e5fa9d8e90c9cef135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga326f0868782800e5fa9d8e90c9cef135">&#9670;&nbsp;</a></span>make_zero_boundary_constraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_zero_boundary_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>zero_boundary_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与前一个函数相同，只是对边界的所有部分进行处理，而不仅仅是那些有特定边界指标的部分。那么这个函数就相当于以 <a class="el" href="namespacenumbers.html#a1745778880e38cde9ef045471f4757fd">numbers::invalid_boundary_id</a> 为第二个参数调用前一个函数。 这个函数在 <a class="el" href="step_36.html">step-36</a> 中使用，例如。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l03536">3536</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="ga814d426ef355ed315bb57cea21a7630a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814d426ef355ed315bb57cea21a7630a">&#9670;&nbsp;</a></span>distribute_constraints_linear_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; distribute_constraints_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数接收一个AffineConstraints对象 <code>constraints</code> 和一个运算器示例 <code>exemplar</code> （这个示例通常是一个描述系统矩阵的线性运算器</p>
<p>-它只用于创建适当大小的域和范围向量，它的动作<code>vmult</code>从不使用）。) 一个与底层AffineConstraints对象的 "同质动作
"相关的LinearOperator对象被返回。 在向量 <code>u</code> 上应用LinearOperator对象的结果是一个向量 <code>v</code> ，它存储了在 <code>u</code> 上调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 的结果。</p>
<ul>
<li>有一个重要的区别：不均匀性不被应用，而是始终被视为0。 这个函数创建的LinearOperator对象主要在内部用于constrained_linear_operator()，以建立一个修正的线性方程组。如何用这种方法解决线性方程组，在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中有详细解释。</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>目前，这个函数对于分布式数据结构可能无法正确工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00064">64</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga52c9bbeff68309fdc7e4975eddba5eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52c9bbeff68309fdc7e4975eddba5eea">&#9670;&nbsp;</a></span>project_to_constrained_linear_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; project_to_constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个AffineConstraints <code>constraints</code> 和一个运算符示例 <code>示例，返回一个LinearOperator，该运算符是对受限自由度子空间的投影，即结果向量中对应于非受限自由度的所有条目被设置为零。</code> </p>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00156">156</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga4787b401a7e601750d85b8b4fc84c8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4787b401a7e601750d85b8b4fc84c8a5">&#9670;&nbsp;</a></span>constrained_linear_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个AffineConstraints对象 <code>constraints</code> 和一个LinearOperator <code>linop</code>, ，该函数创建一个LinearOperator对象，由三个操作和一个正则化组成。</p>
<div class="fragment"><div class="line">Ct linop C + Id_c;</div></div><!-- fragment --><p> 与</p>
<div class="fragment"><div class="line">C = <a class="code" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a>(constraints, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(C);</div><div class="line">Id_c = <a class="code" href="group__constraints.html#ga52c9bbeff68309fdc7e4975eddba5eea">project_to_constrained_linear_operator</a>(constraints, linop);</div></div><!-- fragment --><p> 而 <code>Id_c</code> 是对由所有与受限自由度相关的向量条目组成的子空间的投影。 这个LinearOperator对象与constrained_right_hand_side()一起使用，建立了以下修改后的线性方程系统。 </p><p class="formulaDsp">
\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]
</p>
<p> 具有给定的（无约束的）系统矩阵 \(A\) ，右手边 \(b\) ，以及具有不均匀性的线性约束 \(C\) 。 在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中对这种方法进行了详细解释。</p>
<dl class="section note"><dt>Note</dt><dd>目前，这个函数对于分布式数据结构可能无法正确工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00241">241</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1985f642cfa97d522ffe9d21d2313ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1985f642cfa97d522ffe9d21d2313ce2">&#9670;&nbsp;</a></span>constrained_right_hand_side() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; constrained_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个AffineConstraints对象 <code>constraints</code>, 一个LinearOperator <code>linop和一个右手边</code> <code>right_hand_side</code>, ，这个函数创建一个PackagedOperation，存储以下计算结果。</p>
<div class="fragment"><div class="line">Ct (right_hand_side</div><div class="line"></div><div class="line">- linop k)</div></div><!-- fragment --><p> 与</p>
<div class="fragment"><div class="line">C = <a class="code" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a>(constraints, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(C);</div></div><!-- fragment --><p>这个LinearOperator对象与constrained_right_hand_side()一起用于建立以下修改后的线性方程组。 </p><p class="formulaDsp">
\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]
</p>
<p> 具有给定的（无约束的）系统矩阵 \(A\) ，右手边 \(b\) ，以及具有不均匀性的线性约束 \(C\) 。 在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中对这种方法进行了详细解释。</p>
<dl class="section note"><dt>Note</dt><dd>目前，这个函数对于分布式数据结构可能无法正确工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00288">288</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga5e6b9de5ad09eb5009075618f08eb129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e6b9de5ad09eb5009075618f08eb129">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将由于Dirichlet边界条件引起的（代数）约束插入AffineConstraints <code>constraints</code>. 这个函数识别受Dirichlet边界条件约束的自由度，将它们添加到 <code>constraints</code> 中受约束的DoF列表中，并将各自的不均匀性设置为围绕边界插值的值。如果这个例程遇到一个已经被约束的DoF（例如被悬挂的节点约束，见下文，或任何其他类型的约束，例如来自周期性边界条件的约束），约束的旧设置（条目被约束的DoF，不均匀性）被保留，不会发生什么。 </p><dl class="section note"><dt>Note</dt><dd>当在一个AffineConstraints对象中结合具有悬挂节点约束和边界条件的自适应细化网格时，悬挂节点约束应该总是首先被设置，然后是边界条件，因为边界条件不会在已经被约束的自由度的第二次操作中被设置。这可以确保离散化保持所需的一致性。参见 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中关于冲突约束的讨论。 这个函数与上面的函数基本等同，只是它将其结果放入AffineConstraint对象中，而不是 <code>std::map</code>. 更多评论见上面的函数。 </dd></dl>

</div>
</div>
<a id="ga5255de72726a1fa50c4653ce59e6a438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5255de72726a1fa50c4653ce59e6a438">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述函数相同，但只取一对边界指标和相应的边界函数。同样的评论适用于前面的函数，特别是关于组件掩码的使用和函数对象的要求大小。 @ @ "" </p>

</div>
</div>
<a id="gaa39e86be1bee406512895d2b0377da87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa39e86be1bee406512895d2b0377da87">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用另一个interpolate_boundary_values()函数，见上文，使用<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim,spacedim&gt;(1)</code>. 与前一个函数的注释相同，特别是关于组件掩码的使用和函数对象的要求大小。 @ @ "" </p>

</div>
</div>
<a id="gaf2f61567fa003b5448fce53e0eec4b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2f61567fa003b5448fce53e0eec4b79">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用另一个interpolate_boundary_values()函数，见上文，<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim,spacedim&gt;(1)</code>. 与前一个函数的注释相同，特别是关于组件掩码的使用和函数对象的要求大小。 </p>

</div>
</div>
<a id="ga32a2c72e6d0bc19fb346d51767e48c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32a2c72e6d0bc19fb346d51767e48c89">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将一个函数投影到域的边界，使用给定的面的正交公式。该函数识别受Dirichlet边界条件约束的自由度，将其添加到 <code>constraints</code> 中的受约束自由度列表中，并将各自的不均匀性设置为投影操作产生的值。如果这个例程遇到一个已经被约束的DoF（例如被悬挂的节点约束，见下文，或任何其他类型的约束，例如来自周期性边界条件的约束），约束的旧设置（条目被约束的DoF，不均匀性）被保留，不会发生什么。 </p><dl class="section note"><dt>Note</dt><dd>当在一个AffineConstraints对象中结合具有悬挂节点约束和边界条件的自适应细化网格时，悬挂节点约束应该总是首先被设置，然后是边界条件，因为边界条件不会在已经被约束的自由度的第二次操作中被设置。这可以确保离散化保持所需的一致性。参见 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中关于冲突约束的讨论。 如果 <code>component_mapping</code> 为空，则假定 <code>boundary_function</code> 的分量数与 <code>dof</code>. 所使用的有限元的分量数一致。 在1d中，投影等于插值。因此，interpolate_boundary_values被调用。 <ul>
<li><code>component_mapping:</code> 如果 <code>boundary_functions</code> 和 <code>dof</code> 中的组件不重合，这个向量允许它们被重新映射。如果这个向量不是空的，它必须有一个条目代表 <code>中的每个组件。这个条目是</code> <code>boundary_functions</code> 中的分量编号，应该用于 <code>dof</code>. 中的这个分量。 默认情况下，不应用重映射。 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf550f1f801988790bf89c099e7ff2fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf550f1f801988790bf89c099e7ff2fb0">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用project_boundary_values()函数，见上文，使用<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim,spacedim&gt;(1)</code>. 。 </p>

</div>
</div>
<a id="ga190b302dc1ee7c89727c94c083d132d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga190b302dc1ee7c89727c94c083d132d2">&#9670;&nbsp;</a></span>project_boundary_values_curl_conforming_l2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_curl_conforming_l2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是project_boundary_values_curl_conforming函数的一个更新版本。其目的是修复在使用前一个函数时与非矩形几何体（即具有非矩形面的元素）一起使用的一个问题。所用的L2投影方法取自PD Ledger, K Morgan and O Hassan的论文 "Electromagnetic Scattering simulation using an H (curl) conforming hp-finite element method in three dimensions" ( Int. J. Num. Meth. Fluids, Volume 53, Issue 8, pages 1267-1296) 。 该函数将计算对应于 \(\vec{n}\times\vec{E}=\vec{n}\times\vec{F}\) 形式的Dirichlet边界条件的约束，即 \(\vec{E}\) 和 \(f\) 的切向分量应相吻合。 </p><h4>Computing constraints</h4>
<p>为了计算约束条件，我们使用基于上述论文的投影方法。在二维中，对于基于边缘的形状函数，无论有限元的顺序如何，这都是在单一阶段完成的。在三维中，这是在两个阶段完成的，首先是边，然后是面。 对于每个单元，每个边 \(e\) 通过解决线性系统 \(Ax=b\) 进行投影，其中 \(x\) 是边上自由度的约束向量， \(A_{ij} = \int_{e} (\vec{s}_{i}\cdot\vec{t})(\vec{s}_{j}\cdot\vec{t}) dS\) \(b_{i} = \int_{e} (\vec{s}_{i}\cdot\vec{t})(\vec{F}\cdot\vec{t}) dS\) 是 \(\vec{s}_{i}\) 形状函数， \(\vec{t}\) 是切线向量。 一旦所有的边缘约束， \(x\) 被计算出来，我们可以用类似的方式计算面的约束，同时考虑到边缘的残差。 对于单元格上的每个面， \(f\) ，我们解决线性系统 \(By=c\) ，其中 \(y\) 是面的自由度约束矢量， \(B_{ij} = \int_{f} (\vec{n} \times \vec{s}_{i}) \cdot (\vec{n} \times \vec{s}_{j}) dS\) \(c_{i} = \int_{f} (\vec{n} \times \vec{r}) \cdot (\vec{n} \times \vec{s}_i) dS\) 和 \(\vec{r} = \vec{F} - \sum_{e \in f} \sum{i \in e} x_{i}\vec{s}_i\) ，是边缘残差。 然后在解决方案 \(x\) 和 \(y\) 中给出所产生的约束。 如果AffineConstraints <code>constraints</code> 中包含数值或其他约束，那么如果要使用的边界部分的节点已经在约束列表中，那么新的约束将被添加或覆盖旧的约束。这可以通过使用不均匀约束来处理。请注意，当结合自适应网格和这种约束时，应该首先设置Dirichlet条件，然后通过悬挂节点约束完成，以确保离散化保持一致。参见 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中关于冲突约束的讨论。 </p><h4>Arguments to this function</h4>
<p>该函数明确用于FE_Nedelec元素，或包含FE_Nedelec元素的FESystem元素。如果在调用该函数时使用任何其他有限元，则会产生一个异常。用户在使用此函数时必须保证FESystem元素的正确设置，因为在这种情况下不可能进行检查。 这个函数的第二个参数表示有限元的第一个矢量分量，对应于你希望约束的矢量函数。例如，如果我们正在求解三维麦克斯韦方程，并且有分量 \((E_x,E_y,E_z,B_x,B_y,B_z)\) ，我们想要边界条件 \(\vec{n}\times\vec{B}=\vec{n}\times\vec{f}\) ，那么 <code>第一_向量_分量将是3。在这个例子中，</code> <code>boundary_function</code> 必须返回6个分量，前3个对应于 \(\vec{E}\) ，后3个对应于 \(\vec{B}\) 。隐含地假定矢量正好有 <code>dim</code> 个分量，这些分量的排序方式与我们通常对坐标方向的排序方式相同，即 \(x\) -， \(y\) -，最后是 \(z\) -分量。 参数 <code>boundary_component</code> 对应于面的编号 <code>边界_id。</code> <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> 是一个非法值，因为它是为内部面保留的。 最后一个参数被表示为计算边界点的法向量 \(\vec{n}\) 。 @ @ "" </p>

</div>
</div>
<a id="gac0d845992528893a53ad7f37a15d0aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d845992528893a53ad7f37a15d0aaa">&#9670;&nbsp;</a></span>project_boundary_values_curl_conforming_l2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_curl_conforming_l2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_collection</em> = <code><a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping_collection</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>project_boundary_values_curl_conforming_l2（上文）的hp-namespace版本。 </p>

</div>
</div>
<a id="gaac8ab38430250535a694205a7372f5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac8ab38430250535a694205a7372f5a7">&#9670;&nbsp;</a></span>project_boundary_values_div_conforming() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_div_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算对应于 \(\vec{n}^T\vec{u}=\vec{n}^T\vec{f}\) 形式的边界条件的约束，即解 \(u\) 和给定 \(f\) 的法线分量应重合。函数 \(f\) 由 <code>boundary_function</code> 给出，所得到的约束被添加到 <code>约束中，用于具有边界指标的面</code> <code>boundary_component</code>. 这个函数是明确写给FE_RaviartThomas元素使用的。因此，如果它与其他有限元一起被调用，就会抛出一个异常。 如果AffineConstraints对象 <code>constraints</code> 之前包含数值或其他约束，那么如果要使用的边界部分的一个节点已经在约束列表中，那么就会添加新的约束或覆盖旧的约束。这可以通过使用不均匀约束来处理。请注意，当结合自适应网格和这种约束时，应该首先设置Dirichlet条件，然后通过悬挂节点约束完成，以确保离散化保持一致。参见 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中关于冲突约束的讨论。 参数 <code>first_vector_component</code> 表示有限元中的第一个矢量分量，对应于你要约束的矢量函数 \(\vec{u}\) 。隐含地假定矢量正好有 <code>dim</code> 个分量，这些分量的排序方式与我们通常对坐标方向的排序方式相同，即 \(x\) -， \(y\) -，最后是 \(z\) -分量。 参数 <code>boundary_component</code> 对应的是应用边界条件的面的 <code>boundary_id</code> 。 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> 是一个非法值，因为它被保留给内部面。 <code>mapping</code> 用于计算边界点的法向量 \(\vec{n}\) 。 </p><h4>Computing constraints</h4>
<p>为了计算约束条件，我们在位于边界的每个面上使用Brezzi, Fortin (Mixed and Hybrid Finite Element Methods, Springer, 1991)中提出的插值运算。 @ @ "" </p>

</div>
</div>
<a id="gaff48f8eaf46c5618b95eefa23081449e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff48f8eaf46c5618b95eefa23081449e">&#9670;&nbsp;</a></span>project_boundary_values_div_conforming() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values_div_conforming </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_collection</em> = <code><a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt;&#160;dim&#160;&gt;::mapping_collection</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述hp-namespace的情况相同。 @ @ "" </p>

</div>
</div>
<a id="ga54fdd3b0f9e4e4ad02cf932901bd0659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54fdd3b0f9e4e4ad02cf932901bd0659">&#9670;&nbsp;</a></span>compute_nonzero_normal_flux_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_nonzero_normal_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;&#160;dim&#160;&gt;()&#160;.template&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数计算对应于 \(\vec u \cdot \vec n=\vec u_\Gamma \cdot \vec n\) 形式的边界条件的约束，即法向通量约束，其中 \(\vec u\) 是一个矢量值的解变量， \(\vec u_\Gamma\) 是一个规定的矢量场，我们希望其法向分量等于解的法向分量。 这些条件完全具有AffineConstraints类所处理的形式，即它们将边界自由度的<em>linear combination</em>与相应的值（约束的不均匀性）联系起来。因此，当前函数创建了一个写进AffineConstraints容器的约束列表。这个对象可能已经有了一些内容，例如来自悬挂节点的约束，但仍未触及。这些约束条件必须像其他此类约束条件一样应用于线性系统，也就是说，你必须在求解前用约束条件浓缩线性系统，而且你必须在求解后分配解向量。 这个函数处理的情况比 <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints()</a> 更普遍（它只能处理 \(\vec u_\Gamma \cdot \vec n = 0\) 的情况，并在 <a class="el" href="step_31.html">step-31</a> 和 <a class="el" href="step_32.html">step-32</a> 中使用）。然而，由于适用于该函数的所有内容也作为特例适用于当前的函数，所以下面的讨论与两者都有关。 </p><dl class="section note"><dt>Note</dt><dd>这个函数在1d中没有什么意义，所以如果 <code>dim</code> 等于1，它会抛出一个异常。 <h4>Arguments to this function</h4>
</dd></dl>
<p>这个函数的第二个参数表示有限元中的第一个矢量分量，对应于你要约束的矢量函数。例如，如果我们正在求解2d中的斯托克斯方程，有限元有分量 \((u,v,p)\) ，那么如果你打算约束矢量 \((u,v)^T \cdot \vec n = \vec u_\Gamma \cdot \vec n\) ， <code>first_vector_component需要为0。</code> 另一方面，如果我们在三维中求解麦克斯韦方程，有限元有分量 \((E_x,E_y,E_z,B_x,B_y,B_z)\) ，我们想要边界条件 \(\vec B\cdot \vec n=\vec B_\Gamma\cdot \vec n\) ，那么 <code>first_vector_component</code> 将是3。隐含地假设矢量正好有 <code>dim</code> 个分量，这些分量的排序方式与我们通常对坐标方向的排序方式相同，即 \(x\) -， \(y\) -，最后是 \(z\) -分量。该函数假设，但不能检查， <code>[first_vector_component,first_vector_component+dim)</code> 范围内的矢量分量来自同一个基础有限元。例如，在上面的Stokes例子中，使用 <code><a class="el" href="classFESystem.html">FESystem</a>&lt;dim&gt;(<a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(2), 1, <a class="el" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim)</code> 是没有意义的（注意第一个速度矢量分量是 \(Q_2\) 元素，而其他的都是 \(Q_1\) 元素），因为在边界上会有定义了 \(x\) -速度的点，但没有相应的 \(y\) -或 \(z\) -velocities。 第三个参数表示要强制执行边界条件的边界指标集。请注意，正如下面所解释的，这是少数几个函数之一，在这些函数中，我们只用一个边界指标多次调用该函数，还是用整个边界指标一次调用该函数，是有区别的。 参数四（ <code>function_map</code>) 描述了每个边界id的边界函数 \(\vec u_\Gamma\) 。函数 <code>function_map[id]</code> 用于id为 <code>id</code> 的边界，取自集合 <code>boundary_ids</code>. 中的每个函数预计都有 <code>dim</code> 成分，这些成分的使用与 <code>first_vector_component</code>. 无关 映射参数用于计算边界点，在边界点上，函数需要从边界描述中请求法向量 \(\vec n\) 。 </p><dl class="section note"><dt>Note</dt><dd>当在一个AffineConstraints对象中结合具有悬挂节点约束和边界条件的自适应细化网格时，悬挂节点约束应该总是首先被设置，然后是边界条件，因为边界条件不会在已经被约束的自由度的第二次操作中被设置。这可以确保离散化保持所需的一致性。参见 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中关于冲突约束的讨论。 <h4>Computing constraints in 2d</h4>
</dd></dl>
<p>计算这些约束需要一些智慧。主要问题是围绕着法向量是什么这个问题。考虑一下下面的情况。 &lt;p ALIGN="center" </p><blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<div class="image">
<img src="no_normal_flux_1.png" alt="no_normal_flux_1.png"/>
</div>
 <p>这里，我们有两个使用双线性映射（即MappingQGeneric(1)）的单元格。因此，对于每一个单元格来说，法向量都是垂直于直边的。如果顶部和右侧的两条边是为了近似弯曲的边界（如虚线所示），那么两个计算出来的法向量都不等于准确的法向量（尽管随着网格的进一步细化，它们近似于法向量）。更糟糕的是，如果我们用两个单元的法线向量来约束公共顶点的 \(\vec u \cdot \vec n= \vec u_\Gamma \cdot \vec n\) ，那么我们就用两个线性独立的向量来约束向量 \(\vec u\) ；因此，在这一点上的约束将是 \(\vec u=\vec u_\Gamma\) （即向量的<em>all</em>分量），这并不是我们想要的结果。 为了处理这种情况，算法的工作方式如下：在我们想要约束 \(\vec u\) 的每一点，我们首先收集相邻单元在这一点可能计算的所有法向量。然后我们不对这些法向量中的<em>each</em>进行约束 \(\vec u \cdot \vec n=\vec u_\Gamma \cdot \vec n\) ，而只对法向量中的<em>average</em>进行约束。在上面的例子中，我们因此只记录了一个单一的约束 \(\vec u \cdot \vec {\bar n}=\vec u_\Gamma \cdot \vec {\bar n}\) ，其中 \(\vec {\bar n}\) 是两个指定法向量的平均值。 不幸的是，这还远远不够。考虑一下这里的情况。 </p>
<div class="image">
<img src="no_normal_flux_2.png" alt="no_normal_flux_2.png"/>
</div>
 <p>如果顶边和右边又近似于一个弯曲的边界，而左边的边界是一个单独的边界（例如直的），所以确切的边界在左顶点确实有一个角，那么上面的构造就不起作用了：在这里，我们确实希望在这一点上的约束是 \(\vec u\) （因为相对于左边的法线以及上面的法线矢量的法线速度应该是零），而不是说平均法线矢量方向的速度是零。 因此，我们使用以下启发式方法来确定在某一点计算的所有法向量是否要被平均化：如果同一点的两个法向量是在<em>different</em>单元上计算的，那么它们就要被平均化。这包括上面的第一个例子。如果它们是从同一个单元计算出来的，那么它们不同的事实被认为是表明它们来自边界的不同部分，可能被一个真正的角所连接，因此必须不被平均化。 这个方案有一个问题。例如，如果我们在上面考虑的同一个域，用下面的网格进行离散，那么我们就会陷入麻烦。 </p>
<div class="image">
<img src="no_normal_flux_3.png" alt="no_normal_flux_3.png"/>
</div>
 <p>这里，算法假设边界在面 \(F1\) 和 \(F2\) 连接处没有角，因为在这一点上有两个不同的法向量从不同的单元计算出来。如果你想在这一点上有一个确切的边界角，处理这个问题的唯一方法是给边界的两个部分分配不同的边界指标，并调用这个函数两次，一次针对每个边界指标；这样做每次调用只能得到一个法向量（因为我们一次只考虑一个边界部分），结果是法向量不会被平均化。在笛卡尔网格上的重心角周围使用该函数时，也需要考虑到这种情况。如果法向流边界条件要在非直角坐标系网格上的重心角处执行，我们甚至可能在约束中得到循环，因为一般来说，我们会约束来自两边的不同分量。在这种情况下，首先在重心顶点上设置一个无滑移约束。 </p><h4>Computing constraints in 3d</h4>
<p>在三维中，情况更为复杂。考虑以下情况，我们要在被标记的顶点计算约束。 </p>
<div class="image">
<img src="no_normal_flux_4.png" alt="no_normal_flux_4.png"/>
</div>
 <p>在这里，我们得到四个不同的法向量，其中一个来自在顶点相遇的四个面。尽管它们可能形成一个完整的向量集，但我们的目的不是在这一点上约束向量场的所有成分。相反，我们希望仍然允许切向流动，其中 "切向 "一词必须得到适当的定义。 在这种情况下，算法进行如下：对于在这一点上计算了两个切向矢量的每个单元，我们计算不受约束的方向，作为两个切向矢量的外积（如果有必要，乘以减一）。然后我们对这些切向矢量进行平均。最后，我们计算垂直于这个平均切线方向的两个方向的约束。 有些情况下，一个单元贡献了两个切向，而另一个单元只贡献了一个切向；例如，如果左边单元的顶面和正面都属于选定的边界，而只有右边单元的顶面属于边界，就会发生这种情况，也许这表明域的整个正面部分是一个平滑流形，而顶部确实形成了两个独立的流形，在一个山脊上相遇，而且只希望在正面流形和顶部的右边流形上设置法向流动边界条件。在这样的情况下，很难定义应该发生什么。目前的实现只是忽略了只贡献了一个法向的单元的贡献。在所示的例子中，这是可以接受的，因为左边单元的正面的法向量与右边单元的正面提供的法向量是一样的（表面是平面的），但是如果前面的流形是弯曲的，这将是一个问题。无论如何，不清楚在这种情况下该如何进行，忽略单细胞可能是最好的办法了。 </p><h4>Results</h4>
<p>因为它能产生很好的图片，这里有两张圆和球体上的矢量场的图片，这个函数计算的约束被应用于此（为了说明问题，我们强制执行零法线通量，这可以更容易地使用 <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints()</a>, 计算，因为这必须导致<em>tangential</em>矢量场）。 </p>
<div class="image">
<img src="no_normal_flux_5.png" alt="no_normal_flux_5.png"/>
</div>
 <div class="image">
<img src="no_normal_flux_6.png" alt="no_normal_flux_6.png"/>
</div>
 <p>矢量场在物理上是不合理的，但切向性约束显然是被执行的。事实上，向量场在边界上的某些点是零的，这是创建方式的一个伪命题，它没有被约束在这些点上为零。 @ @ "" </p>

</div>
</div>
<a id="ga0d16c332aaa652e8905a6f48208e4500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d16c332aaa652e8905a6f48208e4500">&#9670;&nbsp;</a></span>compute_no_normal_flux_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_no_normal_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;&#160;dim&#160;&gt;()&#160;.template&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数与compute_nonzero_normal_flux_constraints()函数的作用相同（更多信息见那里），但用于同质法向流约束的更简单情况，即用于施加条件 \(\vec u \cdot \vec n= 0\) 。这个函数在 <a class="el" href="step_31.html">step-31</a> 和 <a class="el" href="step_32.html">step-32</a> 中使用。 @ @ "" </p>

</div>
</div>
<a id="ga1b73118e3a950d33515ae649b9014d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b73118e3a950d33515ae649b9014d04">&#9670;&nbsp;</a></span>compute_nonzero_tangential_flux_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_nonzero_tangential_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;&#160;dim&#160;&gt;()&#160;.template&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算对应于 \(\vec u \times \vec n=\vec u_\Gamma \times \vec n\) 形式的边界条件的约束，即切向流约束，其中 \(\vec u\) 是一个矢量值的解变量， \(\vec u_\Gamma\) 是规定的矢量场，我们希望其切向分量与解的切向分量相等。这个函数正好约束那些不受 <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints()</a>, 约束的dim-1矢量值分量，并留下一个不受约束的分量，这个分量受到该函数的约束。 @ @ "" </p>

</div>
</div>
<a id="gad396065c624ae6c5d843e22fb75c3c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad396065c624ae6c5d843e22fb75c3c36">&#9670;&nbsp;</a></span>compute_normal_flux_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::compute_normal_flux_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>first_vector_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code>(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt;&#160;dim&#160;&gt;()&#160;.template&#160;<a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt;&#160;dim,&#160;spacedim&#160;&gt;())</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述同质切向流约束相同。 @ @ "" </p>

</div>
</div>
<a id="ga814d426ef355ed315bb57cea21a7630a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814d426ef355ed315bb57cea21a7630a">&#9670;&nbsp;</a></span>distribute_constraints_linear_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; distribute_constraints_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数接收一个AffineConstraints对象 <code>constraints</code> 和一个运算器示例 <code>exemplar</code> （这个示例通常是一个描述系统矩阵的线性运算器</p>
<p>-它只用于创建适当大小的域和范围向量，它的动作<code>vmult</code>从不使用）。) 一个与底层AffineConstraints对象的 "同质动作
"相关的LinearOperator对象被返回。 在向量 <code>u</code> 上应用LinearOperator对象的结果是一个向量 <code>v</code> ，它存储了在 <code>u</code> 上调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 的结果。</p>
<ul>
<li>有一个重要的区别：不均匀性不被应用，而是始终被视为0。 这个函数创建的LinearOperator对象主要在内部用于constrained_linear_operator()，以建立一个修正的线性方程组。如何用这种方法解决线性方程组，在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中有详细解释。</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>目前，这个函数对于分布式数据结构可能无法正确工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00064">64</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga52c9bbeff68309fdc7e4975eddba5eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52c9bbeff68309fdc7e4975eddba5eea">&#9670;&nbsp;</a></span>project_to_constrained_linear_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; project_to_constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个AffineConstraints <code>constraints</code> 和一个运算符示例 <code>示例，返回一个LinearOperator，该运算符是对受限自由度子空间的投影，即结果向量中对应于非受限自由度的所有条目被设置为零。</code> </p>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00156">156</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga4787b401a7e601750d85b8b4fc84c8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4787b401a7e601750d85b8b4fc84c8a5">&#9670;&nbsp;</a></span>constrained_linear_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个AffineConstraints对象 <code>constraints</code> 和一个LinearOperator <code>linop</code>, ，该函数创建一个LinearOperator对象，由三个操作和一个正则化组成。</p>
<div class="fragment"><div class="line">Ct linop C + Id_c;</div></div><!-- fragment --><p> 与</p>
<div class="fragment"><div class="line">C = <a class="code" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a>(constraints, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(C);</div><div class="line">Id_c = <a class="code" href="group__constraints.html#ga52c9bbeff68309fdc7e4975eddba5eea">project_to_constrained_linear_operator</a>(constraints, linop);</div></div><!-- fragment --><p> 而 <code>Id_c</code> 是对由所有与受限自由度相关的向量条目组成的子空间的投影。 这个LinearOperator对象与constrained_right_hand_side()一起使用，建立了以下修改后的线性方程系统。 </p><p class="formulaDsp">
\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]
</p>
<p> 具有给定的（无约束的）系统矩阵 \(A\) ，右手边 \(b\) ，以及具有不均匀性的线性约束 \(C\) 。 在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中对这种方法进行了详细解释。</p>
<dl class="section note"><dt>Note</dt><dd>目前，这个函数对于分布式数据结构可能无法正确工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00241">241</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1985f642cfa97d522ffe9d21d2313ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1985f642cfa97d522ffe9d21d2313ce2">&#9670;&nbsp;</a></span>constrained_right_hand_side() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; constrained_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个AffineConstraints对象 <code>constraints</code>, 一个LinearOperator <code>linop和一个右手边</code> <code>right_hand_side</code>, ，这个函数创建一个PackagedOperation，存储以下计算结果。</p>
<div class="fragment"><div class="line">Ct (right_hand_side</div><div class="line"></div><div class="line">- linop k)</div></div><!-- fragment --><p> 与</p>
<div class="fragment"><div class="line">C = <a class="code" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a>(constraints, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(C);</div></div><!-- fragment --><p>这个LinearOperator对象与constrained_right_hand_side()一起用于建立以下修改后的线性方程组。 </p><p class="formulaDsp">
\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]
</p>
<p> 具有给定的（无约束的）系统矩阵 \(A\) ，右手边 \(b\) ，以及具有不均匀性的线性约束 \(C\) 。 在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中对这种方法进行了详细解释。</p>
<dl class="section note"><dt>Note</dt><dd>目前，这个函数对于分布式数据结构可能无法正确工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00288">288</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga5a0600dbcf28ec5bf58de34e21e1fb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a0600dbcf28ec5bf58de34e21e1fb4b">&#9670;&nbsp;</a></span>make_sparsity_pattern() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构建一个稀疏模式，允许在两个不同但相关的网格上耦合自由度。 这个想法是，如果两个给定的DoFHandler对象对应于两个不同的网格（并且可能对应于在这些单元上使用的不同的有限元），但是如果它们所基于的两个三角形是通过分层细化从同一个粗网格导出的，那么人们可能会设置一个问题，想用一个网格的形状函数来测试另一个网格的形状函数。特别是，这意味着来自第一个网格上的单元的形状函数要与第二个网格上位于相应单元的形状函数进行测试；这种对应关系是IntergridMap类可以确定的。 这个函数然后构建一个稀疏模式，其中代表行的自由度来自第一个给定的DoFHandler，而对应列的自由度则来自第二个DoFHandler。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00216">216</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga52de1b60d79f9ef5e0c642d7da16f0a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52de1b60d79f9ef5e0c642d7da16f0a8">&#9670;&nbsp;</a></span>make_flux_sparsity_pattern() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_flux_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>couplings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_couplings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classbool.html">bool</a>(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>face_has_flux_coupling</em> = <code>&amp;internal::always_couple_on_faces&lt;dim,&#160;spacedim&gt;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数与之前的make_flux_sparsity_pattern()函数的功能基本相同，但允许应用AffineConstraints对象。这对于有限元的某些部分是连续的，某些部分是不连续的情况很有用，允许对连续部分施加约束，同时也建立不连续部分所需的通量项。 可选的 <code>face_has_flux_coupling</code> 可以用来指定在哪些面上发生通量耦合。这允许在使用双线性形式时创建一个更稀疏的模式，即通量项只出现在三角结构中的一个子集的面上。默认情况下，通量耦合被添加到所有内部面。 <code>face_has_flux_coupling</code> 应该是一个函数，它接收一个active_cell_iterator和一个面的索引，如果该面有一个通量耦合，应该返回true。当使用 <a class="el" href="classDoFHandler.html">DoFHandler</a> 时，我们可以，比如说，使用 </p><div class="fragment"><div class="line"><span class="keyword">auto</span> face_has_flux_coupling =</div><div class="line"> [](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                    face_index) {</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;face_center = cell-&gt;face(face_index)-&gt;center();</div><div class="line">   <span class="keywordflow">return</span> 0 &lt; face_center[0];</div><div class="line"> };</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l01399">1399</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="ga9f970db3b035e9813fc7201a2d18d032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f970db3b035e9813fc7201a2d18d032">&#9670;&nbsp;</a></span>make_boundary_sparsity_pattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_boundary_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建边界矩阵的稀疏模式。更多信息请参见该类的一般文档。 该函数基本上做了其他make_sparsity_pattern()函数所做的事情，但假定用于建立矩阵的双线性形式不包括域的积分，而只包括域的边界上的积分。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00360">360</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="gab3dd70fabd9fe942ce3c127e6510024e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3dd70fabd9fe942ce3c127e6510024e">&#9670;&nbsp;</a></span>make_boundary_sparsity_pattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename SparsityPatternType , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::make_boundary_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是之前make_boundary_sparsity_pattern()函数的一个变体，我们假设将产生矩阵的边界积分只延伸到边界的那些部分，这些部分的边界指标在这个函数的 <code>boundary_ids</code> 参数中列出。 这个函数本来可以通过传递一个 <code>set</code> 的边界_id数字来写。然而，整个deal.II中处理边界指标的大多数函数都采取边界指标和相应的边界函数的映射，即一个 std::map&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const Function&lt;spacedim,number&gt;*&gt;参数。相应地，这个函数也是这样做的，尽管实际的边界函数在这里被忽略了。 因此，如果你没有任何这样的边界函数，只要用你想要的边界指标创建一个地图，并将函数指针设置为空指针）。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__sparsity_8cc_source.html#l00431">431</a> of file <a class="el" href="dof__tools__sparsity_8cc_source.html">dof_tools_sparsity.cc</a>.</p>

</div>
</div>
<a id="gaae648a4b093f351b25eba50e8567b6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae648a4b093f351b25eba50e8567b6ef">&#9670;&nbsp;</a></span>compute_intergrid_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::compute_intergrid_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fine_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_to_fine_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>当问题中的不同变量被离散在不同的网格上时，这个函数被使用，其中一个网格严格地比另一个更粗。一个例子是优化问题，控制变量通常在比状态变量更粗的网格上离散。 该函数的结果可以在数学上表述如下。让 \({\cal T}_0\) 和 \({\cal T}_1\) 是两个网格，其中 \({\cal T}_1\) 是由 \({\cal T}_0\) 严格通过细化或不考虑 \({\cal T}_0\) 的单元而得到的。在两者上使用相同的有限元，有与这些网格相关的函数空间 \({\cal V}_0\) 和 \({\cal V}_1\) 。那么每个函数 \(v_0 \in {\cal V}_0\) 当然也可以在 \({\cal V}_1\) 中精确表示，因为通过构造 \({\cal V}_0 \subset {\cal V}_1\) 。 然而，并不是 \({\cal V}_1\) 中的每个函数都能被表达为 \({\cal V}_0\) 的形状函数的线性组合。可以表示的函数位于 \({\cal V}_1\) 的一个同质子空间（即 \({\cal V}_0\) ，当然），这个子空间可以用 \(CV=0\) 形式的线性约束来表示，其中 \(V\) 是函数 \(v\in {\cal V}_1\) 的结点值的向量。换句话说，每个同时满足 \(v_h\in {\cal V}_0\) 的函数 \(v_h=\sum_j V_j \varphi_j^{(1)} \in {\cal V}_1\) 都自动满足 \(CV=0\) 。这个函数以AffineConstraints对象的形式计算矩阵 \(C\) 。 这些约束的构造如下：对于粗网格上的每个自由度（即形状函数），我们计算它在细网格上的表现，即细网格上的形状函数的线性组合看起来如何与粗网格上的形状函数相像。从这些信息中，我们可以计算出如果一个线性方程在细网格上的解在粗网格上可以表示出来，那么这些约束就必须成立。如何计算这些约束条件的确切算法相当复杂，最好是通过阅读源代码来理解，其中包含许多注释。 这个函数的用法如下：它接受两个DoF处理程序作为参数，第一个是指粗网格，第二个是指细网格。在这两者上，一个有限元由DoF处理程序对象表示，通常会有几个向量分量，可能属于不同的基元。因此，这个函数的第二和第四个参数说明粗网格上的哪个矢量分量应被用来限制细网格上的所述分量。两个网格上的各个分量所使用的有限元必须是相同的。一个例子可以说明这一点：考虑一个优化问题，控制 \(q\) 在粗网格上离散，状态变量 \(u\) （和相应的拉格朗日乘子 \(\lambda\) ）在细网格上离散。它们分别使用片状常数不连续、连续线性和连续线性元素进行离散。在粗网格上只有参数 \(q\) 被表示，因此粗网格上的DoFHandler对象只表示一个变量，用片状常数不连续元素离散。那么，粗网格上表示矢量分量的参数将是零（唯一可能的选择，因为粗网格上的变量是标量）。如果细网格FES系统中变量的排序是 \(u, q, \lambda\) ，那么对应于矢量分量的函数的第四个参数将是1（对应于变量 \(q\) ；0将是 \(u\) ，2将是 \(\lambda\) ）。 该函数还需要一个IntergridMap类型的对象，代表如何从粗网格单元到细网格上的相应单元。原则上，这个对象可以由函数本身从两个DoFHandler对象中生成，但由于它在使用不同网格的程序中可能是可用的，所以函数只是把它作为一个参数。 计算出的约束被输入一个AffineConstraints类型的变量中；之前的内容不会被删除。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l03167">3167</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
<a id="gae1126ff8e1542c36e6fcc2d825006d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1126ff8e1542c36e6fcc2d825006d7f">&#9670;&nbsp;</a></span>compute_intergrid_transfer_representation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFTools::compute_intergrid_transfer_representation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>coarse_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fine_grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fine_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_to_fine_grid_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, float &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer_representation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数生成一个矩阵，当一个元素数与粗网格上该分量的自由度相同的数据向量乘以这个矩阵时，我们得到一个元素数与细网格上全局自由度相同的向量。细网格上有限元场的其他矢量分量的所有元素都不被触及。 细网格的三角化可以是分布式的。当并行调用时，每个进程必须有一份粗网格的副本。在这种情况下，函数返回本地拥有的一组单元的转移表示。 这个函数的输出是一种压缩格式，可以用来构造相应的稀疏转移矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="dof__tools__constraints_8cc_source.html#l03350">3350</a> of file <a class="el" href="dof__tools__constraints_8cc_source.html">dof_tools_constraints.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
