<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceUtilities.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilities Namespace Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceUtilities_1_1CUDA"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1CUDA.html">CUDA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1LinearAlgebra"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1LinearAlgebra.html">LinearAlgebra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1MPI"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html">MPI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1System"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1System.html">System</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1Trilinos"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1Trilinos.html">Trilinos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91c51abf8f95716de44ab318e4c0857d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a91c51abf8f95716de44ab318e4c0857d">create_evenly_distributed_partitioning</a> (const unsigned <a class="el" href="classint.html">int</a> my_partition_id, const unsigned <a class="el" href="classint.html">int</a> n_partitions, const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> total_size)</td></tr>
<tr class="separator:a91c51abf8f95716de44ab318e4c0857d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244dcff7d2307d223bd2da9bf0b13ec0"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , class... FunctionArgs&gt; </td></tr>
<tr class="memitem:a244dcff7d2307d223bd2da9bf0b13ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt; ReturnType, FunctionArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a244dcff7d2307d223bd2da9bf0b13ec0">mutable_bind</a> (ReturnType(*function)(FunctionArgs...), typename <a class="el" href="structidentity.html">identity</a>&lt; FunctionArgs &gt;::type &amp;&amp;... arguments)</td></tr>
<tr class="separator:a244dcff7d2307d223bd2da9bf0b13ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77cb0654e4a283ed11a62fa5913ae86"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , class... FunctionArgs&gt; </td></tr>
<tr class="memitem:ac77cb0654e4a283ed11a62fa5913ae86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt; ReturnType, FunctionArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ac77cb0654e4a283ed11a62fa5913ae86">mutable_bind</a> (std::function&lt; ReturnType(FunctionArgs...)&gt;, typename <a class="el" href="structidentity.html">identity</a>&lt; FunctionArgs &gt;::type &amp;&amp;... arguments)</td></tr>
<tr class="separator:ac77cb0654e4a283ed11a62fa5913ae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac040436711f265a2285730068b83030e"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , class... FunctionArgs&gt; </td></tr>
<tr class="memitem:ac040436711f265a2285730068b83030e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt; ReturnType, FunctionArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ac040436711f265a2285730068b83030e">mutable_bind</a> (ReturnType(*function)(FunctionArgs...))</td></tr>
<tr class="separator:ac040436711f265a2285730068b83030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14397edd57e34da458930d8e83a2de4"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , class... FunctionArgs&gt; </td></tr>
<tr class="memitem:ad14397edd57e34da458930d8e83a2de4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt; ReturnType, FunctionArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ad14397edd57e34da458930d8e83a2de4">mutable_bind</a> (std::function&lt; ReturnType(FunctionArgs...)&gt;)</td></tr>
<tr class="separator:ad14397edd57e34da458930d8e83a2de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38806c4f02f69c071d8893f81e3c0ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ab38806c4f02f69c071d8893f81e3c0ce">dealii_version_string</a> ()</td></tr>
<tr class="separator:ab38806c4f02f69c071d8893f81e3c0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2518180c950be48153d93410f70d3c"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a3c2518180c950be48153d93410f70d3c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; std::uint64_t, dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3c2518180c950be48153d93410f70d3c">inverse_Hilbert_space_filling_curve</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt;&gt; &amp;points, const <a class="el" href="classint.html">int</a> bits_per_dim=64)</td></tr>
<tr class="separator:a3c2518180c950be48153d93410f70d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f382174c57e11ba880c019baa9761ce"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a4f382174c57e11ba880c019baa9761ce"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; std::uint64_t, dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a4f382174c57e11ba880c019baa9761ce">inverse_Hilbert_space_filling_curve</a> (const std::vector&lt; std::array&lt; std::uint64_t, dim &gt;&gt; &amp;points, const <a class="el" href="classint.html">int</a> bits_per_dim=64)</td></tr>
<tr class="separator:a4f382174c57e11ba880c019baa9761ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2710626bb38ca169232a2d11571ddb4c"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2710626bb38ca169232a2d11571ddb4c"><td class="memTemplItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a2710626bb38ca169232a2d11571ddb4c">pack_integers</a> (const std::array&lt; std::uint64_t, dim &gt; &amp;index, const <a class="el" href="classint.html">int</a> bits_per_dim)</td></tr>
<tr class="separator:a2710626bb38ca169232a2d11571ddb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6155277fd058eddb1504f9562cb1c04d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress</a> (const std::string &amp;input)</td></tr>
<tr class="separator:a6155277fd058eddb1504f9562cb1c04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8621974566702000fa007c7537c39bae"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a8621974566702000fa007c7537c39bae">decompress</a> (const std::string &amp;compressed_input)</td></tr>
<tr class="separator:a8621974566702000fa007c7537c39bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b872a22ae12bc52e151da92e3d996ec"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3b872a22ae12bc52e151da92e3d996ec">encode_base64</a> (const std::vector&lt; unsigned char &gt; &amp;binary_input)</td></tr>
<tr class="separator:a3b872a22ae12bc52e151da92e3d996ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5262eb044e97d6f5c014791e31c4084f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a5262eb044e97d6f5c014791e31c4084f">decode_base64</a> (const std::string &amp;base64_input)</td></tr>
<tr class="separator:a5262eb044e97d6f5c014791e31c4084f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6195c5f009ea8c7c536c6ffdf108c32f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a> (const unsigned <a class="el" href="classint.html">int</a> value, const unsigned <a class="el" href="classint.html">int</a> digits=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a6195c5f009ea8c7c536c6ffdf108c32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cb23f1982e4aa0bec09b60903303ce"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a56cb23f1982e4aa0bec09b60903303ce"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">to_string</a> (const number value, const unsigned <a class="el" href="classint.html">int</a> digits=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a56cb23f1982e4aa0bec09b60903303ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c75f3b2b9de645e7432eba26e59499b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a9c75f3b2b9de645e7432eba26e59499b">needed_digits</a> (const unsigned <a class="el" href="classint.html">int</a> max_number)</td></tr>
<tr class="separator:a9c75f3b2b9de645e7432eba26e59499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17955af7a4bc8771d430e622f9e732b3"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a17955af7a4bc8771d430e622f9e732b3"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a17955af7a4bc8771d430e622f9e732b3">truncate_to_n_digits</a> (const Number number, const unsigned <a class="el" href="classint.html">int</a> n_digits)</td></tr>
<tr class="separator:a17955af7a4bc8771d430e622f9e732b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8ff146c677d8a2408b88e4936f57d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#af7e8ff146c677d8a2408b88e4936f57d">string_to_int</a> (const std::string &amp;s)</td></tr>
<tr class="separator:af7e8ff146c677d8a2408b88e4936f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa22d290ce783e37587b6c879b926c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">dim_string</a> (const <a class="el" href="classint.html">int</a> dim, const <a class="el" href="classint.html">int</a> spacedim)</td></tr>
<tr class="separator:a21aa22d290ce783e37587b6c879b926c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af501c72fdc02dd969cd9d82d0f30642c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#af501c72fdc02dd969cd9d82d0f30642c">string_to_int</a> (const std::vector&lt; std::string &gt; &amp;s)</td></tr>
<tr class="separator:af501c72fdc02dd969cd9d82d0f30642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3177021843ad87857e6f8c5d98d29a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ab3177021843ad87857e6f8c5d98d29a5">string_to_double</a> (const std::string &amp;s)</td></tr>
<tr class="separator:ab3177021843ad87857e6f8c5d98d29a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd7c2e406c4e77b2cbbd2d68d2251a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a4cd7c2e406c4e77b2cbbd2d68d2251a5">string_to_double</a> (const std::vector&lt; std::string &gt; &amp;s)</td></tr>
<tr class="separator:a4cd7c2e406c4e77b2cbbd2d68d2251a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2b9ceded96f25b47eccd7c177dc67e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">split_string_list</a> (const std::string &amp;s, const std::string &amp;delimiter=&quot;,&quot;)</td></tr>
<tr class="separator:a0a2b9ceded96f25b47eccd7c177dc67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4d5a4196ba3f39b96876c320a6ac88"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#acd4d5a4196ba3f39b96876c320a6ac88">split_string_list</a> (const std::string &amp;s, const char delimiter)</td></tr>
<tr class="separator:acd4d5a4196ba3f39b96876c320a6ac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5448c92da85de774d6274e9a27797443"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a5448c92da85de774d6274e9a27797443">break_text_into_lines</a> (const std::string &amp;original_text, const unsigned <a class="el" href="classint.html">int</a> width, const char delimiter=' ')</td></tr>
<tr class="separator:a5448c92da85de774d6274e9a27797443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37ad8cfa930cb1ff91d68562553fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a6b37ad8cfa930cb1ff91d68562553fec">match_at_string_start</a> (const std::string &amp;name, const std::string &amp;pattern)</td></tr>
<tr class="separator:a6b37ad8cfa930cb1ff91d68562553fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbc4b2f7fb9ef31b841667a47ce3955"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a2dbc4b2f7fb9ef31b841667a47ce3955">get_integer_at_position</a> (const std::string &amp;name, const unsigned <a class="el" href="classint.html">int</a> position)</td></tr>
<tr class="separator:a2dbc4b2f7fb9ef31b841667a47ce3955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51121974cb2781c8bbb0ec281ece9f40"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a51121974cb2781c8bbb0ec281ece9f40">replace_in_string</a> (const std::string &amp;input, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="separator:a51121974cb2781c8bbb0ec281ece9f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca117b9cf9345b7ae7b72a075ddde116"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aca117b9cf9345b7ae7b72a075ddde116">trim</a> (const std::string &amp;input)</td></tr>
<tr class="separator:aca117b9cf9345b7ae7b72a075ddde116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6aef87ce08208501a4b524563836db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#acc6aef87ce08208501a4b524563836db">generate_normal_random_number</a> (const <a class="el" href="classdouble.html">double</a> a, const <a class="el" href="classdouble.html">double</a> sigma)</td></tr>
<tr class="separator:acc6aef87ce08208501a4b524563836db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7b53ed9c24a8dbec9f2305e908c5ff"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1e7b53ed9c24a8dbec9f2305e908c5ff"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a1e7b53ed9c24a8dbec9f2305e908c5ff">type_to_string</a> (const T &amp;t)</td></tr>
<tr class="separator:a1e7b53ed9c24a8dbec9f2305e908c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a834c6b595ada6f8e73c78d9bbd8ec551">fixed_power</a> (const T t)</td></tr>
<tr class="separator:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0900f35b37ee122e73fb2c80bba9beb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0900f35b37ee122e73fb2c80bba9beb9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">pow</a> (const T base, const <a class="el" href="classint.html">int</a> iexp)</td></tr>
<tr class="separator:a0900f35b37ee122e73fb2c80bba9beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0f9cd449850bf25160131cc4bc5668"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:aaa0f9cd449850bf25160131cc4bc5668"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aaa0f9cd449850bf25160131cc4bc5668">lower_bound</a> (Iterator <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a>, Iterator last, const T &amp;val)</td></tr>
<tr class="separator:aaa0f9cd449850bf25160131cc4bc5668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , typename Comp &gt; </td></tr>
<tr class="memitem:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3c612c5ab6f6fe3937de5f82861d7533">lower_bound</a> (Iterator <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a>, Iterator last, const T &amp;val, const Comp comp)</td></tr>
<tr class="separator:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45dacd4df58c7a93611e06fed4b97cd"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ad45dacd4df58c7a93611e06fed4b97cd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Integer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ad45dacd4df58c7a93611e06fed4b97cd">reverse_permutation</a> (const std::vector&lt; Integer &gt; &amp;permutation)</td></tr>
<tr class="separator:ad45dacd4df58c7a93611e06fed4b97cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17441dc4ee67526f51da147f5653a38"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ae17441dc4ee67526f51da147f5653a38"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Integer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ae17441dc4ee67526f51da147f5653a38">invert_permutation</a> (const std::vector&lt; Integer &gt; &amp;permutation)</td></tr>
<tr class="separator:ae17441dc4ee67526f51da147f5653a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebf9e8745b1c1c0f314d24a1ec90921"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ebf9e8745b1c1c0f314d24a1ec90921"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">pack</a> (const T &amp;object, std::vector&lt; char &gt; &amp;dest_buffer, const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a1ebf9e8745b1c1c0f314d24a1ec90921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18246c5d00bf120a058cd0f1c3c31e47"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18246c5d00bf120a058cd0f1c3c31e47"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a18246c5d00bf120a058cd0f1c3c31e47">pack</a> (const T &amp;object, const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a18246c5d00bf120a058cd0f1c3c31e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cf162221b13681933fcae78268c558"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82cf162221b13681933fcae78268c558"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">unpack</a> (const std::vector&lt; char &gt; &amp;buffer, const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a82cf162221b13681933fcae78268c558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a15c28893574e4d3c1887376fb185c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07a15c28893574e4d3c1887376fb185c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a07a15c28893574e4d3c1887376fb185c">unpack</a> (const std::vector&lt; char &gt;::const_iterator &amp;cbegin, const std::vector&lt; char &gt;::const_iterator &amp;cend, const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a07a15c28893574e4d3c1887376fb185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cd26f2016fe62ab2cd01230a24e71f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a50cd26f2016fe62ab2cd01230a24e71f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a50cd26f2016fe62ab2cd01230a24e71f">unpack</a> (const std::vector&lt; char &gt; &amp;buffer, T(&amp;unpacked_object)[N], const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a50cd26f2016fe62ab2cd01230a24e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db5c925d2b5221b0bb9b5be300ea1de"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a3db5c925d2b5221b0bb9b5be300ea1de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3db5c925d2b5221b0bb9b5be300ea1de">unpack</a> (const std::vector&lt; char &gt;::const_iterator &amp;cbegin, const std::vector&lt; char &gt;::const_iterator &amp;cend, T(&amp;unpacked_object)[N], const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a3db5c925d2b5221b0bb9b5be300ea1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeed5a63bdfab1d4890682fda6dd25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a2aeed5a63bdfab1d4890682fda6dd25e">get_bit</a> (const unsigned char number, const unsigned <a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="separator:a2aeed5a63bdfab1d4890682fda6dd25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc19608ea16d6ff5473c83c261822271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#abc19608ea16d6ff5473c83c261822271">set_bit</a> (unsigned char &amp;number, const unsigned <a class="el" href="classint.html">int</a> n, const <a class="el" href="classbool.html">bool</a> x)</td></tr>
<tr class="separator:abc19608ea16d6ff5473c83c261822271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4457a4656f1df496e01e2d396838461b"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a4457a4656f1df496e01e2d396838461b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a4457a4656f1df496e01e2d396838461b">dynamic_unique_cast</a> (std::unique_ptr&lt; From &gt; &amp;&amp;p)</td></tr>
<tr class="separator:a4457a4656f1df496e01e2d396838461b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0db556aff652f6765e5f7a373d8408"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b0db556aff652f6765e5f7a373d8408"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a0b0db556aff652f6765e5f7a373d8408">get_underlying_value</a> (T &amp;p)</td></tr>
<tr class="separator:a0b0db556aff652f6765e5f7a373d8408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dbc2ea3c952246c229da82619e5827"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49dbc2ea3c952246c229da82619e5827"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a49dbc2ea3c952246c229da82619e5827">get_underlying_value</a> (std::shared_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:a49dbc2ea3c952246c229da82619e5827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63c90105d4a987c7fd481a218049bb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac63c90105d4a987c7fd481a218049bb9"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ac63c90105d4a987c7fd481a218049bb9">get_underlying_value</a> (const std::shared_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:ac63c90105d4a987c7fd481a218049bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0be7e999bcff29e0eeb32d461099f3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0be7e999bcff29e0eeb32d461099f3b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ad0be7e999bcff29e0eeb32d461099f3b">get_underlying_value</a> (std::unique_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:ad0be7e999bcff29e0eeb32d461099f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfad0736928ec1b2040f4c4abe607aac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfad0736928ec1b2040f4c4abe607aac"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#acfad0736928ec1b2040f4c4abe607aac">get_underlying_value</a> (const std::unique_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:acfad0736928ec1b2040f4c4abe607aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5091cc3b5f91465b228b4934030380d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aa5091cc3b5f91465b228b4934030380d">DeclException2</a> (ExcInvalidNumber2StringConversersion, unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;When trying to convert &quot;&lt;&lt; arg1&lt;&lt; &quot; to a string with &quot;&lt;&lt; arg2&lt;&lt; &quot; digits&quot;)</td></tr>
<tr class="separator:aa5091cc3b5f91465b228b4934030380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa1bd2d1af6d3383136abd7b9e8afdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aafa1bd2d1af6d3383136abd7b9e8afdc">DeclException1</a> (ExcInvalidNumber, unsigned <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;Invalid number &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:aafa1bd2d1af6d3383136abd7b9e8afdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a67f68c6b9a288767dc58b55da823e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a21a67f68c6b9a288767dc58b55da823e">DeclException1</a> (ExcCantConvertString, std::string,&lt;&lt; &quot;Can't convert the string &quot;&lt;&lt; arg1&lt;&lt; &quot; to the desired type&quot;)</td></tr>
<tr class="separator:a21a67f68c6b9a288767dc58b55da823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>一个用于实用功能的命名空间，这些功能不是特别针对有限元计算或数值程序的，但在编写应用程序时，在各种情况下都需要。 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a91c51abf8f95716de44ab318e4c0857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c51abf8f95716de44ab318e4c0857d">&#9670;&nbsp;</a></span>create_evenly_distributed_partitioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> Utilities::create_evenly_distributed_partitioning </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>my_partition_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a>&#160;</td>
          <td class="paramname"><em>total_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出元素总数 <code>total_size</code>, ，为整个 <code>n_partitions</code>. 的元素创建一个均匀分布的1:1分区，本地大小将等于 <code>total_size</code> 除以分区的数量，再加上余下的部分在第一个进程中分配。每个进程将存储一个连续的索引子集，进程p+1上的索引集从比进程p上存储的最后一个索引大的索引开始。例如，一个 <code>total_size</code> 为11的3个进程将产生索引集{ [0,4), [4,8), [8,11)] }，这个函数将返回 <code>my_partition_id</code> 的索引集。 </p>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00071">71</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a244dcff7d2307d223bd2da9bf0b13ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244dcff7d2307d223bd2da9bf0b13ec0">&#9670;&nbsp;</a></span>mutable_bind() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt;ReturnType, FunctionArgs...&gt; Utilities::mutable_bind </td>
          <td>(</td>
          <td class="paramtype">ReturnType(*)(FunctionArgs...)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structidentity.html">identity</a>&lt; FunctionArgs &gt;::type &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从一个函数指针和一个参数列表创建一个MutableBind对象。 一个用法的例子是这样给出的。 </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_function(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;a, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> bound = <a class="code" href="namespaceUtilities.html#a244dcff7d2307d223bd2da9bf0b13ec0">mutable_bind</a>(my_function, 1, 2.0);</div><div class="line"></div><div class="line">bound(); <span class="comment">// will execute my_function(1, 2.0);</span></div><div class="line"></div><div class="line">bound.set_arguments(2, 3.0);</div><div class="line">bound(); <span class="comment">// will execute my_function(2, 3.0);</span></div><div class="line"></div><div class="line">bound.parse_arguments(<span class="stringliteral">&quot;3: 4.0&quot;</span>);</div><div class="line">bound(); <span class="comment">// will execute my_function(3, 4.0);</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ac77cb0654e4a283ed11a62fa5913ae86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77cb0654e4a283ed11a62fa5913ae86">&#9670;&nbsp;</a></span>mutable_bind() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt;ReturnType, FunctionArgs...&gt; Utilities::mutable_bind </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; ReturnType(FunctionArgs...)&gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structidentity.html">identity</a>&lt; FunctionArgs &gt;::type &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面一样，使用 std::function 对象。 </p>

</div>
</div>
<a id="ac040436711f265a2285730068b83030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac040436711f265a2285730068b83030e">&#9670;&nbsp;</a></span>mutable_bind() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt;ReturnType, FunctionArgs...&gt; Utilities::mutable_bind </td>
          <td>(</td>
          <td class="paramtype">ReturnType(*)(FunctionArgs...)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从一个函数指针创建一个MutableBind对象，带有未初始化的参数。 注意，如果你不调用 <a class="el" href="classUtilities_1_1MutableBind.html#a8c9892610afbf8e437530a3302c290a8">MutableBind::set_arguments()</a> 方法中的一个，或者在返回的对象上调用 <a class="el" href="classUtilities_1_1MutableBind.html#ad675baf4560885f06f27387bff9c1969">MutableBind::parse_arguments()</a> 函数，那么传递给函数对象的参数将被初始化，其值来自每个参数的默认构造函数。 </p>

</div>
</div>
<a id="ad14397edd57e34da458930d8e83a2de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14397edd57e34da458930d8e83a2de4">&#9670;&nbsp;</a></span>mutable_bind() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt;ReturnType, FunctionArgs...&gt; Utilities::mutable_bind </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; ReturnType(FunctionArgs...)&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，使用 std::function 对象。 </p>

</div>
</div>
<a id="ab38806c4f02f69c071d8893f81e3c0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38806c4f02f69c071d8893f81e3c0ce">&#9670;&nbsp;</a></span>dealii_version_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::dealii_version_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个形式为 "deal.II version x.y.z "的字符串，其中 "x.y.z
"标识了你正在使用的deal.II的版本。这个信息也是由DEAL_II_PACKAGE_NAME和DEAL_II_PACKAGE_VERSION预处理器变量提供的。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00097">97</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a3c2518180c950be48153d93410f70d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2518180c950be48153d93410f70d3c">&#9670;&nbsp;</a></span>inverse_Hilbert_space_filling_curve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; std::uint64_t, dim &gt; &gt; Utilities::inverse_Hilbert_space_filling_curve </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bits_per_dim</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用希尔伯特空间填充曲线给 <code>points</code> 中的每个点分配一个索引。 为此，将确定 <code>points</code> 的一个边界框，在此基础上计算它们的整数坐标。 线性索引是以比特的昏暗集合的形式给出的，从高到低。 这样做是为了保持沿每个轴的位深度的最大分辨率。请注意，这个dim-integer索引仍然可以很容易地用于分类和排序，例如使用整数组的lexicographic排序。 希尔伯特曲线的深度（即每维的比特数）默认等于 <code>64</code> . </p><dl class="section note"><dt>Note</dt><dd>这个函数也可以处理退化的情况，例如，当包围盒在其中一个维度的大小为零时。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00148">148</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a4f382174c57e11ba880c019baa9761ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f382174c57e11ba880c019baa9761ce">&#9670;&nbsp;</a></span>inverse_Hilbert_space_filling_curve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; std::uint64_t, dim &gt; &gt; Utilities::inverse_Hilbert_space_filling_curve </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::array&lt; std::uint64_t, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bits_per_dim</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但对于整数坐标的点。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00257">257</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a2710626bb38ca169232a2d11571ddb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2710626bb38ca169232a2d11571ddb4c">&#9670;&nbsp;</a></span>pack_integers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t Utilities::pack_integers </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::uint64_t, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bits_per_dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将 <code>index</code> 的每个元素中最不重要的 <code>bits_per_dim</code> 位（从最后一位开始）打包成一个无符号整数。 <code>index</code> 的最后一个元素将用于设置所得整数中的第一个 <code>bits_per_dim</code> 位，倒数第二个元素用于设置下一个 <code>bits_per_dim</code> 位，等等。为了将所有的数据装入输出，下面应该保持 <code>bits_per_dim dim &lt;= 64</code> 。 该函数在调试和可视化由inverse_Hilbert_space_filling_curve()返回的指数时很有用。 </p><dl class="section note"><dt>Note</dt><dd>为了比较inverse_Hilbert_space_filling_curve()返回的指数，没有必要使用这个函数，因为这可以通过 <code>std::lexicographical_compare()</code> 轻松完成。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00369">369</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a6155277fd058eddb1504f9562cb1c04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6155277fd058eddb1504f9562cb1c04d">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::compress </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果库被配置为ZLIB，那么这个函数会压缩输入字符串，并返回一个包含压缩后的输入的非零终止的字符串。 如果库没有配置启用ZLIB，则返回的字符串与输入字符串相同。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>要压缩的字符串 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>输入字符串的压缩版本 </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00392">392</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a8621974566702000fa007c7537c39bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8621974566702000fa007c7537c39bae">&#9670;&nbsp;</a></span>decompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::decompress </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>compressed_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果库中配置了ZLIB，那么这个函数假定输入的字符串已经用compress()函数进行了压缩，并返回原始的解压缩字符串。 如果库没有配置启用ZLIB，则返回的字符串与输入字符串相同。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compressed_input</td><td>一个压缩的字符串，由函数compress()返回 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>原始未压缩的字符串。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00414">414</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a3b872a22ae12bc52e151da92e3d996ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b872a22ae12bc52e151da92e3d996ec">&#9670;&nbsp;</a></span>encode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::encode_base64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将二进制输入编码为base64字符串。 Base64是一组二进制到文本的编码方案，通过将二进制数据转化为radix-64表示法，以ASCII字符串格式表示。Base64被设计用来在只可靠地支持文本内容的通道上携带以二进制格式存储的数据。它也被用来以独立于机器的方式存储二进制格式。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary_input</td><td>一个字符向量，代表你的输入为二进制数据。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个包含二进制输入的字符串，作为base64字符串。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00436">436</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a5262eb044e97d6f5c014791e31c4084f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5262eb044e97d6f5c014791e31c4084f">&#9670;&nbsp;</a></span>decode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; Utilities::decode_base64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base64_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将base64字符串解码为二进制输出。 这是上面的encode_base64()函数的逆运算。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base64_input</td><td>一个包含base64格式输入的字符串。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个字符向量，表示你的输入为二进制数据。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00449">449</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a6195c5f009ea8c7c536c6ffdf108c32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6195c5f009ea8c7c536c6ffdf108c32f">&#9670;&nbsp;</a></span>int_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::int_to_string </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>digits</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将一个数字 <code>value</code> 转换成一个字符串，有多少个数字就用多少个前导零填充。 如果第二个参数保留为默认值，则数字不会被填充前导零。其结果与调用标准C++ <code>std::to_string</code> （或旧的C函数<code>itoa()</code>）的结果相同。 这个函数需要一个<code>无符号int'作为参数。因此，如果你用</code>signed int<code>（当然与</code>int<code>的类型相同）调用它，参数会被隐含地转换为无符号整数，负数可能不会像你希望的那样被打印出来。同样地，如果你用</code>long int<code>调用函数，打印出来的结果可能会显示转换为</code>unsigned int`时的溢出效果。 </p><dl class="section note"><dt>Note</dt><dd>不鼓励使用这个函数，用户应该使用 <code><a class="el" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string()</a></code> 代替。在目前的实现中，该函数只是简单地调用<code>to_string &lt;unsigned int &gt;()</code>. 。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00473">473</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a56cb23f1982e4aa0bec09b60903303ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cb23f1982e4aa0bec09b60903303ce">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::to_string </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>digits</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将一个数字 <code>value</code> 转换成一个字符串，其中有 <code>digits</code> 个字符。字符串被填充了前导零，在可能的减号之后。 因此，填充零的总数是 <code>digits</code> 减去任何符号、小数点和 <code>value</code>. 的数字。 如果第二个参数保持其默认值，数字就不会被填充前导零。结果与调用C++函数 <code><a class="el" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">std::to_string()</a></code> （对于积分类型）或调用 <code>boost::lexical_cast()</code> （对于所有其他类型）的情况相同。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00482">482</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a9c75f3b2b9de645e7432eba26e59499b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c75f3b2b9de645e7432eba26e59499b">&#9670;&nbsp;</a></span>needed_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Utilities::needed_digits </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定需要多少个数字来表示最多和给定数字一样大的数字。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00568">568</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a17955af7a4bc8771d430e622f9e732b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17955af7a4bc8771d430e622f9e732b3">&#9670;&nbsp;</a></span>truncate_to_n_digits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number Utilities::truncate_to_n_digits </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_digits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数允许在 <code>n_digits</code> 的精度之后切断一个浮点数 <code>number</code> ，即在科学浮点符号的小数点后 <code>n_digits</code> 位之后切断。当解释为四舍五入操作时，这个函数减少了浮点数的绝对值，并且总是向零舍入，因为小数点位被简单地切断了。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00581">581</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="af7e8ff146c677d8a2408b88e4936f57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8ff146c677d8a2408b88e4936f57d">&#9670;&nbsp;</a></span>string_to_int() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> Utilities::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个字符串，将其转换为一个整数。如果不可能，则抛出一个断言。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00608">608</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a21aa22d290ce783e37587b6c879b926c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aa22d290ce783e37587b6c879b926c">&#9670;&nbsp;</a></span>dim_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::dim_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>spacedim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个描述对象尺寸的字符串。通常，deal.II库以及用户代码中的函数需要定义一个字符串，包含一些使用两个模板参数定义的对象的模板尺寸：dim（对象的拓扑尺寸）和spacedim（嵌入欧几里得空间的尺寸）。 由于在所有deal.II类中，默认情况下spacedim等于dimension，上述字符串通常被缩减为"&lt;dim&gt;"，而不是"&lt;dim,spacedim&gt;"。 如果dim等于spacedim，该函数返回一个包含 "dim
"的字符串，否则返回 "dim,spacedim"。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00558">558</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="af501c72fdc02dd969cd9d82d0f30642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af501c72fdc02dd969cd9d82d0f30642c">&#9670;&nbsp;</a></span>string_to_int() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; Utilities::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个字符串列表，将其转换为一个整数列表。如果不可能，则抛出一个断言。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00645">645</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ab3177021843ad87857e6f8c5d98d29a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3177021843ad87857e6f8c5d98d29a5">&#9670;&nbsp;</a></span>string_to_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> Utilities::string_to_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个字符串，将其转换为一个双数。如果不可能，抛出一个断言。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00656">656</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a4cd7c2e406c4e77b2cbbd2d68d2251a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd7c2e406c4e77b2cbbd2d68d2251a5">&#9670;&nbsp;</a></span>string_to_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; Utilities::string_to_double </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个字符串的列表，将其转换为一个双数的列表。如果不可能，抛出一个断言。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00693">693</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a0a2b9ceded96f25b47eccd7c177dc67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2b9ceded96f25b47eccd7c177dc67e">&#9670;&nbsp;</a></span>split_string_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utilities::split_string_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个包含由 <code>delimiter</code>, 分隔的文本的字符串，将其分割成其组成部分；对于每个组成部分，去除前面和后面的空格。分隔符的默认值是逗号，因此该函数可以分割逗号分隔的字符串列表。 为了使来自表格的数据输入更简单，如果输入的字符串以定界符结束（后面可能有任意数量的空白），那么最后这个定界符将被忽略。比如说。 </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc; def; ghi; &quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> 产生的3个元素的输出 <code>{"abc","def","ghi"}</code> 与你在输入时得到的相同 </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc; def; ghi&quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> 或 </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc; def; ghi;&quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> 作为这一规则的结果，像这样的调用 </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot; ; &quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> 产生了一个单元素的列表。由于修剪了空白，这个单元素是空字符串。 这个函数可以消化定界符是空格的情况。在这种情况下，它返回字符串中的所有单词。结合上面的规则，这意味着 </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc def ghi &quot;</span>, <span class="charliteral">&#39; &#39;</span>);</div></div><!-- fragment --><p> 尽管在字符串的末尾存在空格，*还是会产生上面的输出 <code>{"abc","def","ghi"}</code> 的3元素列表。此外。 </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;      &quot;</span>, <span class="charliteral">&#39; &#39;</span>);</div></div><!-- fragment --><p> 无论字符串中有多少空格，都会产生一个空列表。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00704">704</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="acd4d5a4196ba3f39b96876c320a6ac88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4d5a4196ba3f39b96876c320a6ac88">&#9670;&nbsp;</a></span>split_string_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utilities::split_string_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">split_string_list()</a>的特殊化，用于分隔符为单个字符的情况。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00749">749</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a5448c92da85de774d6274e9a27797443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5448c92da85de774d6274e9a27797443">&#9670;&nbsp;</a></span>break_text_into_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utilities::break_text_into_lines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>取一个文本，通常是一个文档或其他东西，并尝试将其分割成最多 <code>width</code> 个字符宽的独立文本行，在文本中由 <code>delimiter</code> 标记的位置进行分割。如果这是不可能的，则返回长于 <code>width</code>. 的最短的几行，分隔符的默认值是一个空格字符。如果original_text包含换行符(/n)，字符串也会在这些位置被分割。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00758">758</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a6b37ad8cfa930cb1ff91d68562553fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b37ad8cfa930cb1ff91d68562553fec">&#9670;&nbsp;</a></span>match_at_string_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Utilities::match_at_string_start </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果给定的模式字符串出现在字符串的第一个位置，则返回true。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00838">838</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a2dbc4b2f7fb9ef31b841667a47ce3955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbc4b2f7fb9ef31b841667a47ce3955">&#9670;&nbsp;</a></span>get_integer_at_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; Utilities::get_integer_at_position </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>读取一个（有符号的）整数，从第二个参数指示的 <code>name</code> 中的位置开始，并将这个整数与它在字符串中所占的字符数一起作为一对返回。 如果在指定的位置没有读到整数，则返回 (-1,<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>) 。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00853">853</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a51121974cb2781c8bbb0ec281ece9f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51121974cb2781c8bbb0ec281ece9f40">&#9670;&nbsp;</a></span>replace_in_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::replace_in_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个字符串，其中 <code>input</code> 中所有出现的 <code>from</code> 都被 <code>to</code>. 替换。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00512">512</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="aca117b9cf9345b7ae7b72a075ddde116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca117b9cf9345b7ae7b72a075ddde116">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个字符串，删除 <code>input</code> 开头和结尾的所有标准空白字符（包括'<code></code>', '<code><br />
</code>', 和 '<code></code>'）。 </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00531">531</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="acc6aef87ce08208501a4b524563836db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6aef87ce08208501a4b524563836db">&#9670;&nbsp;</a></span>generate_normal_random_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> Utilities::generate_normal_random_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从以 <code>a</code> 为中心、标准差为 <code>sigma</code>. 的归一化高斯概率分布中生成一个随机数，每次调用该函数时返回的数字都会不同。 这个函数是可重入的，也就是说，它可以安全地从多个线程同时调用。此外，每个线程每次都会得到相同的数字序列。另一方面，如果你通过线程积木运行 <a class="el" href="classThreads_1_1Task.html">Threads::Task</a> 对象，那么任务将被分配到大部分随机的线程中，并且可能在程序的不同运行中获得不同的随机数序列，因为之前的任务可能已经消耗了为你所在的线程生成的前几个随机数。如果这是一个问题，你需要在每次想从一个定义的点开始时创建自己的随机数生成器对象。 </p><dl class="section note"><dt>Note</dt><dd>与系统函数rand()一样，这个函数在每次程序启动时都会产生相同的随机数序列。这是调试代码的一个重要特性，但它使我们无法真正验证代码的统计特性。对于<code>rand()</code>，你可以调用<code>srand()</code>来 "播种
"随机数发生器，以便在每次调用程序时得到不同的随机数序列。然而，这个函数不允许给随机数发生器播种。如果你需要这个，如上所述，请使用C++或BOOST设施之一。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00895">895</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a1e7b53ed9c24a8dbec9f2305e908c5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7b53ed9c24a8dbec9f2305e908c5ff">&#9670;&nbsp;</a></span>type_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::type_to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回变量类型的字符串描述 <code>t</code>. 一般来说，C++使用混杂的名称来识别类型。这个函数使用 boost::core::demangle 来返回一个人类可读的字符串，描述作为参数传递的变量的类型。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00950">950</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a834c6b595ada6f8e73c78d9bbd8ec551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834c6b595ada6f8e73c78d9bbd8ec551">&#9670;&nbsp;</a></span>fixed_power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::fixed_power </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一个固定的幂，作为模板参数提供，是一个数字的计算。 这个函数提供了一种有效的方法来计算诸如 <code>t^N</code> where <code>N</code> 是一个已知的数字在编译时。 使用这个函数，如 <code>fixed_power&lt;dim&gt; (n)</code> . </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00929">929</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a0900f35b37ee122e73fb2c80bba9beb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0900f35b37ee122e73fb2c80bba9beb9">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T Utilities::pow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>iexp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>替换 <code>std::pow</code> ，允许对常量表达式参数进行编译时计算。 <code>base</code> 必须是整数类型，指数 <code>iexp</code> 不能是负数。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00410">410</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aaa0f9cd449850bf25160131cc4bc5668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0f9cd449850bf25160131cc4bc5668">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator Utilities::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对 <code>std::lower_bound</code> 的优化替换，用于在列索引的范围内搜索。对于目前的应用来说，执行时间大约减少了一半，部分原因是二进制搜索被小循环长度的线性搜索所取代。 这个功能的另一个原因相当不明显：当使用GCC的libstdc++函数 std::lower_bound, 时，复杂性为O(log(N))，符合要求。 然而，当使用GCC libstdc++的调试版本时，正如我们在运行测试套件时所做的那样，那么 std::lower_bound 测试序列是否实际上是相对于枢轴 "值
"而言的分区（也就是说，本质上序列是按照二进制搜索的要求进行排序的）。 然而，验证这一点意味着 std::lower_bound 的复杂度跃升至O(N)；我们在下面调用这个函数O(N)次，使得整体复杂度为O(N*2)。其后果是，一些有大网格的测试完全跑出了测试的时间限制，并在libstdc++调试模式下失败。这个函数只是假设序列是排序的，而我们根本不做额外的检查。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00959">959</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a3c612c5ab6f6fe3937de5f82861d7533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c612c5ab6f6fe3937de5f82861d7533">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T , typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator Utilities::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上面的函数相同，但接受一个参数，用来比较迭代器所指向的对象序列的各个元素。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00968">968</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ad45dacd4df58c7a93611e06fed4b97cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45dacd4df58c7a93611e06fed4b97cd">&#9670;&nbsp;</a></span>reverse_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Integer &gt; Utilities::reverse_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个排列向量（即一个向量 \(p_0\ldots p_{N-1}\) ，其中每个 \(p_i\in [0,N)\) 和 \(p_i\neq p_j\) 为 \(i\neq j\) ），产生反向排列 \(q_i=N-1-p_i\) 。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01315">1315</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ae17441dc4ee67526f51da147f5653a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17441dc4ee67526f51da147f5653a38">&#9670;&nbsp;</a></span>invert_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Integer &gt; Utilities::invert_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个互换向量（即一个向量 \(p_0\ldots p_{N-1}\) ，其中每个 \(p_i\in [0,N)\) 和 \(p_i\neq p_j\) 为 \(i\neq j\) ），产生反互换 \(q_0\ldots q_{N-1}\) ，以便 \(q_{p_i}=p_{q_i}=i\)</p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01330">1330</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a1ebf9e8745b1c1c0f314d24a1ec90921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebf9e8745b1c1c0f314d24a1ec90921">&#9670;&nbsp;</a></span>pack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Utilities::pack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个T类型的任意对象，使用 boost::serialization 工具将该对象打包成一个字符向量，并将其追加到给定的缓冲区中。被添加到缓冲区的元素的数量将被返回。该对象可以使用下面的 <a class="el" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">Utilities::unpack</a> 函数进行解包。 如果库在编译时启用了ZLIB，那么输出缓冲区可以被压缩。这可以通过参数 <code>allow_compression</code>, 来触发，并且只有在启用ZLIB时才有效。 如果考虑用同一个缓冲区进行多次连续调用，出于性能考虑，建议确保缓冲区有足够的容量。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01066">1066</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a18246c5d00bf120a058cd0f1c3c31e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18246c5d00bf120a058cd0f1c3c31e47">&#9670;&nbsp;</a></span>pack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; char &gt; Utilities::pack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用上面提到的pack函数，只为给定对象创建并返回一个缓冲区。 如果该库在编译时启用了ZLIB，那么输出缓冲区可以被压缩。这可以通过参数 <code>allow_compression</code>, 来触发，并且只有在启用ZLIB时才有效。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01118">1118</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a82cf162221b13681933fcae78268c558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cf162221b13681933fcae78268c558">&#9670;&nbsp;</a></span>unpack() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个字符向量，通过调用函数 <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack</a>, 获得，在一个T类型的对象中恢复其内容。 这个函数使用 boost::serialization 实用程序从字符向量中解压缩对象，它是函数 <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack()</a>. 的逆函数。 <code>allow_compression</code> 参数表示要读取的缓冲区是否以前用ZLIB压缩过，并且只有在启用ZLIB时才有效。 </p><dl class="section note"><dt>Note</dt><dd>因为这个函数的参数不取决于模板类型 <code>T</code>, 你必须在调用这个函数时手动指定模板参数。 </dd>
<dd>
如果你想打包()或解压()对象的数组，那么下面的方法可行。 <div class="fragment"><div class="line"><span class="keywordtype">double</span> array[3] = {1,2,3};</div><div class="line">std::vector&lt;char&gt; buffer = <a class="code" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack</a>(array);</div></div><!-- fragment --> 然而，反过来就不行了。 <div class="fragment"><div class="line">array = Utilities::unpack&lt;double[3]&gt;(buffer);</div></div><!-- fragment --> 这是因为C++不允许函数返回数组。 因此，有一个单独的解包()函数用于数组，见下文。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01169">1169</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a07a15c28893574e4d3c1887376fb185c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a15c28893574e4d3c1887376fb185c">&#9670;&nbsp;</a></span>unpack() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>cbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>cend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的解包函数相同，但在给定的 std::vector&lt;char&gt; 类型的打包缓冲区上（一部分）采取恒定的迭代器来代替。 <code>allow_compression</code> 参数表示要读取的缓冲区是否以前用ZLIB压缩过，并且只有在启用ZLIB时才有效。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01128">1128</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a50cd26f2016fe62ab2cd01230a24e71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cd26f2016fe62ab2cd01230a24e71f">&#9670;&nbsp;</a></span>unpack() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>unpacked_object</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个字符向量，通过调用函数 <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack</a>, 获得，将其内容还原为T型数组。 这个函数使用 boost::serialization 实用程序从字符向量中解压缩对象，它是函数 <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack()</a>. 的逆函数。 <code>allow_compression</code> 参数表示要读取的缓冲区是否以前用ZLIB压缩过，只有当ZLIB被启用时才有效。 </p><dl class="section note"><dt>Note</dt><dd>这个函数的存在是由于C++的一个怪癖。具体来说，如果你想打包()或解压()对象的数组，那么下面的方法就可以。 <div class="fragment"><div class="line"><span class="keywordtype">double</span> array[3] = {1,2,3};</div><div class="line">std::vector&lt;char&gt; buffer = <a class="code" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack</a>(array);</div></div><!-- fragment --> 然而，反过来就不行了。 <div class="fragment"><div class="line">array = Utilities::unpack&lt;double[3]&gt;(buffer);</div></div><!-- fragment --> 这是因为C++不允许函数返回数组。 因此，当前的函数允许写 <div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">Utilities::unpack</a>(buffer, array);</div></div><!-- fragment --> 注意，与其他unpack()函数不同，不需要明确指定模板参数，因为它们可以从第二个参数中推导出来。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01211">1211</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a3db5c925d2b5221b0bb9b5be300ea1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db5c925d2b5221b0bb9b5be300ea1de">&#9670;&nbsp;</a></span>unpack() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>cbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>cend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>unpacked_object</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面的解包函数一样，但是在给定的 std::vector&lt;char&gt; 类型的打包缓冲区上（一部分）采取常数迭代器来代替。 <code>allow_compression</code> 参数表示要读取的缓冲区是否以前用ZLIB压缩过，并且只有在启用ZLIB时才有效。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01177">1177</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a2aeed5a63bdfab1d4890682fda6dd25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeed5a63bdfab1d4890682fda6dd25e">&#9670;&nbsp;</a></span>get_bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Utilities::get_bit </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>检查 <code>number</code> 中 <code>n</code> 位置的位是否被设置。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01224">1224</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="abc19608ea16d6ff5473c83c261822271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc19608ea16d6ff5473c83c261822271">&#9670;&nbsp;</a></span>set_bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::set_bit </td>
          <td>(</td>
          <td class="paramtype">unsigned char &amp;&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将 <code>number</code> 中位置 <code>n</code> 的位设置为值 <code>x</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01237">1237</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a4457a4656f1df496e01e2d396838461b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4457a4656f1df496e01e2d396838461b">&#9670;&nbsp;</a></span>dynamic_unique_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; To &gt; Utilities::dynamic_unique_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; From &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个类型为 <code>std::unique_ptr&lt;From&gt;</code> 的对象转换为类型为 <code>std::unique_ptr&lt;To&gt;</code>, 的对象，这里假定我们可以使用<code>dynamic_cast</code>将指向<code>From</code>的指针转换为指向<code>To</code>的指针。</p>
<ul>
<li>换句话说，我们假设<code>From'和</code>To'是通过一个类的层次结构连接起来的，而且所指向的对象实际上是一个同时包含<code>From'和</code>To'的类型。一个例子是如果<code>To</code>是从<code>From</code>派生出来的，或者反过来。 如果<code>dynamic_cast</code>不成功，该函数会抛出一个类型为 <code>std::bad_cast</code> 的异常。这和你在对象类型（但不是指针类型）之间的常规<code>dynamic_cast</code>不成功时得到的异常一样。 这个函数如何工作的例子如下。 <div class="fragment"><div class="line"><span class="comment">// A base class. Assume that it has virtual</span></div><div class="line"><span class="comment">// functions so that dynamic_cast can work.</span></div><div class="line"><span class="keyword">class </span>B</div><div class="line">{</div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// A derived class</span></div><div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B</div><div class="line">{</div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// A factory function</span></div><div class="line">std::unique_ptr&lt;B&gt; create_object (...)</div><div class="line">{</div><div class="line">  ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> foo (...)</div><div class="line">{</div><div class="line">  std::unique_ptr&lt;B&gt; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a> = create_object (...);</div><div class="line"></div><div class="line">  <span class="comment">// Assume that we know for some reason that the object above must</span></div><div class="line">  <span class="comment">// have created a D object but returned it as a std::unique_ptr&lt;B&gt;.</span></div><div class="line">  <span class="comment">// In order to access the D functionality, we need to cast the</span></div><div class="line">  <span class="comment">// pointer. Use the equivalent to dynamic_cast:</span></div><div class="line">  std::unique_ptr&lt;D&gt; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = <a class="code" href="namespaceUtilities.html#a4457a4656f1df496e01e2d396838461b">dynamic_unique_cast</a>&lt;D&gt;(std::move(b));</div><div class="line"></div><div class="line">  <span class="comment">// If the object really was a D, then &#39;d&#39; now points to it. Note</span></div><div class="line">  <span class="comment">// also that in accordance with the semantics of std::unique_ptr,</span></div><div class="line">  <span class="comment">// it was necessary to std::move the &#39;b&#39; object, and indeed &#39;b&#39;</span></div><div class="line">  <span class="comment">// now no longer points to anything</span></div><div class="line"></div><div class="line">-- ownership has been</div><div class="line">  <span class="comment">// transferred to &#39;d&#39;!</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>这个函数不会尝试转换 <code>std::unique_ptr</code> 对象所存储的<code>Deleter</code>对象。因此，该函数只在deleter对象处于默认状态时起作用，即，如果它们是 <code>std::default_delete&lt;To&gt;</code> 和 <code>std::default_delete&lt;From&gt;</code>. 类型的对象。 </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01251">1251</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a0b0db556aff652f6765e5f7a373d8408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0db556aff652f6765e5f7a373d8408">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回基本值。默认：返回输入。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01270">1270</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a49dbc2ea3c952246c229da82619e5827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dbc2ea3c952246c229da82619e5827">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回基本值。对 std::shared_ptr&lt;T&gt;. 的特殊化。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01279">1279</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ac63c90105d4a987c7fd481a218049bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63c90105d4a987c7fd481a218049bb9">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回底层值。对const std::shared_ptr&lt;T&gt;. 的特化。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01288">1288</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ad0be7e999bcff29e0eeb32d461099f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0be7e999bcff29e0eeb32d461099f3b">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回基本值。对 std::unique_ptr&lt;T&gt;. 的特化 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01297">1297</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="acfad0736928ec1b2040f4c4abe607aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfad0736928ec1b2040f4c4abe607aac">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回基本值。对const std::unique_ptr&lt;T&gt;. 的特化。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01306">1306</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aa5091cc3b5f91465b228b4934030380d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5091cc3b5f91465b228b4934030380d">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Utilities::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidNumber2StringConversersion&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;When trying to convert &quot;&lt;&lt; arg1&lt;&lt; &quot; to a string with &quot;&lt;&lt; arg2&lt;&lt; &quot; digits&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafa1bd2d1af6d3383136abd7b9e8afdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa1bd2d1af6d3383136abd7b9e8afdc">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Utilities::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidNumber&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Invalid number &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21a67f68c6b9a288767dc58b55da823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a67f68c6b9a288767dc58b55da823e">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Utilities::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcCantConvertString&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Can't convert the string &quot;&lt;&lt; arg1&lt;&lt; &quot; to the desired type&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
