<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceUtilities.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilities Namespace Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceUtilities_1_1CUDA"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1CUDA.html">CUDA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1LinearAlgebra"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1LinearAlgebra.html">LinearAlgebra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1MPI"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html">MPI</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1System"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1System.html">System</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1Trilinos"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1Trilinos.html">Trilinos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91c51abf8f95716de44ab318e4c0857d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a91c51abf8f95716de44ab318e4c0857d">create_evenly_distributed_partitioning</a> (const unsigned <a class="el" href="classint.html">int</a> my_partition_id, const unsigned <a class="el" href="classint.html">int</a> n_partitions, const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> total_size)</td></tr>
<tr class="separator:a91c51abf8f95716de44ab318e4c0857d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244dcff7d2307d223bd2da9bf0b13ec0"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , class... FunctionArgs&gt; </td></tr>
<tr class="memitem:a244dcff7d2307d223bd2da9bf0b13ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt; ReturnType, FunctionArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a244dcff7d2307d223bd2da9bf0b13ec0">mutable_bind</a> (ReturnType(*function)(FunctionArgs...), typename <a class="el" href="structidentity.html">identity</a>&lt; FunctionArgs &gt;::type &amp;&amp;... arguments)</td></tr>
<tr class="separator:a244dcff7d2307d223bd2da9bf0b13ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77cb0654e4a283ed11a62fa5913ae86"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , class... FunctionArgs&gt; </td></tr>
<tr class="memitem:ac77cb0654e4a283ed11a62fa5913ae86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt; ReturnType, FunctionArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ac77cb0654e4a283ed11a62fa5913ae86">mutable_bind</a> (std::function&lt; ReturnType(FunctionArgs...)&gt;, typename <a class="el" href="structidentity.html">identity</a>&lt; FunctionArgs &gt;::type &amp;&amp;... arguments)</td></tr>
<tr class="separator:ac77cb0654e4a283ed11a62fa5913ae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac040436711f265a2285730068b83030e"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , class... FunctionArgs&gt; </td></tr>
<tr class="memitem:ac040436711f265a2285730068b83030e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt; ReturnType, FunctionArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ac040436711f265a2285730068b83030e">mutable_bind</a> (ReturnType(*function)(FunctionArgs...))</td></tr>
<tr class="separator:ac040436711f265a2285730068b83030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14397edd57e34da458930d8e83a2de4"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , class... FunctionArgs&gt; </td></tr>
<tr class="memitem:ad14397edd57e34da458930d8e83a2de4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt; ReturnType, FunctionArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ad14397edd57e34da458930d8e83a2de4">mutable_bind</a> (std::function&lt; ReturnType(FunctionArgs...)&gt;)</td></tr>
<tr class="separator:ad14397edd57e34da458930d8e83a2de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38806c4f02f69c071d8893f81e3c0ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ab38806c4f02f69c071d8893f81e3c0ce">dealii_version_string</a> ()</td></tr>
<tr class="separator:ab38806c4f02f69c071d8893f81e3c0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2518180c950be48153d93410f70d3c"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a3c2518180c950be48153d93410f70d3c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; std::uint64_t, dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3c2518180c950be48153d93410f70d3c">inverse_Hilbert_space_filling_curve</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt;&gt; &amp;points, const <a class="el" href="classint.html">int</a> bits_per_dim=64)</td></tr>
<tr class="separator:a3c2518180c950be48153d93410f70d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f382174c57e11ba880c019baa9761ce"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a4f382174c57e11ba880c019baa9761ce"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::array&lt; std::uint64_t, dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a4f382174c57e11ba880c019baa9761ce">inverse_Hilbert_space_filling_curve</a> (const std::vector&lt; std::array&lt; std::uint64_t, dim &gt;&gt; &amp;points, const <a class="el" href="classint.html">int</a> bits_per_dim=64)</td></tr>
<tr class="separator:a4f382174c57e11ba880c019baa9761ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2710626bb38ca169232a2d11571ddb4c"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2710626bb38ca169232a2d11571ddb4c"><td class="memTemplItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a2710626bb38ca169232a2d11571ddb4c">pack_integers</a> (const std::array&lt; std::uint64_t, dim &gt; &amp;index, const <a class="el" href="classint.html">int</a> bits_per_dim)</td></tr>
<tr class="separator:a2710626bb38ca169232a2d11571ddb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6155277fd058eddb1504f9562cb1c04d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress</a> (const std::string &amp;input)</td></tr>
<tr class="separator:a6155277fd058eddb1504f9562cb1c04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8621974566702000fa007c7537c39bae"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a8621974566702000fa007c7537c39bae">decompress</a> (const std::string &amp;compressed_input)</td></tr>
<tr class="separator:a8621974566702000fa007c7537c39bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b872a22ae12bc52e151da92e3d996ec"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3b872a22ae12bc52e151da92e3d996ec">encode_base64</a> (const std::vector&lt; unsigned char &gt; &amp;binary_input)</td></tr>
<tr class="separator:a3b872a22ae12bc52e151da92e3d996ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5262eb044e97d6f5c014791e31c4084f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a5262eb044e97d6f5c014791e31c4084f">decode_base64</a> (const std::string &amp;base64_input)</td></tr>
<tr class="separator:a5262eb044e97d6f5c014791e31c4084f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6195c5f009ea8c7c536c6ffdf108c32f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a> (const unsigned <a class="el" href="classint.html">int</a> value, const unsigned <a class="el" href="classint.html">int</a> digits=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a6195c5f009ea8c7c536c6ffdf108c32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cb23f1982e4aa0bec09b60903303ce"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a56cb23f1982e4aa0bec09b60903303ce"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">to_string</a> (const number value, const unsigned <a class="el" href="classint.html">int</a> digits=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a56cb23f1982e4aa0bec09b60903303ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c75f3b2b9de645e7432eba26e59499b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a9c75f3b2b9de645e7432eba26e59499b">needed_digits</a> (const unsigned <a class="el" href="classint.html">int</a> max_number)</td></tr>
<tr class="separator:a9c75f3b2b9de645e7432eba26e59499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17955af7a4bc8771d430e622f9e732b3"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a17955af7a4bc8771d430e622f9e732b3"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a17955af7a4bc8771d430e622f9e732b3">truncate_to_n_digits</a> (const Number number, const unsigned <a class="el" href="classint.html">int</a> n_digits)</td></tr>
<tr class="separator:a17955af7a4bc8771d430e622f9e732b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8ff146c677d8a2408b88e4936f57d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#af7e8ff146c677d8a2408b88e4936f57d">string_to_int</a> (const std::string &amp;s)</td></tr>
<tr class="separator:af7e8ff146c677d8a2408b88e4936f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa22d290ce783e37587b6c879b926c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a21aa22d290ce783e37587b6c879b926c">dim_string</a> (const <a class="el" href="classint.html">int</a> dim, const <a class="el" href="classint.html">int</a> spacedim)</td></tr>
<tr class="separator:a21aa22d290ce783e37587b6c879b926c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af501c72fdc02dd969cd9d82d0f30642c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#af501c72fdc02dd969cd9d82d0f30642c">string_to_int</a> (const std::vector&lt; std::string &gt; &amp;s)</td></tr>
<tr class="separator:af501c72fdc02dd969cd9d82d0f30642c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3177021843ad87857e6f8c5d98d29a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ab3177021843ad87857e6f8c5d98d29a5">string_to_double</a> (const std::string &amp;s)</td></tr>
<tr class="separator:ab3177021843ad87857e6f8c5d98d29a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd7c2e406c4e77b2cbbd2d68d2251a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a4cd7c2e406c4e77b2cbbd2d68d2251a5">string_to_double</a> (const std::vector&lt; std::string &gt; &amp;s)</td></tr>
<tr class="separator:a4cd7c2e406c4e77b2cbbd2d68d2251a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2b9ceded96f25b47eccd7c177dc67e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">split_string_list</a> (const std::string &amp;s, const std::string &amp;delimiter=&quot;,&quot;)</td></tr>
<tr class="separator:a0a2b9ceded96f25b47eccd7c177dc67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4d5a4196ba3f39b96876c320a6ac88"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#acd4d5a4196ba3f39b96876c320a6ac88">split_string_list</a> (const std::string &amp;s, const char delimiter)</td></tr>
<tr class="separator:acd4d5a4196ba3f39b96876c320a6ac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5448c92da85de774d6274e9a27797443"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a5448c92da85de774d6274e9a27797443">break_text_into_lines</a> (const std::string &amp;original_text, const unsigned <a class="el" href="classint.html">int</a> width, const char delimiter=' ')</td></tr>
<tr class="separator:a5448c92da85de774d6274e9a27797443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37ad8cfa930cb1ff91d68562553fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a6b37ad8cfa930cb1ff91d68562553fec">match_at_string_start</a> (const std::string &amp;name, const std::string &amp;pattern)</td></tr>
<tr class="separator:a6b37ad8cfa930cb1ff91d68562553fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbc4b2f7fb9ef31b841667a47ce3955"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a2dbc4b2f7fb9ef31b841667a47ce3955">get_integer_at_position</a> (const std::string &amp;name, const unsigned <a class="el" href="classint.html">int</a> position)</td></tr>
<tr class="separator:a2dbc4b2f7fb9ef31b841667a47ce3955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51121974cb2781c8bbb0ec281ece9f40"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a51121974cb2781c8bbb0ec281ece9f40">replace_in_string</a> (const std::string &amp;input, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="separator:a51121974cb2781c8bbb0ec281ece9f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca117b9cf9345b7ae7b72a075ddde116"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aca117b9cf9345b7ae7b72a075ddde116">trim</a> (const std::string &amp;input)</td></tr>
<tr class="separator:aca117b9cf9345b7ae7b72a075ddde116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6aef87ce08208501a4b524563836db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#acc6aef87ce08208501a4b524563836db">generate_normal_random_number</a> (const <a class="el" href="classdouble.html">double</a> a, const <a class="el" href="classdouble.html">double</a> sigma)</td></tr>
<tr class="separator:acc6aef87ce08208501a4b524563836db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7b53ed9c24a8dbec9f2305e908c5ff"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1e7b53ed9c24a8dbec9f2305e908c5ff"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a1e7b53ed9c24a8dbec9f2305e908c5ff">type_to_string</a> (const T &amp;t)</td></tr>
<tr class="separator:a1e7b53ed9c24a8dbec9f2305e908c5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memTemplParams" colspan="2">template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a834c6b595ada6f8e73c78d9bbd8ec551">fixed_power</a> (const T t)</td></tr>
<tr class="separator:a834c6b595ada6f8e73c78d9bbd8ec551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0900f35b37ee122e73fb2c80bba9beb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0900f35b37ee122e73fb2c80bba9beb9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">pow</a> (const T base, const <a class="el" href="classint.html">int</a> iexp)</td></tr>
<tr class="separator:a0900f35b37ee122e73fb2c80bba9beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0f9cd449850bf25160131cc4bc5668"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T &gt; </td></tr>
<tr class="memitem:aaa0f9cd449850bf25160131cc4bc5668"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aaa0f9cd449850bf25160131cc4bc5668">lower_bound</a> (Iterator first, Iterator last, const T &amp;val)</td></tr>
<tr class="separator:aaa0f9cd449850bf25160131cc4bc5668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename T , typename Comp &gt; </td></tr>
<tr class="memitem:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3c612c5ab6f6fe3937de5f82861d7533">lower_bound</a> (Iterator first, Iterator last, const T &amp;val, const Comp comp)</td></tr>
<tr class="separator:a3c612c5ab6f6fe3937de5f82861d7533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45dacd4df58c7a93611e06fed4b97cd"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ad45dacd4df58c7a93611e06fed4b97cd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Integer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ad45dacd4df58c7a93611e06fed4b97cd">reverse_permutation</a> (const std::vector&lt; Integer &gt; &amp;permutation)</td></tr>
<tr class="separator:ad45dacd4df58c7a93611e06fed4b97cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17441dc4ee67526f51da147f5653a38"><td class="memTemplParams" colspan="2">template&lt;typename Integer &gt; </td></tr>
<tr class="memitem:ae17441dc4ee67526f51da147f5653a38"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Integer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ae17441dc4ee67526f51da147f5653a38">invert_permutation</a> (const std::vector&lt; Integer &gt; &amp;permutation)</td></tr>
<tr class="separator:ae17441dc4ee67526f51da147f5653a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebf9e8745b1c1c0f314d24a1ec90921"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ebf9e8745b1c1c0f314d24a1ec90921"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">pack</a> (const T &amp;object, std::vector&lt; char &gt; &amp;dest_buffer, const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a1ebf9e8745b1c1c0f314d24a1ec90921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18246c5d00bf120a058cd0f1c3c31e47"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18246c5d00bf120a058cd0f1c3c31e47"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a18246c5d00bf120a058cd0f1c3c31e47">pack</a> (const T &amp;object, const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a18246c5d00bf120a058cd0f1c3c31e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cf162221b13681933fcae78268c558"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82cf162221b13681933fcae78268c558"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">unpack</a> (const std::vector&lt; char &gt; &amp;buffer, const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a82cf162221b13681933fcae78268c558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a15c28893574e4d3c1887376fb185c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07a15c28893574e4d3c1887376fb185c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a07a15c28893574e4d3c1887376fb185c">unpack</a> (const std::vector&lt; char &gt;::const_iterator &amp;cbegin, const std::vector&lt; char &gt;::const_iterator &amp;cend, const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a07a15c28893574e4d3c1887376fb185c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cd26f2016fe62ab2cd01230a24e71f"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a50cd26f2016fe62ab2cd01230a24e71f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a50cd26f2016fe62ab2cd01230a24e71f">unpack</a> (const std::vector&lt; char &gt; &amp;buffer, T(&amp;unpacked_object)[N], const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a50cd26f2016fe62ab2cd01230a24e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db5c925d2b5221b0bb9b5be300ea1de"><td class="memTemplParams" colspan="2">template&lt;typename T , int N&gt; </td></tr>
<tr class="memitem:a3db5c925d2b5221b0bb9b5be300ea1de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a3db5c925d2b5221b0bb9b5be300ea1de">unpack</a> (const std::vector&lt; char &gt;::const_iterator &amp;cbegin, const std::vector&lt; char &gt;::const_iterator &amp;cend, T(&amp;unpacked_object)[N], const <a class="el" href="classbool.html">bool</a> allow_compression=true)</td></tr>
<tr class="separator:a3db5c925d2b5221b0bb9b5be300ea1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeed5a63bdfab1d4890682fda6dd25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a2aeed5a63bdfab1d4890682fda6dd25e">get_bit</a> (const unsigned char number, const unsigned <a class="el" href="classint.html">int</a> n)</td></tr>
<tr class="separator:a2aeed5a63bdfab1d4890682fda6dd25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc19608ea16d6ff5473c83c261822271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#abc19608ea16d6ff5473c83c261822271">set_bit</a> (unsigned char &amp;number, const unsigned <a class="el" href="classint.html">int</a> n, const <a class="el" href="classbool.html">bool</a> x)</td></tr>
<tr class="separator:abc19608ea16d6ff5473c83c261822271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4457a4656f1df496e01e2d396838461b"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a4457a4656f1df496e01e2d396838461b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; To &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a4457a4656f1df496e01e2d396838461b">dynamic_unique_cast</a> (std::unique_ptr&lt; From &gt; &amp;&amp;p)</td></tr>
<tr class="separator:a4457a4656f1df496e01e2d396838461b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0db556aff652f6765e5f7a373d8408"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b0db556aff652f6765e5f7a373d8408"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a0b0db556aff652f6765e5f7a373d8408">get_underlying_value</a> (T &amp;p)</td></tr>
<tr class="separator:a0b0db556aff652f6765e5f7a373d8408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dbc2ea3c952246c229da82619e5827"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49dbc2ea3c952246c229da82619e5827"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a49dbc2ea3c952246c229da82619e5827">get_underlying_value</a> (std::shared_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:a49dbc2ea3c952246c229da82619e5827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63c90105d4a987c7fd481a218049bb9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac63c90105d4a987c7fd481a218049bb9"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ac63c90105d4a987c7fd481a218049bb9">get_underlying_value</a> (const std::shared_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:ac63c90105d4a987c7fd481a218049bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0be7e999bcff29e0eeb32d461099f3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0be7e999bcff29e0eeb32d461099f3b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#ad0be7e999bcff29e0eeb32d461099f3b">get_underlying_value</a> (std::unique_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:ad0be7e999bcff29e0eeb32d461099f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfad0736928ec1b2040f4c4abe607aac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfad0736928ec1b2040f4c4abe607aac"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#acfad0736928ec1b2040f4c4abe607aac">get_underlying_value</a> (const std::unique_ptr&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:acfad0736928ec1b2040f4c4abe607aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5091cc3b5f91465b228b4934030380d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aa5091cc3b5f91465b228b4934030380d">DeclException2</a> (ExcInvalidNumber2StringConversersion, unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;When trying to convert &quot;&lt;&lt; arg1&lt;&lt; &quot; to a string with &quot;&lt;&lt; arg2&lt;&lt; &quot; digits&quot;)</td></tr>
<tr class="separator:aa5091cc3b5f91465b228b4934030380d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa1bd2d1af6d3383136abd7b9e8afdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#aafa1bd2d1af6d3383136abd7b9e8afdc">DeclException1</a> (ExcInvalidNumber, unsigned <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;Invalid number &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:aafa1bd2d1af6d3383136abd7b9e8afdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a67f68c6b9a288767dc58b55da823e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities.html#a21a67f68c6b9a288767dc58b55da823e">DeclException1</a> (ExcCantConvertString, std::string,&lt;&lt; &quot;Can't convert the string &quot;&lt;&lt; arg1&lt;&lt; &quot; to the desired type&quot;)</td></tr>
<tr class="separator:a21a67f68c6b9a288767dc58b55da823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace for utility functions that are not particularly specific to finite element computing or numerical programs, but nevertheless are needed in various contexts when writing applications. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a91c51abf8f95716de44ab318e4c0857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c51abf8f95716de44ab318e4c0857d">&#9670;&nbsp;</a></span>create_evenly_distributed_partitioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> Utilities::create_evenly_distributed_partitioning </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>my_partition_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_partitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a>&#160;</td>
          <td class="paramname"><em>total_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the total number of elements <code>total_size</code>, create an evenly distributed 1:1 partitioning of the elements for across <code>n_partitions</code>. The local sizes will be equal to the <code>total_size</code> divided by the number of partitions plus the remainder being divided amongst the first processes. Each process will store a contiguous subset of indices, and the index set on process p+1 starts at the index one larger than the last one stored on process p. For example, a <code>total_size</code> of 11 with 3 processes will result in the IndexSets { [0,4), [4,8), [8,11)] }, and this function will return the <code>my_partition_id</code> 's <a class="el" href="classIndexSet.html">IndexSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00071">71</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a244dcff7d2307d223bd2da9bf0b13ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244dcff7d2307d223bd2da9bf0b13ec0">&#9670;&nbsp;</a></span>mutable_bind() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt;ReturnType, FunctionArgs...&gt; Utilities::mutable_bind </td>
          <td>(</td>
          <td class="paramtype">ReturnType(*)(FunctionArgs...)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structidentity.html">identity</a>&lt; FunctionArgs &gt;::type &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object from a function pointer and a list of arguments.</p>
<p>An example usage is given by: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_function(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;a, <span class="keyword">const</span> <span class="keywordtype">double</span> &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> bound = <a class="code" href="namespaceUtilities.html#a244dcff7d2307d223bd2da9bf0b13ec0">mutable_bind</a>(my_function, 1, 2.0);</div><div class="line"></div><div class="line">bound(); <span class="comment">// will execute my_function(1, 2.0);</span></div><div class="line"></div><div class="line">bound.set_arguments(2, 3.0);</div><div class="line">bound(); <span class="comment">// will execute my_function(2, 3.0);</span></div><div class="line"></div><div class="line">bound.parse_arguments(<span class="stringliteral">&quot;3: 4.0&quot;</span>);</div><div class="line">bound(); <span class="comment">// will execute my_function(3, 4.0);</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ac77cb0654e4a283ed11a62fa5913ae86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77cb0654e4a283ed11a62fa5913ae86">&#9670;&nbsp;</a></span>mutable_bind() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt;ReturnType, FunctionArgs...&gt; Utilities::mutable_bind </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; ReturnType(FunctionArgs...)&gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structidentity.html">identity</a>&lt; FunctionArgs &gt;::type &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, using a std::function object. </p>

</div>
</div>
<a id="ac040436711f265a2285730068b83030e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac040436711f265a2285730068b83030e">&#9670;&nbsp;</a></span>mutable_bind() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt;ReturnType, FunctionArgs...&gt; Utilities::mutable_bind </td>
          <td>(</td>
          <td class="paramtype">ReturnType(*)(FunctionArgs...)&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a> object from a function pointer, with uninitialized arguments.</p>
<p>Notice that if you do not call one of the <a class="el" href="classUtilities_1_1MutableBind.html#a8c9892610afbf8e437530a3302c290a8">MutableBind::set_arguments()</a> methods, or the <a class="el" href="classUtilities_1_1MutableBind.html#ad675baf4560885f06f27387bff9c1969">MutableBind::parse_arguments()</a> function on the returned object, then the arguments passed to the function object will be initialized with the values coming from each of the arguments' default constructors. </p>

</div>
</div>
<a id="ad14397edd57e34da458930d8e83a2de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14397edd57e34da458930d8e83a2de4">&#9670;&nbsp;</a></span>mutable_bind() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , class... FunctionArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classUtilities_1_1MutableBind.html">MutableBind</a>&lt;ReturnType, FunctionArgs...&gt; Utilities::mutable_bind </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; ReturnType(FunctionArgs...)&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, using a std::function object. </p>

</div>
</div>
<a id="ab38806c4f02f69c071d8893f81e3c0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38806c4f02f69c071d8893f81e3c0ce">&#9670;&nbsp;</a></span>dealii_version_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::dealii_version_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string of the form "deal.II version x.y.z" where "x.y.z" identifies the version of deal.II you are using. This information is also provided by the DEAL_II_PACKAGE_NAME and DEAL_II_PACKAGE_VERSION preprocessor variables. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00097">97</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a3c2518180c950be48153d93410f70d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2518180c950be48153d93410f70d3c">&#9670;&nbsp;</a></span>inverse_Hilbert_space_filling_curve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; std::uint64_t, dim &gt; &gt; Utilities::inverse_Hilbert_space_filling_curve </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bits_per_dim</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign to each point in <code>points</code> an index using the Hilbert space filling curve. To that end, a bounding box for <code>points</code> will be determined, based on which their integer coordinates are calculated. The linear index is given as a dim-collection of bits, from high to low. This is done in order to keep the maximum resolution in terms of bit depth along each axis. Note that this dim-integer index can still be easily used for sorting and ordering, for example using the lexicographic ordering of tuples of integers.</p>
<p>The depth of the Hilbert curve (i.e. the number of bits per dimension) by default is equal to <code>64</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also handle degenerate cases, e.g. when the bounding box has zero size in one of the dimensions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00148">148</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a4f382174c57e11ba880c019baa9761ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f382174c57e11ba880c019baa9761ce">&#9670;&nbsp;</a></span>inverse_Hilbert_space_filling_curve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; std::uint64_t, dim &gt; &gt; Utilities::inverse_Hilbert_space_filling_curve </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::array&lt; std::uint64_t, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bits_per_dim</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but for points in integer coordinates. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00257">257</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a2710626bb38ca169232a2d11571ddb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2710626bb38ca169232a2d11571ddb4c">&#9670;&nbsp;</a></span>pack_integers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t Utilities::pack_integers </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::uint64_t, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>bits_per_dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pack the least significant <code>bits_per_dim</code> bits from each element of <code>index</code> (starting from last) into a single unsigned integer. The last element of <code>index</code> will be used to set the first <code>bits_per_dim</code> bits in the resulting integer, the second to last element is used to set the next <code>bits_per_dim</code> bits, etc.. To fit all the data into the output, the following should hold <code>bits_per_dim * dim &lt;= 64</code>.</p>
<p>The function is useful in debugging and visualization of indices returned by <a class="el" href="namespaceUtilities.html#a3c2518180c950be48153d93410f70d3c">inverse_Hilbert_space_filling_curve()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>There is no need to use this function in order to compare indices returned by <a class="el" href="namespaceUtilities.html#a3c2518180c950be48153d93410f70d3c">inverse_Hilbert_space_filling_curve()</a>, as that can easily be done via <code><a class="el" href="namespacemystl.html#a18608c3326637cec51bc756768e7c7c4">std::lexicographical_compare()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00369">369</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a6155277fd058eddb1504f9562cb1c04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6155277fd058eddb1504f9562cb1c04d">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::compress </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the library is configured with ZLIB, then this function compresses the input string and returns a non-zero terminated string containing the compressed input.</p>
<p>If the library was not configured with ZLIB enabled, the returned string is identical to the input string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The string to compress</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A compressed version of the input string </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00392">392</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a8621974566702000fa007c7537c39bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8621974566702000fa007c7537c39bae">&#9670;&nbsp;</a></span>decompress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::decompress </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>compressed_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the library is configured with ZLIB, then this function assumes that the input string has been compressed using the <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> function, and returns the original decompressed string.</p>
<p>If the library was not configured with ZLIB enabled, the returned string is identical to the input string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">compressed_input</td><td>A compressed string, as returned by the function <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The original uncompressed string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00414">414</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a3b872a22ae12bc52e151da92e3d996ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b872a22ae12bc52e151da92e3d996ec">&#9670;&nbsp;</a></span>encode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::encode_base64 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>binary_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes the binary input as a base64 string.</p>
<p>Base64 is a group of binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation. Base64 is designed to carry data stored in binary formats across channels that only reliably support text content. It is used also to store binary formats in a machine independent way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary_input</td><td>A vector of characters, representing your input as binary data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the binary input as a base64 string. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00436">436</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a5262eb044e97d6f5c014791e31c4084f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5262eb044e97d6f5c014791e31c4084f">&#9670;&nbsp;</a></span>decode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned char &gt; Utilities::decode_base64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base64_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decodes a base64 string into a binary output.</p>
<p>This is the inverse of the <a class="el" href="namespaceUtilities.html#a3b872a22ae12bc52e151da92e3d996ec">encode_base64()</a> function above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base64_input</td><td>A string that contains the input in base64 format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of characters that represents your input as binary data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00449">449</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a6195c5f009ea8c7c536c6ffdf108c32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6195c5f009ea8c7c536c6ffdf108c32f">&#9670;&nbsp;</a></span>int_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::int_to_string </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>digits</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a number <code>value</code> to a string, with as many digits as given to fill with leading zeros.</p>
<p>If the second parameter is left at its default value, the number is not padded with leading zeros. The result is then the same as if the standard C++ <code>std::to_string</code> (or the older C function <code>itoa()</code>) had been called.</p>
<p>This function takes an <code>unsigned int</code> as argument. As a consequence, if you call it with a <code>signed int</code> (which is of course the same type as <code>int</code>), the argument is implicitly converted to unsigned integers and negative numbers may not be printed as you had hoped. Similarly, if you call the function with a <code>long int</code>, the printed result might show the effects of an overflow upon conversion to <code>unsigned int</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The use of this function is discouraged and users should use <code><a class="el" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">Utilities::to_string()</a></code> instead. In its current implementation the function simply calls <code>to_string&lt;unsigned int&gt;()</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00473">473</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a56cb23f1982e4aa0bec09b60903303ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cb23f1982e4aa0bec09b60903303ce">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::to_string </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>digits</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a number <code>value</code> to a string, with <code>digits</code> characters. The string is padded with leading zeros, after a possible minus sign. Therefore the total number of padding zeros is <code>digits</code> minus any signs, decimal points and digits of <code>value</code>.</p>
<p>If the second parameter is left at its default value, the number is not padded with leading zeros. The result is then the same as if the C++ function <code><a class="el" href="namespaceUtilities.html#a56cb23f1982e4aa0bec09b60903303ce">std::to_string()</a></code> had been called (for integral types), or if <code>boost::lexical_cast()</code> had been called (for all other types). </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00482">482</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a9c75f3b2b9de645e7432eba26e59499b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c75f3b2b9de645e7432eba26e59499b">&#9670;&nbsp;</a></span>needed_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Utilities::needed_digits </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine how many digits are needed to represent numbers at most as large as the given number. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00568">568</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a17955af7a4bc8771d430e622f9e732b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17955af7a4bc8771d430e622f9e732b3">&#9670;&nbsp;</a></span>truncate_to_n_digits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number Utilities::truncate_to_n_digits </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_digits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allows to cut off a floating point number <code>number</code> after <code>n_digits</code> of accuracy, i.e., after <code>n_digits</code> decimal places in scientific floating point notation. When interpreted as rounding operation, this function reduces the absolute value of a floating point number and always rounds towards zero, since decimal places are simply cut off. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00581">581</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="af7e8ff146c677d8a2408b88e4936f57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8ff146c677d8a2408b88e4936f57d">&#9670;&nbsp;</a></span>string_to_int() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> Utilities::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, convert it to an integer. Throw an assertion if that is not possible. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00608">608</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a21aa22d290ce783e37587b6c879b926c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aa22d290ce783e37587b6c879b926c">&#9670;&nbsp;</a></span>dim_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::dim_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>spacedim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string describing the dimensions of the object. Often, functions in the deal.II library as well as in user codes need to define a string containing the template dimensions of some objects defined using two template parameters: dim (the topological dimension of the object) and spacedim (the dimension of the embedding Euclidean space). Since in all deal.II classes, by default spacedim is equal to dimension, the above string is usually contracted to "&lt;dim&gt;", instead of "&lt;dim,spacedim&gt;". This function returns a string containing "dim" if dim is equal to spacedim, otherwise it returns "dim,spacedim". </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00558">558</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="af501c72fdc02dd969cd9d82d0f30642c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af501c72fdc02dd969cd9d82d0f30642c">&#9670;&nbsp;</a></span>string_to_int() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classint.html">int</a> &gt; Utilities::string_to_int </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of strings, convert it to a list of integers. Throw an assertion if that is not possible. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00645">645</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ab3177021843ad87857e6f8c5d98d29a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3177021843ad87857e6f8c5d98d29a5">&#9670;&nbsp;</a></span>string_to_double() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> Utilities::string_to_double </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string, convert it to an double. Throw an assertion if that is not possible. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00656">656</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a4cd7c2e406c4e77b2cbbd2d68d2251a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd7c2e406c4e77b2cbbd2d68d2251a5">&#9670;&nbsp;</a></span>string_to_double() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; Utilities::string_to_double </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of strings, convert it to a list of doubles. Throw an assertion if that is not possible. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00693">693</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a0a2b9ceded96f25b47eccd7c177dc67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a2b9ceded96f25b47eccd7c177dc67e">&#9670;&nbsp;</a></span>split_string_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utilities::split_string_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a string that contains text separated by a <code>delimiter</code>, split it into its components; for each component, remove leading and trailing spaces. The default value of the delimiter is a comma, so that the function splits comma separated lists of strings.</p>
<p>To make data input from tables simpler, if the input string ends in a delimiter (possibly followed by an arbitrary amount of whitespace), then this last delimiter is ignored. For example, </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc; def; ghi; &quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> yields the same 3-element list of output <code>{"abc","def","ghi"}</code> as you would get if the input had been </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc; def; ghi&quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc; def; ghi;&quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> As a consequence of this rule, a call like </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot; ; &quot;</span>, <span class="charliteral">&#39;;&#39;</span>);</div></div><!-- fragment --><p> yields a one-element list. Because of the trimming of whitespace, the single element is the empty string.</p>
<p>This function can digest the case that the delimiter is a space. In this case, it returns all words in the string. Combined with the rules above, this implies that </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;abc def ghi &quot;</span>, <span class="charliteral">&#39; &#39;</span>);</div></div><!-- fragment --><p> yields again the 3-element list of output <code>{"abc","def","ghi"}</code> from above despite the presence of space at the end of the string. Furthermore, </p><div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">Utilities::split_string_list</a>(<span class="stringliteral">&quot;      &quot;</span>, <span class="charliteral">&#39; &#39;</span>);</div></div><!-- fragment --><p> yields an empty list regardless of the number of spaces in the string. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00704">704</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="acd4d5a4196ba3f39b96876c320a6ac88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4d5a4196ba3f39b96876c320a6ac88">&#9670;&nbsp;</a></span>split_string_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utilities::split_string_list </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization of <a class="el" href="namespaceUtilities.html#a0a2b9ceded96f25b47eccd7c177dc67e">split_string_list()</a> for the case where the delimiter is a single char. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00749">749</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a5448c92da85de774d6274e9a27797443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5448c92da85de774d6274e9a27797443">&#9670;&nbsp;</a></span>break_text_into_lines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utilities::break_text_into_lines </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a text, usually a documentation or something, and try to break it into individual lines of text at most <code>width</code> characters wide, by breaking at positions marked by <code>delimiter</code> in the text. If this is not possible, return the shortest lines that are longer than <code>width</code>. The default value of the delimiter is a space character. If original_text contains newline characters (<br />
), the string is split at these locations, too. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00758">758</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a6b37ad8cfa930cb1ff91d68562553fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b37ad8cfa930cb1ff91d68562553fec">&#9670;&nbsp;</a></span>match_at_string_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Utilities::match_at_string_start </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given pattern string appears in the first position of the string. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00838">838</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a2dbc4b2f7fb9ef31b841667a47ce3955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dbc4b2f7fb9ef31b841667a47ce3955">&#9670;&nbsp;</a></span>get_integer_at_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; Utilities::get_integer_at_position </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a (signed) integer starting at the position in <code>name</code> indicated by the second argument, and return this integer as a pair together with how many characters it takes up in the string.</p>
<p>If no integer can be read at the indicated position, return (-1,<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>) </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00853">853</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a51121974cb2781c8bbb0ec281ece9f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51121974cb2781c8bbb0ec281ece9f40">&#9670;&nbsp;</a></span>replace_in_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::replace_in_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string with all occurrences of <code>from</code> in <code>input</code> replaced by <code>to</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00512">512</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="aca117b9cf9345b7ae7b72a075ddde116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca117b9cf9345b7ae7b72a075ddde116">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a string with all standard whitespace characters (including '<code>\t</code>', '<code>\n</code>', and '<code>\r</code>') at the beginning and end of <code>input</code> removed. </p>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00531">531</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="acc6aef87ce08208501a4b524563836db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6aef87ce08208501a4b524563836db">&#9670;&nbsp;</a></span>generate_normal_random_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> Utilities::generate_normal_random_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a random number from a normalized Gaussian probability distribution centered around <code>a</code> and with standard deviation <code>sigma</code>. The returned number will be different every time the function is called.</p>
<p>This function is reentrant, i.e., it can safely be called from multiple threads at the same time. In addition, each thread will get the same sequence of numbers every time. On the other hand, if you run <a class="el" href="classThreads_1_1Task.html">Threads::Task</a> objects via the Threading Building Blocks, then tasks will be assigned to mostly random threads, and may get a different sequence of random numbers in different runs of the program, since a previous task may already have consumed the first few random numbers generated for the thread you're on. If this is a problem, you need to create your own random number generator objects every time you want to start from a defined point.</p>
<dl class="section note"><dt>Note</dt><dd>Like the system function rand(), this function produces the same sequence of random numbers every time a program is started. This is an important property for debugging codes, but it makes it impossible to really verify statistical properties of a code. For <code>rand()</code>, you can call <code>srand()</code> to "seed" the random number generator to get different sequences of random numbers every time a program is called. However, this function does not allow seeding the random number generator. If you need this, as above, use one of the C++ or BOOST facilities. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2utilities_8cc_source.html#l00895">895</a> of file <a class="el" href="base_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a1e7b53ed9c24a8dbec9f2305e908c5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7b53ed9c24a8dbec9f2305e908c5ff">&#9670;&nbsp;</a></span>type_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utilities::type_to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a string description of the type of the variable <code>t</code>.</p>
<p>In general, C++ uses mangled names to identify types. This function uses boost::core::demangle to return a human readable string describing the type of the variable passed as argument. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01102">1102</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a834c6b595ada6f8e73c78d9bbd8ec551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834c6b595ada6f8e73c78d9bbd8ec551">&#9670;&nbsp;</a></span>fixed_power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::fixed_power </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate a fixed power, provided as a template argument, of a number.</p>
<p>This function provides an efficient way to calculate things like <code>t^N</code> where <code>N</code> is a known number at compile time.</p>
<p>Use this function as in <code>fixed_power&lt;dim&gt; (n)</code>. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01081">1081</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a0900f35b37ee122e73fb2c80bba9beb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0900f35b37ee122e73fb2c80bba9beb9">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T Utilities::pow </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>iexp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A replacement for <code>std::pow</code> that allows compile-time calculations for constant expression arguments. The <code>base</code> must be an integer type and the exponent <code>iexp</code> must not be negative. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l00461">461</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aaa0f9cd449850bf25160131cc4bc5668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0f9cd449850bf25160131cc4bc5668">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator Utilities::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Optimized replacement for <code>std::lower_bound</code> for searching within the range of column indices. Slashes execution time by approximately one half for the present application, partly because the binary search is replaced by a linear search for small loop lengths.</p>
<p>Another reason for this function is rather obscure: when using the GCC libstdc++ function std::lower_bound, complexity is O(log(N)) as required. However, when using the debug version of the GCC libstdc++ as we do when running the testsuite, then std::lower_bound tests whether the sequence is in fact partitioned with respect to the pivot 'value' (i.e. in essence that the sequence is sorted as required for binary search to work). However, verifying this means that the complexity of std::lower_bound jumps to O(N); we call this function O(N) times below, making the overall complexity O(N**2). The consequence is that a few tests with big meshes completely run off the wall time limit for tests and fail with the libstdc++ debug mode</p>
<p>This function simply makes the assumption that the sequence is sorted, and we simply don't do the additional check. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01111">1111</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a3c612c5ab6f6fe3937de5f82861d7533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c612c5ab6f6fe3937de5f82861d7533">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename T , typename Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Iterator Utilities::lower_bound </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same function as above, but taking an argument that is used to compare individual elements of the sequence of objects pointed to by the iterators. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01120">1120</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ad45dacd4df58c7a93611e06fed4b97cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45dacd4df58c7a93611e06fed4b97cd">&#9670;&nbsp;</a></span>reverse_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Integer &gt; Utilities::reverse_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector \(p_0\ldots p_{N-1}\) where each \(p_i\in [0,N)\) and \(p_i\neq p_j\) for \(i\neq j\)), produce the reverse permutation \(q_i=N-1-p_i\). </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01471">1471</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ae17441dc4ee67526f51da147f5653a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17441dc4ee67526f51da147f5653a38">&#9670;&nbsp;</a></span>invert_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Integer &gt; Utilities::invert_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Integer &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a permutation vector (i.e. a vector \(p_0\ldots p_{N-1}\) where each \(p_i\in [0,N)\) and \(p_i\neq p_j\) for \(i\neq j\)), produce the inverse permutation \(q_0\ldots q_{N-1}\) so that \(q_{p_i}=p_{q_i}=i\). </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01486">1486</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a1ebf9e8745b1c1c0f314d24a1ec90921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebf9e8745b1c1c0f314d24a1ec90921">&#9670;&nbsp;</a></span>pack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Utilities::pack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an arbitrary object of type T, use boost::serialization utilities to pack the object into a vector of characters and append it to the given buffer. The number of elements that have been added to the buffer will be returned. The object can be unpacked using the <a class="el" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">Utilities::unpack</a> function below.</p>
<p>If the library has been compiled with ZLIB enabled, then the output buffer can be compressed. This can be triggered with the parameter <code>allow_compression</code>, and is only of effect if ZLIB is enabled.</p>
<p>If many consecutive calls with the same buffer are considered, it is recommended for reasons of performance to ensure that its capacity is sufficient. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01218">1218</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a18246c5d00bf120a058cd0f1c3c31e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18246c5d00bf120a058cd0f1c3c31e47">&#9670;&nbsp;</a></span>pack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; char &gt; Utilities::pack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and returns a buffer solely for the given object, using the above mentioned pack function.</p>
<p>If the library has been compiled with ZLIB enabled, then the output buffer can be compressed. This can be triggered with the parameter <code>allow_compression</code>, and is only of effect if ZLIB is enabled. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01270">1270</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a82cf162221b13681933fcae78268c558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cf162221b13681933fcae78268c558">&#9670;&nbsp;</a></span>unpack() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a vector of characters, obtained through a call to the function <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack</a>, restore its content in an object of type T.</p>
<p>This function uses boost::serialization utilities to unpack the object from a vector of characters, and it is the inverse of the function <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack()</a>.</p>
<p>The <code>allow_compression</code> parameter denotes if the buffer to read from could have been previously compressed with ZLIB, and is only of effect if ZLIB is enabled.</p>
<dl class="section note"><dt>Note</dt><dd>Since no arguments to this function depend on the template type <code>T</code>, you must manually specify the template argument when calling this function.</dd>
<dd>
If you want to <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">pack()</a> or <a class="el" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">unpack()</a> arrays of objects, then the following works: <div class="fragment"><div class="line"><span class="keywordtype">double</span> array[3] = {1,2,3};</div><div class="line">std::vector&lt;char&gt; buffer = <a class="code" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack</a>(array);</div></div><!-- fragment --> However, the converse does not: <div class="fragment"><div class="line">array = Utilities::unpack&lt;double[3]&gt;(buffer);</div></div><!-- fragment --> This is because C++ does not allow functions to return arrays. Consequently, there is a separate <a class="el" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">unpack()</a> function for arrays, see below. </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01321">1321</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a07a15c28893574e4d3c1887376fb185c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a15c28893574e4d3c1887376fb185c">&#9670;&nbsp;</a></span>unpack() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>cbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>cend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same unpack function as above, but takes constant iterators on (a fraction of) a given packed buffer of type std::vector&lt;char&gt; instead.</p>
<p>The <code>allow_compression</code> parameter denotes if the buffer to read from could have been previously compressed with ZLIB, and is only of effect if ZLIB is enabled. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01280">1280</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a50cd26f2016fe62ab2cd01230a24e71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cd26f2016fe62ab2cd01230a24e71f">&#9670;&nbsp;</a></span>unpack() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>unpacked_object</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a vector of characters, obtained through a call to the function <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack</a>, restore its content in an array of type T.</p>
<p>This function uses boost::serialization utilities to unpack the object from a vector of characters, and it is the inverse of the function <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack()</a>.</p>
<p>The <code>allow_compression</code> parameter denotes if the buffer to read from could have been previously compressed with ZLIB, and is only of effect if ZLIB is enabled.</p>
<dl class="section note"><dt>Note</dt><dd>This function exists due to a quirk of C++. Specifically, if you want to <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">pack()</a> or <a class="el" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">unpack()</a> arrays of objects, then the following works: <div class="fragment"><div class="line"><span class="keywordtype">double</span> array[3] = {1,2,3};</div><div class="line">std::vector&lt;char&gt; buffer = <a class="code" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack</a>(array);</div></div><!-- fragment --> However, the converse does not: <div class="fragment"><div class="line">array = Utilities::unpack&lt;double[3]&gt;(buffer);</div></div><!-- fragment --> This is because C++ does not allow functions to return arrays. The current function therefore allows to write <div class="fragment"><div class="line"><a class="code" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">Utilities::unpack</a>(buffer, array);</div></div><!-- fragment --> Note that unlike the other <a class="el" href="namespaceUtilities.html#a82cf162221b13681933fcae78268c558">unpack()</a> function, it is not necessary to explicitly specify the template arguments since they can be deduced from the second argument. </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01367">1367</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a3db5c925d2b5221b0bb9b5be300ea1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db5c925d2b5221b0bb9b5be300ea1de">&#9670;&nbsp;</a></span>unpack() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::unpack </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>cbegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>cend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>unpacked_object</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_compression</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same unpack function as above, but takes constant iterators on (a fraction of) a given packed buffer of type std::vector&lt;char&gt; instead.</p>
<p>The <code>allow_compression</code> parameter denotes if the buffer to read from could have been previously compressed with ZLIB, and is only of effect if ZLIB is enabled. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01329">1329</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a2aeed5a63bdfab1d4890682fda6dd25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeed5a63bdfab1d4890682fda6dd25e">&#9670;&nbsp;</a></span>get_bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Utilities::get_bit </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the bit at position <code>n</code> in <code>number</code> is set. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01380">1380</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="abc19608ea16d6ff5473c83c261822271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc19608ea16d6ff5473c83c261822271">&#9670;&nbsp;</a></span>set_bit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::set_bit </td>
          <td>(</td>
          <td class="paramtype">unsigned char &amp;&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the bit at position <code>n</code> in <code>number</code> to value <code>x</code>. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01393">1393</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a4457a4656f1df496e01e2d396838461b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4457a4656f1df496e01e2d396838461b">&#9670;&nbsp;</a></span>dynamic_unique_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; To &gt; Utilities::dynamic_unique_cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; From &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an object of type <code>std::unique_ptr&lt;From&gt;</code> to an object of type <code>std::unique_ptr&lt;To&gt;</code>, where it is assumed that we can cast the pointer to <code>From</code> to a pointer to <code>To</code> using a <code>dynamic_cast</code> &ndash; in other words, we assume that <code>From</code> and <code>To</code> are connected through a class hierarchy, and that the object pointed to is in fact of a type that contains both a <code>From</code> and a <code>To</code>. An example is if either <code>To</code> is derived from <code>From</code> or the other way around.</p>
<p>The function throws an exception of type <code>std::bad_cast</code> if the <code>dynamic_cast</code> does not succeed. This is the same exception you would get if a regular <code>dynamic_cast</code> between object types (but not pointer types) does not succeed.</p>
<p>An example of how this function works is as follows: </p><div class="fragment"><div class="line"><span class="comment">// A base class. Assume that it has virtual</span></div><div class="line"><span class="comment">// functions so that dynamic_cast can work.</span></div><div class="line"><span class="keyword">class </span>B</div><div class="line">{</div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// A derived class</span></div><div class="line"><span class="keyword">class </span>D : <span class="keyword">public</span> B</div><div class="line">{</div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// A factory function</span></div><div class="line">std::unique_ptr&lt;B&gt; create_object (...)</div><div class="line">{</div><div class="line">  ...</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> foo (...)</div><div class="line">{</div><div class="line">  std::unique_ptr&lt;B&gt; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a> = create_object (...);</div><div class="line"></div><div class="line">  <span class="comment">// Assume that we know for some reason that the object above must</span></div><div class="line">  <span class="comment">// have created a D object but returned it as a std::unique_ptr&lt;B&gt;.</span></div><div class="line">  <span class="comment">// In order to access the D functionality, we need to cast the</span></div><div class="line">  <span class="comment">// pointer. Use the equivalent to dynamic_cast:</span></div><div class="line">  std::unique_ptr&lt;D&gt; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = <a class="code" href="namespaceUtilities.html#a4457a4656f1df496e01e2d396838461b">dynamic_unique_cast</a>&lt;D&gt;(<a class="code" href="namespacemystl.html#a663604ca23ed4b96db3d1a6e301615db">std::move</a>(b));</div><div class="line"></div><div class="line">  <span class="comment">// If the object really was a D, then &#39;d&#39; now points to it. Note</span></div><div class="line">  <span class="comment">// also that in accordance with the semantics of std::unique_ptr,</span></div><div class="line">  <span class="comment">// it was necessary to std::move the &#39;b&#39; object, and indeed &#39;b&#39;</span></div><div class="line">  <span class="comment">// now no longer points to anything -- ownership has been</span></div><div class="line">  <span class="comment">// transferred to &#39;d&#39;!</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This function does not try to convert the <code>Deleter</code> objects stored by <code>std::unique_ptr</code> objects. The function therefore only works if the deleter objects are at their defaults, i.e., if they are of type <code>std::default_delete&lt;To&gt;</code> and <code>std::default_delete&lt;From&gt;</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01407">1407</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a0b0db556aff652f6765e5f7a373d8408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0db556aff652f6765e5f7a373d8408">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return underlying value. Default: return input. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01426">1426</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a49dbc2ea3c952246c229da82619e5827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49dbc2ea3c952246c229da82619e5827">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return underlying value. Specialization for std::shared_ptr&lt;T&gt;. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01435">1435</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ac63c90105d4a987c7fd481a218049bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63c90105d4a987c7fd481a218049bb9">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return underlying value. Specialization for const std::shared_ptr&lt;T&gt;. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01444">1444</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ad0be7e999bcff29e0eeb32d461099f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0be7e999bcff29e0eeb32d461099f3b">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return underlying value. Specialization for std::unique_ptr&lt;T&gt;. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01453">1453</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="acfad0736928ec1b2040f4c4abe607aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfad0736928ec1b2040f4c4abe607aac">&#9670;&nbsp;</a></span>get_underlying_value() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; Utilities::get_underlying_value </td>
          <td>(</td>
          <td class="paramtype">const std::unique_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return underlying value. Specialization for const std::unique_ptr&lt;T&gt;. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html#l01462">1462</a> of file <a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aa5091cc3b5f91465b228b4934030380d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5091cc3b5f91465b228b4934030380d">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Utilities::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidNumber2StringConversersion&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;When trying to convert &quot;&lt;&lt; arg1&lt;&lt; &quot; to a string with &quot;&lt;&lt; arg2&lt;&lt; &quot; digits&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafa1bd2d1af6d3383136abd7b9e8afdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa1bd2d1af6d3383136abd7b9e8afdc">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Utilities::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidNumber&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Invalid number &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21a67f68c6b9a288767dc58b55da823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a67f68c6b9a288767dc58b55da823e">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Utilities::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcCantConvertString&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Can't convert the string &quot;&lt;&lt; arg1&lt;&lt; &quot; to the desired type&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
