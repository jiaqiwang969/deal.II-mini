<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceGridGenerator.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GridGenerator Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">GridGenerator Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceGridGenerator_1_1Airfoil"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator_1_1Airfoil.html">Airfoil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Creating meshes for basic geometries</div></td></tr>
<tr class="memitem:acea0cbcd68e52ce8113d1134b87de403"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acea0cbcd68e52ce8113d1134b87de403"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:acea0cbcd68e52ce8113d1134b87de403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1a8bdb6ff5ca4d25a7f709c543b798"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7a1a8bdb6ff5ca4d25a7f709c543b798"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a7a1a8bdb6ff5ca4d25a7f709c543b798">simplex</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, dim &gt; &amp;tria, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>)</td></tr>
<tr class="separator:a7a1a8bdb6ff5ca4d25a7f709c543b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9a83e353f8d69ce49ebdd191a3a51f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aeb9a83e353f8d69ce49ebdd191a3a51f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aeb9a83e353f8d69ce49ebdd191a3a51f">reference_cell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;reference_cell)</td></tr>
<tr class="separator:aeb9a83e353f8d69ce49ebdd191a3a51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358d5bd545bc115c8645d93fa79b64bc"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a358d5bd545bc115c8645d93fa79b64bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">subdivided_hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> repetitions, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a358d5bd545bc115c8645d93fa79b64bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56019d263ae45708302d5d7599f0d458"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a56019d263ae45708302d5d7599f0d458"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a56019d263ae45708302d5d7599f0d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76417d7404b75cf53c732f456e6e971"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac76417d7404b75cf53c732f456e6e971"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;repetitions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:ac76417d7404b75cf53c732f456e6e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af215d99be737f1c91f166669e783449e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:af215d99be737f1c91f166669e783449e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#af215d99be737f1c91f166669e783449e">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;step_sizes, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p_1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p_2, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:af215d99be737f1c91f166669e783449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19141a2f24b10ce86f7f90d1661e2ced"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a19141a2f24b10ce86f7f90d1661e2ced"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a19141a2f24b10ce86f7f90d1661e2ced">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;spacing, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const <a class="el" href="classTable.html">Table</a>&lt; dim, <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> &gt; &amp;material_id, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a19141a2f24b10ce86f7f90d1661e2ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c54698f4666a44ac3982ee62f87ee9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a76c54698f4666a44ac3982ee62f87ee9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a76c54698f4666a44ac3982ee62f87ee9">cheese</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;holes)</td></tr>
<tr class="memdesc:a76c54698f4666a44ac3982ee62f87ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rectangular domain with rectangular pattern of holes.  <a href="#a76c54698f4666a44ac3982ee62f87ee9">More...</a><br /></td></tr>
<tr class="separator:a76c54698f4666a44ac3982ee62f87ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cef2def7a0b1ce88eef4ec630b1e3b8"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a1cef2def7a0b1ce88eef4ec630b1e3b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a1cef2def7a0b1ce88eef4ec630b1e3b8">plate_with_a_hole</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> inner_radius=0.4, const <a class="el" href="classdouble.html">double</a> outer_radius=1., const <a class="el" href="classdouble.html">double</a> pad_bottom=2., const <a class="el" href="classdouble.html">double</a> pad_top=2., const <a class="el" href="classdouble.html">double</a> pad_left=1., const <a class="el" href="classdouble.html">double</a> pad_right=1., const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> polar_manifold_id=0, const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> tfi_manifold_id=1, const <a class="el" href="classdouble.html">double</a> L=1., const unsigned <a class="el" href="classint.html">int</a> n_slices=2, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="memdesc:a1cef2def7a0b1ce88eef4ec630b1e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rectangular plate with an (offset) cylindrical hole.  <a href="#a1cef2def7a0b1ce88eef4ec630b1e3b8">More...</a><br /></td></tr>
<tr class="separator:a1cef2def7a0b1ce88eef4ec630b1e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0b8a34fe5ca58425aa1fcf0d6132f1"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a9d0b8a34fe5ca58425aa1fcf0d6132f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a9d0b8a34fe5ca58425aa1fcf0d6132f1">channel_with_cylinder</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> shell_region_width=0.03, const unsigned <a class="el" href="classint.html">int</a> n_shells=2, const <a class="el" href="classdouble.html">double</a> skewness=2.0, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a9d0b8a34fe5ca58425aa1fcf0d6132f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a8e0666bdbfa278179377c47536b8e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a22a8e0666bdbfa278179377c47536b8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a22a8e0666bdbfa278179377c47536b8e">general_cell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a22a8e0666bdbfa278179377c47536b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324b8447f05b148e2f58bdbcf89f5325"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a324b8447f05b148e2f58bdbcf89f5325"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a324b8447f05b148e2f58bdbcf89f5325">parallelogram</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a324b8447f05b148e2f58bdbcf89f5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c6b55bcadf6596001a1e232a8faad"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a016c6b55bcadf6596001a1e232a8faad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a016c6b55bcadf6596001a1e232a8faad">parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a016c6b55bcadf6596001a1e232a8faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91269092ac149bdc6df9baabad785d02"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a91269092ac149bdc6df9baabad785d02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a91269092ac149bdc6df9baabad785d02">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> n_subdivisions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a91269092ac149bdc6df9baabad785d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e16fb3b8412754508c3b574f3ccfdbc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a3e16fb3b8412754508c3b574f3ccfdbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a3e16fb3b8412754508c3b574f3ccfdbc">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a>(&amp;n_subdivisions)[dim], const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a3e16fb3b8412754508c3b574f3ccfdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93a16355ace7092f5160b44cfeac767"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa93a16355ace7092f5160b44cfeac767"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aa93a16355ace7092f5160b44cfeac767">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;origin, const std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, dim &gt; &amp;edges, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;subdivisions={}, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:aa93a16355ace7092f5160b44cfeac767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c537aebe22842ec22de2c8b5c545896"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2c537aebe22842ec22de2c8b5c545896"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a2c537aebe22842ec22de2c8b5c545896">enclosed_hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classdouble.html">double</a> thickness=1., const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a2c537aebe22842ec22de2c8b5c545896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533c4778cbc9bcbed365dcab42ca4418"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a533c4778cbc9bcbed365dcab42ca4418"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1., const <a class="el" href="classbool.html">bool</a> attach_spherical_manifold_on_boundary_cells=false)</td></tr>
<tr class="separator:a533c4778cbc9bcbed365dcab42ca4418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a07e4609d568267cab4a2f0414cd913"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a1a07e4609d568267cab4a2f0414cd913"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a1a07e4609d568267cab4a2f0414cd913">hyper_ball_balanced</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:a1a07e4609d568267cab4a2f0414cd913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e98b4b3cd47554a365b55d175338be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a7e98b4b3cd47554a365b55d175338be0">non_standard_orientation_mesh</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> rotate_left_square, const <a class="el" href="classbool.html">bool</a> rotate_right_square)</td></tr>
<tr class="separator:a7e98b4b3cd47554a365b55d175338be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7faa3e36d4333d03a3cc865142f3d2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#af7faa3e36d4333d03a3cc865142f3d2f">non_standard_orientation_mesh</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> face_orientation, const <a class="el" href="classbool.html">bool</a> face_flip, const <a class="el" href="classbool.html">bool</a> face_rotation, const <a class="el" href="classbool.html">bool</a> manipulate_left_cube)</td></tr>
<tr class="separator:af7faa3e36d4333d03a3cc865142f3d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dc2f16fc52cf1e51b9afdc4264ac70"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:ab2dc2f16fc52cf1e51b9afdc4264ac70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ab2dc2f16fc52cf1e51b9afdc4264ac70">hyper_sphere</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; spacedim - 1, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:ab2dc2f16fc52cf1e51b9afdc4264ac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712f95340c7002afbd5d6fb755e12a61"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a712f95340c7002afbd5d6fb755e12a61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a712f95340c7002afbd5d6fb755e12a61">quarter_hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:a712f95340c7002afbd5d6fb755e12a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af218d0939daf0732e3b507a27ea5d8e3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:af218d0939daf0732e3b507a27ea5d8e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">half_hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:af218d0939daf0732e3b507a27ea5d8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> radius=1., const <a class="el" href="classdouble.html">double</a> half_length=1.)</td></tr>
<tr class="separator:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f6e6a7ae2fe3a862df035dd2cb4467"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a95f6e6a7ae2fe3a862df035dd2cb4467"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a95f6e6a7ae2fe3a862df035dd2cb4467">subdivided_cylinder</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> x_subdivisions, const <a class="el" href="classdouble.html">double</a> radius=1., const <a class="el" href="classdouble.html">double</a> half_length=1.)</td></tr>
<tr class="separator:a95f6e6a7ae2fe3a862df035dd2cb4467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63c93351f77276c20de07c91d3c1e48"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ae63c93351f77276c20de07c91d3c1e48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ae63c93351f77276c20de07c91d3c1e48">truncated_cone</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> radius_0=1.0, const <a class="el" href="classdouble.html">double</a> radius_1=0.5, const <a class="el" href="classdouble.html">double</a> half_length=1.0)</td></tr>
<tr class="separator:ae63c93351f77276c20de07c91d3c1e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a04f98a456ca1942a071d3a20ef5b4dbe">hyper_cross</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;sizes, const <a class="el" href="classbool.html">bool</a> colorize_cells=false)</td></tr>
<tr class="memdesc:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A center cell with stacks of cell protruding from each surface.  <a href="#a04f98a456ca1942a071d3a20ef5b4dbe">More...</a><br /></td></tr>
<tr class="separator:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2a4ad8296c2b72a11d23b5969e8cc0"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a3b2a4ad8296c2b72a11d23b5969e8cc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a3b2a4ad8296c2b72a11d23b5969e8cc0">hyper_L</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=-1., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a3b2a4ad8296c2b72a11d23b5969e8cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab74ba287a243b478588be824ad65ba6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aab74ba287a243b478588be824ad65ba6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aab74ba287a243b478588be824ad65ba6">subdivided_hyper_L</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;repetitions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;bottom_left, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;top_right, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;n_cells_to_remove)</td></tr>
<tr class="separator:aab74ba287a243b478588be824ad65ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114625911496e4f51758fe00562a14a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5114625911496e4f51758fe00562a14a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a5114625911496e4f51758fe00562a14a">hyper_cube_slit</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a5114625911496e4f51758fe00562a14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85de345ccd86a53e63746709c8e1dfc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad85de345ccd86a53e63746709c8e1dfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells=0, <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:ad85de345ccd86a53e63746709c8e1dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f3256a8eccaaa366a9cca918a585ed"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a54f3256a8eccaaa366a9cca918a585ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a54f3256a8eccaaa366a9cca918a585ed">eccentric_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;inner_center, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;outer_center, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells)</td></tr>
<tr class="separator:a54f3256a8eccaaa366a9cca918a585ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a6f31aa1d176dd99c2183efdb4b9cb5f5">half_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells=0, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#acd7c51b0e8032db65db9a5ff73ccca50">quarter_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells=0, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a760789a93b1e0fe7f5c2675c31b6f14f">cylinder_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> length, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_radial_cells=0, const unsigned <a class="el" href="classint.html">int</a> n_axial_cells=0)</td></tr>
<tr class="separator:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e99c2ee8ac3332b50baa028b7ded526"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7e99c2ee8ac3332b50baa028b7ded526"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a7e99c2ee8ac3332b50baa028b7ded526">torus</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> R, const <a class="el" href="classdouble.html">double</a> r, const unsigned <a class="el" href="classint.html">int</a> n_cells_toroidal=6, const <a class="el" href="classdouble.html">double</a> phi=2.0 *<a class="el" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>)</td></tr>
<tr class="separator:a7e99c2ee8ac3332b50baa028b7ded526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add14cab546d033c1eaacc9234c64ebcd"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:add14cab546d033c1eaacc9234c64ebcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">hyper_cube_with_cylindrical_hole</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, const <a class="el" href="classdouble.html">double</a> inner_radius=.25, const <a class="el" href="classdouble.html">double</a> outer_radius=.5, const <a class="el" href="classdouble.html">double</a> L=.5, const unsigned <a class="el" href="classint.html">int</a> repetitions=1, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:add14cab546d033c1eaacc9234c64ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcc142a9fc905a1abec9315693a57d4"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:abfcc142a9fc905a1abec9315693a57d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#abfcc142a9fc905a1abec9315693a57d4">concentric_hyper_shells</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classdouble.html">double</a> inner_radius=0.125, const <a class="el" href="classdouble.html">double</a> outer_radius=0.25, const unsigned <a class="el" href="classint.html">int</a> n_shells=1, const <a class="el" href="classdouble.html">double</a> skewness=0.1, const unsigned <a class="el" href="classint.html">int</a> n_cells_per_shell=0, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:abfcc142a9fc905a1abec9315693a57d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626225354aa3f249f64dc67319e34bf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a626225354aa3f249f64dc67319e34bf8">moebius</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> n_cells, const unsigned <a class="el" href="classint.html">int</a> n_rotations, const <a class="el" href="classdouble.html">double</a> R, const <a class="el" href="classdouble.html">double</a> r)</td></tr>
<tr class="separator:a626225354aa3f249f64dc67319e34bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6c4dcc63863449f08a78a22ec73747"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1e6c4dcc63863449f08a78a22ec73747"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">generate_from_name_and_arguments</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::string &amp;grid_generator_function_name, const std::string &amp;grid_generator_function_arguments)</td></tr>
<tr class="separator:a1e6c4dcc63863449f08a78a22ec73747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creating meshes from other meshes</div></td></tr>
<tr class="memitem:a7cd88e7eacd46697dee80ad2b8438d54"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7cd88e7eacd46697dee80ad2b8438d54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">merge_triangulations</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_2, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result, const <a class="el" href="classdouble.html">double</a> duplicated_vertex_tolerance=1.0e-12, const bool copy_manifold_ids=false)</td></tr>
<tr class="separator:a7cd88e7eacd46697dee80ad2b8438d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860c7b922eaac094ca4acd506c60ad6f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a860c7b922eaac094ca4acd506c60ad6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a860c7b922eaac094ca4acd506c60ad6f">merge_triangulations</a> (const std::vector&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&gt; &amp;triangulations, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result, const <a class="el" href="classdouble.html">double</a> duplicated_vertex_tolerance=1.0e-12, const bool copy_manifold_ids=false)</td></tr>
<tr class="separator:a860c7b922eaac094ca4acd506c60ad6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cde6da3b561768a26f6c531cc93c48"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a31cde6da3b561768a26f6c531cc93c48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a31cde6da3b561768a26f6c531cc93c48">replicate_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;input, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;extents, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="memdesc:a31cde6da3b561768a26f6c531cc93c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate a given triangulation in multiple coordinate axes.  <a href="#a31cde6da3b561768a26f6c531cc93c48">More...</a><br /></td></tr>
<tr class="separator:a31cde6da3b561768a26f6c531cc93c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843fe2c5c77374c51fcd18f05690b902"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a843fe2c5c77374c51fcd18f05690b902"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a843fe2c5c77374c51fcd18f05690b902">create_union_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_2, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="separator:a843fe2c5c77374c51fcd18f05690b902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada140ece81bf38a23e738e0e57f89e97"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ada140ece81bf38a23e738e0e57f89e97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ada140ece81bf38a23e738e0e57f89e97">create_triangulation_with_removed_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;input_triangulation, const std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;cells_to_remove, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="separator:ada140ece81bf38a23e738e0e57f89e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc0ff3b4e5226c3e06a4aa6ac79f90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const unsigned <a class="el" href="classint.html">int</a> n_slices, const <a class="el" href="classdouble.html">double</a> height, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;result, const <a class="el" href="classbool.html">bool</a> copy_manifold_ids=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_priorities={})</td></tr>
<tr class="separator:a6cc0ff3b4e5226c3e06a4aa6ac79f90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c5b7ad43c366f2dcb559782457efda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a15c5b7ad43c366f2dcb559782457efda">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const unsigned <a class="el" href="classint.html">int</a> n_slices, const <a class="el" href="classdouble.html">double</a> height, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;result, const <a class="el" href="classbool.html">bool</a> copy_manifold_ids=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_priorities={})</td></tr>
<tr class="separator:a15c5b7ad43c366f2dcb559782457efda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ce3fd3bac556d634d62d785452f8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a8a9ce3fd3bac556d634d62d785452f8c">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;slice_coordinates, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;result, const <a class="el" href="classbool.html">bool</a> copy_manifold_ids=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_priorities={})</td></tr>
<tr class="separator:a8a9ce3fd3bac556d634d62d785452f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc920b19e79502facbffa861528b71d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#acc920b19e79502facbffa861528b71d4">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;slice_coordinates, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;result, const <a class="el" href="classbool.html">bool</a> copy_manifold_ids=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_priorities={})</td></tr>
<tr class="separator:acc920b19e79502facbffa861528b71d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe86bf1a4502131ec811a6de41ab41e9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim1, int spacedim2&gt; </td></tr>
<tr class="memitem:afe86bf1a4502131ec811a6de41ab41e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">flatten_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim1 &gt; &amp;in_tria, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim2 &gt; &amp;out_tria)</td></tr>
<tr class="separator:afe86bf1a4502131ec811a6de41ab41e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7515d2b17c025dddc0e37286fb8d216"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac7515d2b17c025dddc0e37286fb8d216"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ac7515d2b17c025dddc0e37286fb8d216">convert_hypercube_to_simplex_mesh</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;in_tria, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;out_tria)</td></tr>
<tr class="separator:ac7515d2b17c025dddc0e37286fb8d216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c9d0d7ff5858b45531b626c3a94c2e"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a01c9d0d7ff5858b45531b626c3a94c2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a01c9d0d7ff5858b45531b626c3a94c2e">convert_hypercube_to_simplex_mesh</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;in_tria, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;out_tria)</td></tr>
<tr class="separator:a01c9d0d7ff5858b45531b626c3a94c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f07aec3ce0611f459d2f692ade0c17"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga88f07aec3ce0611f459d2f692ade0c17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__simplex.html#ga88f07aec3ce0611f459d2f692ade0c17">subdivided_hyper_rectangle_with_simplices</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;repetitions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:ga88f07aec3ce0611f459d2f692ade0c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00002873580ef3b74d81c5ed4250bfbc"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga00002873580ef3b74d81c5ed4250bfbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__simplex.html#ga00002873580ef3b74d81c5ed4250bfbc">subdivided_hyper_cube_with_simplices</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> repetitions, const <a class="el" href="classdouble.html">double</a> p1=0.0, const <a class="el" href="classdouble.html">double</a> p2=1.0, const <a class="el" href="classbool.html">bool</a> colorize=false)</td></tr>
<tr class="separator:ga00002873580ef3b74d81c5ed4250bfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creating lower-dimensional meshes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Created from parts of higher-dimensional meshes. </p>
</div></td></tr>
<tr class="memitem:a8f1570ce89e692943efa1bef1d4d4446"><td class="memTemplParams" colspan="2">template&lt;template&lt; int, int &gt; class MeshType, int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8f1570ce89e692943efa1bef1d4d4446"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a8f1570ce89e692943efa1bef1d4d4446">extract_boundary_mesh</a> (const MeshType&lt; dim, spacedim &gt; &amp;volume_mesh, MeshType&lt; dim - 1, spacedim &gt; &amp;surface_mesh, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a8f1570ce89e692943efa1bef1d4d4446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exceptions</div></td></tr>
<tr class="memitem:ad7b4805db66d34e56837dfef047f7fe0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ad7b4805db66d34e56837dfef047f7fe0">DeclException0</a> (ExcInvalidRadii)</td></tr>
<tr class="separator:ad7b4805db66d34e56837dfef047f7fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2334f33e83f0937aa82a9522d03b1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aeb2334f33e83f0937aa82a9522d03b1b">DeclException1</a> (ExcInvalidRepetitions, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of repetitions &quot;&lt;&lt; arg1&lt;&lt; &quot; must be &gt;=1.&quot;)</td></tr>
<tr class="separator:aeb2334f33e83f0937aa82a9522d03b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764d32da2c6ffefa0759861a295395df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a764d32da2c6ffefa0759861a295395df">DeclException1</a> (ExcInvalidRepetitionsDimension, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The vector of repetitions  must have &quot;&lt;&lt; arg1&lt;&lt; &quot; elements.&quot;)</td></tr>
<tr class="separator:a764d32da2c6ffefa0759861a295395df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f83e890d6e88b3dac100d994ac53217"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a9f83e890d6e88b3dac100d994ac53217">DeclExceptionMsg</a> (ExcInvalidInputOrientation, &quot;The input to this function is oriented in a way that will&quot; &quot; cause all cells to have negative measure.&quot;)</td></tr>
<tr class="separator:a9f83e890d6e88b3dac100d994ac53217"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides a collection of functions for generating triangulations for some basic geometries.</p>
<p>Some of these functions receive a flag <code>colorize</code> (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>). If this is set, parts of the boundary receive different <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">boundary indicators</a> allowing them to be distinguished for the purpose of evaluating different boundary conditions.</p>
<p>If the domain is curved, each of the domain parts that should be refined by following an appropriate <a class="el" href="classManifold.html">Manifold</a> description will receive a different <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">manifold indicator</a>, and the correct <a class="el" href="classManifold.html">Manifold</a> descriptor will be attached to the <a class="el" href="classTriangulation.html">Triangulation</a>. Notice that if you later transform the triangulation, you have to make sure you attach the correct new <a class="el" href="classManifold.html">Manifold</a> to the triangulation. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acea0cbcd68e52ce8113d1134b87de403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea0cbcd68e52ce8113d1134b87de403">&#9670;&nbsp;</a></span>hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation with a hypercube (line in 1D, square in 2D, etc) consisting of exactly one cell. The hypercube volume is the tensor product interval \([left,right]^{\text{dim}}\) in the present number of dimensions, where the limits are given as arguments. They default to zero and unity, then producing the unit hypercube.</p>
<p>If the argument <code>colorize</code> is false, then all boundary indicators are set to zero (the default boundary indicator) for 2d and 3d. If it is true, the boundary is <a class="el" href="DEALGlossary.html#GlossColorization">colorized</a> as in <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>. In 1d the indicators are always colorized, see <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<div class="image">
<img src="hyper_cubes.png" alt="hyper_cubes.png"/>
</div>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero. For example, a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> will be a square in the xy plane with z=0.</p>
<p>See also <a class="el" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">subdivided_hyper_cube()</a> for a coarse mesh consisting of several cells. See <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>, if different lengths in different ordinate directions are required.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a7a1a8bdb6ff5ca4d25a7f709c543b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1a8bdb6ff5ca4d25a7f709c543b798">&#9670;&nbsp;</a></span>simplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::simplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a \(d\)-<a href="https://en.wikipedia.org/wiki/Simplex">simplex</a> (i.e., a triangle in 2d, or a tetrahedron in 3d) with \(d+1\) corners. Since deal.II does not support triangular and tetrahedral cells, the simplex described by the input arguments is subdivided into quadrilaterals and hexahedra by adding edge, face, and simplex midpoints, resulting in a mesh that consists of \(d+1\) quadrilateral or hexahedral cells.</p>
<p>The <code>vertices</code> argument contains a vector with all d+1 vertices defining the corners of the simplex. They must be given in an order such that the vectors from the first vertex to each of the others form a right-handed system.</p>
<p>The meshes generated in two and three dimensions are:</p>
<div class="image">
<img src="simplex_2d.png" alt="simplex_2d.png"/>
</div>
 <div class="image">
<img src="simplex_3d.png" alt="simplex_3d.png"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be created. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">vertices</td><td>The dim+1 corners of the simplex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,2&gt;</code>, <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;3,3&gt;</code>. </dd></dl>

</div>
</div>
<a id="aeb9a83e353f8d69ce49ebdd191a3a51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9a83e353f8d69ce49ebdd191a3a51f">&#9670;&nbsp;</a></span>reference_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::reference_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;&#160;</td>
          <td class="paramname"><em>reference_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a358d5bd545bc115c8645d93fa79b64bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358d5bd545bc115c8645d93fa79b64bc">&#9670;&nbsp;</a></span>subdivided_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube()</a>, but with the difference that not only one cell is created but each coordinate direction is subdivided into <code>repetitions</code> cells. Thus, the number of cells filling the given volume is <code>repetitions<sup>dim</sup></code>.</p>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero. For example, a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> will be a square in the xy plane with z=0.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to create. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">repetitions</td><td>An unsigned integer denoting the number of cells to generate in each direction.</td></tr>
    <tr><td class="paramname">left</td><td>Lower bound for the interval used to create the hyper cube.</td></tr>
    <tr><td class="paramname">right</td><td>Upper bound for the interval used to create the hyper cube.</td></tr>
    <tr><td class="paramname">colorize</td><td>Assign different boundary ids if set to true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56019d263ae45708302d5d7599f0d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56019d263ae45708302d5d7599f0d458">&#9670;&nbsp;</a></span>hyper_rectangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coordinate-parallel brick from the two diagonally opposite corner points <code>p1</code> and <code>p2</code>.</p>
<p>If the <code>colorize</code> flag is <code>true</code>, then the <code>boundary_ids</code> of the boundary faces are assigned, such that the lower one in <code>x-direction</code> is 0, the upper one is 1. The indicators for the surfaces in <code>y-direction</code> are 2 and 3, the ones for <code>z</code> are 4 and 5. This corresponds to the numbers of faces of the unit square of cube as laid out in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class; see also <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>. Importantly, however, in 3d <a class="el" href="DEALGlossary.html#GlossColorization">colorization</a> does not set <code>boundary_ids</code> of <em>edges</em>, but only of <em>faces</em>, because each boundary edge is shared between two faces and it is not clear how the boundary id of an edge should be set in that case.</p>
<p>Additionally, if <code>colorize</code> is <code>true</code>, material ids are assigned to the cells according to the octant their center is in: being in the right half space for any coordinate direction <em>x<sub>i</sub></em> adds 2<sup>i</sup>. For instance, a cell with center point (1,-1,1) yields a material id 5, assuming that the center of the hyper rectangle lies at the origin. No manifold id is set for the cells.</p>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero. For example, a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> will be a rectangle in the xy plane with z=0, defined by the two opposing corners <code>p1</code> and <code>p2</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="ac76417d7404b75cf53c732f456e6e971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76417d7404b75cf53c732f456e6e971">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coordinate-parallel brick from the two diagonally opposite corner points <code>p1</code> and <code>p2</code>. The number of cells in coordinate direction <code>i</code> is given by the integer <code>repetitions[i]</code>.</p>
<p>To get cells with an aspect ratio different from that of the domain, use different numbers of subdivisions, given by <code>repetitions</code>, in different coordinate directions. The minimum number of subdivisions in each direction is 1.</p>
<p>If the <code>colorize</code> flag is <code>true</code>, then the <code>boundary_ids</code> of the surfaces are assigned, such that the lower one in <code>x-direction</code> is 0, the upper one is 1 (the left and the right vertical face). The indicators for the surfaces in <code>y-direction</code> are 2 and 3, the ones for <code>z</code> are 4 and 5. Additionally, material ids are assigned to the cells according to the octant their center is in: being in the right half plane for any coordinate direction <em>x<sub>i</sub></em> adds 2<sup>i</sup> (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>). For instance, the center point (1,-1,1) yields a material id 5 (this means that in 2d only material ids 0,1,2,3 are assigned independent from the number of repetitions).</p>
<p>Note that the <code>colorize</code> flag is ignored in 1d and is assumed to always be true. That means the boundary indicator is 0 on the left and 1 on the right. See step-15 for details.</p>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero. For example, a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> will be a rectangle in the xy plane with z=0, defined by the two opposing corners <code>p1</code> and <code>p2</code>.</p>
<dl class="section note"><dt>Note</dt><dd>For an example of the use of this function see the step-28 tutorial program.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be created. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">repetitions</td><td>A vector of <code>dim</code> positive values denoting the number of cells to generate in that direction.</td></tr>
    <tr><td class="paramname">p1</td><td>First corner point.</td></tr>
    <tr><td class="paramname">p2</td><td>Second corner opposite to <code>p1</code>.</td></tr>
    <tr><td class="paramname">colorize</td><td>Assign different boundary ids if set to true. The same comments apply as for the <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a> function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af215d99be737f1c91f166669e783449e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af215d99be737f1c91f166669e783449e">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>step_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function. However, here the second argument does not denote the number of subdivisions in each coordinate direction, but a sequence of step sizes for each coordinate direction. The domain will therefore be subdivided into <code>step_sizes[i].size()</code> cells in coordinate direction <code>i</code>, with width <code>step_sizes[i][j]</code> for the <code>j</code>th cell.</p>
<p>This function is therefore the right one to generate graded meshes where cells are concentrated in certain areas, rather than a uniformly subdivided mesh as the previous function generates.</p>
<p>The step sizes have to add up to the dimensions of the hyper rectangle specified by the points <code>p1</code> and <code>p2</code>. </p>

</div>
</div>
<a id="a19141a2f24b10ce86f7f90d1661e2ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19141a2f24b10ce86f7f90d1661e2ced">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; dim, <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but with the following twist: the <code>material_id</code> argument is a dim-dimensional array that, for each cell, indicates which material_id should be set. In addition, and this is the major new functionality, if the material_id of a cell is <code>(unsigned char)(-1)</code>, then that cell is deleted from the triangulation, i.e. the domain will have a void there.</p>
<dl class="section note"><dt>Note</dt><dd>If you need a lot of holes, you may consider <a class="el" href="namespaceGridGenerator.html#a76c54698f4666a44ac3982ee62f87ee9" title="Rectangular domain with rectangular pattern of holes. ">cheese()</a>. </dd></dl>

</div>
</div>
<a id="a76c54698f4666a44ac3982ee62f87ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c54698f4666a44ac3982ee62f87ee9">&#9670;&nbsp;</a></span>cheese()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cheese </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>holes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rectangular domain with rectangular pattern of holes. </p>
<p>The domain itself is rectangular, very much as if it had been generated by <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">subdivided_hyper_rectangle()</a>. The argument <code>holes</code> specifies how many square holes the domain should have in each coordinate direction. The total number of mesh cells in that direction is then twice this number plus one.</p>
<p>The number of holes in one direction must be at least one.</p>
<p>An example with two by three holes is</p>
<div class="image">
<img src="cheese_2d.png" alt="cheese_2d.png"/>
</div>
<p>If <code>dim</code> &lt; <code>spacedim</code>, this will create a <code>dim</code> dimensional object in the first <code>dim</code> coordinate directions embedded into the <code>spacedim</code> dimensional space with the remaining entries set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be created. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">holes</td><td>Positive number of holes in each of the dim directions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cef2def7a0b1ce88eef4ec630b1e3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cef2def7a0b1ce88eef4ec630b1e3b8">&#9670;&nbsp;</a></span>plate_with_a_hole()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::plate_with_a_hole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em> = <code>0.4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>pad_bottom</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>pad_top</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>pad_left</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>pad_right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>polar_manifold_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>tfi_manifold_id</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>L</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_slices</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rectangular plate with an (offset) cylindrical hole. </p>
<p>Generate a rectangular plate with an (offset) cylindrical hole. The geometry consists of 2 regions: The first is a square region with length <code>outer_radius</code> and a hole of radius <code>inner_radius</code> . Cells in this region will have <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> with manifold id <code>tfi_manifold_id</code> attached to them. Additionally, the boundary faces of the hole will be associated with a <a class="el" href="classPolarManifold.html">PolarManifold</a> (in 2D) or <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> (in 3D). The center of this region can be prescribed via <code>center</code> , namely the axis of the hole will be located at <code>center</code> . The second region describes the remainder of the bulk material. It is specified via padding parameters <code>pad_bottom</code>, <code>padding_top</code>, <code>padding_left</code> and <code>padding_right</code>. All cells in this region will have a <a class="el" href="classFlatManifold.html">FlatManifold</a> attached to them. The final width of the plate will be <code>padding_left + 2*outer_radius + padding_right</code>, while its length is <code>padding_top + 2*outer_radius + padding_bottom</code>.</p>
<p>Here is the non-symmetric grid (after one global refinement, colored according to manifold id) in 2D and 3D, respectively:</p>
<p> <style>div.image
img[src="plate_with_a_hole.png"]{width:25%;}</style>  </p><div class="image">
<img src="plate_with_a_hole.png" alt="plate_with_a_hole.png"/>
</div>
<p>  <style>div.image
img[src="plate_with_a_hole_3D.png"]{width:25%;}</style>  </p><div class="image">
<img src="plate_with_a_hole_3D.png" alt="plate_with_a_hole_3D.png"/>
</div>
<p>In 3D, triangulation will be extruded in the z-direction by the total height of <code>L</code> using <code>n_slices</code> slices (minimum is 2).</p>
<p>If the <code>colorize</code> flag is <code>true</code>, the boundary_ids of the boundary faces are assigned such that the lower one in the x-direction is 0, and the upper one is 1 (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>). The indicators for the surfaces in the y-direction are 2 and 3, and the ones for the z-direction are 5 and 6. The hole boundary has indicator 4.</p>
<p><code>tria</code> is the triangulation to be created. It needs to be empty upon calling this function. </p>

</div>
</div>
<a id="a9d0b8a34fe5ca58425aa1fcf0d6132f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0b8a34fe5ca58425aa1fcf0d6132f1">&#9670;&nbsp;</a></span>channel_with_cylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::channel_with_cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>shell_region_width</em> = <code>0.03</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_shells</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>skewness</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a grid consisting of a channel with a cylinder. This is a common benchmark for Navier-Stokes solvers. The geometry consists of a channel of size \([0, 2.2] \times [0, 0.41] \times [0, 0.41] \) (where the \(z\) dimension is omitted in 2D) with a cylinder, parallel to the \(z\) axis with diameter \(0.1\), centered at \((0.2, 0.2, 0)\). The channel has three distinct regions: </p><ol>
<li>
If <code>n_shells</code> is greater than zero, then there are that many shells centered around the cylinder, </li>
<li>
a blending region between the shells and the rest of the triangulation, and </li>
<li>
a bulk region consisting of Cartesian cells. </li>
</ol>
<p>Since the cylinder is slightly offset from the center of the channel, this geometry results in vortex shedding at moderate Reynolds numbers. Here is the grid (without additional global refinement) in 2D:</p>
<div class="image">
<img src="channel_with_cylinder_2d.png" alt="channel_with_cylinder_2d.png"/>
</div>
<p>and in 3D:</p>
<div class="image">
<img src="channel_with_cylinder_3d.png" alt="channel_with_cylinder_3d.png"/>
</div>
<p>The resulting <a class="el" href="classTriangulation.html">Triangulation</a> uses three manifolds: a <a class="el" href="classPolarManifold.html">PolarManifold</a> (in 2D) or <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> (in 3D) with manifold id \(0\), a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> with manifold id \(1\), and a <a class="el" href="classFlatManifold.html">FlatManifold</a> everywhere else. For more information on this topic see <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">the glossary entry on manifold indicators</a>. The cell faces on the cylinder and surrounding shells have manifold ids of \(0\), while the cell volumes adjacent to the shells (or, if they do not exist, the cylinder) have a manifold id of \(1\). Put another way: this grid uses <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to smoothly transition from the shells (generated with <a class="el" href="namespaceGridGenerator.html#abfcc142a9fc905a1abec9315693a57d4">GridGenerator::concentric_hyper_shells</a>) to the bulk region. All other cell volumes and faces have manifold id <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> and use <a class="el" href="classFlatManifold.html">FlatManifold</a>. All cells with id <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> are rectangular prisms aligned with the coordinate axes.</p>
<p>The picture below shows part of the 2D grid (using all default arguments to this function) after two global refinements. The cells with manifold id \(0\) are orange (the polar manifold id), cells with manifold id \(1\) are yellow (the transfinite interpolation manifold id), and the ones with manifold id <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> are cyan:</p>
<div class="image">
<img src="channel_with_cylinder_2d_manifolds.png" alt="channel_with_cylinder_2d_manifolds.png"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td><a class="el" href="classTriangulation.html">Triangulation</a> to be created. Must be empty upon calling this function.</td></tr>
    <tr><td class="paramname">shell_region_width</td><td>Width of the layer of shells around the cylinder. This value should be between \(0\) and \(0.05\); the default value is \(0.03\).</td></tr>
    <tr><td class="paramname">n_shells</td><td>Number of shells to use in the shell layer.</td></tr>
    <tr><td class="paramname">skewness</td><td>Parameter controlling how close the shells are to the cylinder: see the mathematical definition given in <a class="el" href="namespaceGridGenerator.html#abfcc142a9fc905a1abec9315693a57d4">GridGenerator::concentric_hyper_shells</a>.</td></tr>
    <tr><td class="paramname">colorize</td><td>Assign different boundary ids if set to true. For more information on boundary indicators see <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">this glossary entry</a>. The left boundary (at \(x = 0\)) is assigned an id of \(0\), the right boundary (at \(x = 2.2\)) is assigned an id of \(1\), the cylinder boundary is assigned an id of \(2\), and the channel walls are assigned an id of \(3\).</td></tr>
  </table>
  </dd>
</dl>
<p>See the original paper for more information: </p><div class="fragment"><div class="line">@inbook{schafer1996,</div><div class="line">author    = {Sch{\&quot;a}fer, M. and Turek, S. and Durst, F. and Krause, E.</div><div class="line">             and Rannacher, R.},</div><div class="line">title     = {Benchmark Computations of Laminar Flow Around a Cylinder},</div><div class="line">bookTitle = {Flow Simulation with High-Performance Computers II: DFG</div><div class="line">             Priority Research Programme Results 1993--1995},</div><div class="line">year      = {1996},</div><div class="line">publisher = {Vieweg+Teubner Verlag},</div><div class="line">address   = {Wiesbaden},</div><div class="line">pages     = {547--566},</div><div class="line">isbn      = {978-3-322-89849-4},</div><div class="line">doi       = {10.1007/978-3-322-89849-4_39},</div><div class="line">url       = {https://doi.org/10.1007/978-3-322-89849-4_39}</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a22a8e0666bdbfa278179377c47536b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a8e0666bdbfa278179377c47536b8e">&#9670;&nbsp;</a></span>general_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::general_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A general <code>dim</code> -dimensional cell (a segment if dim is 1, a quadrilateral if <code>dim</code> is 2, or a hexahedron if <code>dim</code> is 3) immersed in a <code>spacedim</code> -dimensional space. It is the responsibility of the user to provide the vertices in the right order (see the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class) because the vertices are stored in the same order as they are given. It is also important to make sure that the volume of the cell is positive.</p>
<p>If the argument <code>colorize</code> is false, then all boundary indicators are set to zero for 2d and 3d. If it is true, the boundary is colorized as in <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a> (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>). In 1d the indicators are always colorized, see <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation that will be created </td></tr>
    <tr><td class="paramname">vertices</td><td>The 2^dim vertices of the cell </td></tr>
    <tr><td class="paramname">colorize</td><td>If true, set different boundary ids. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a324b8447f05b148e2f58bdbcf89f5325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324b8447f05b148e2f58bdbcf89f5325">&#9670;&nbsp;</a></span>parallelogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::parallelogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A parallelogram. The first corner point is the origin. The next <code>dim</code> vertices are the ones given in the second argument and the last vertex will be the sum of the two vectors connecting the origin to those points. Colorizing is done in the same way as in <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is implemented in 2d only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be created. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">corners</td><td>Second and third vertices of the parallelogram.</td></tr>
    <tr><td class="paramname">colorize</td><td>Assign different boundary ids if true. (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a016c6b55bcadf6596001a1e232a8faad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016c6b55bcadf6596001a1e232a8faad">&#9670;&nbsp;</a></span>parallelepiped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A parallelepiped. The first corner point is the origin. The <code>dim</code> adjacent points are vectors describing the edges of the parallelepiped with respect to the origin. Additional points are sums of these dim vectors. Colorizing is done according to <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function silently reorders the vertices on the cells to lexicographic ordering (see <code>GridReordering::reorder_grid</code>). In other words, if reordering of the vertices does occur, the ordering of vertices in the array of <code>corners</code> will no longer refer to the same triangulation.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a91269092ac149bdc6df9baabad785d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91269092ac149bdc6df9baabad785d02">&#9670;&nbsp;</a></span>subdivided_parallelepiped() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A subdivided parallelepiped. The first corner point is the origin. The <code>dim</code> adjacent points are vectors describing the edges of the parallelepiped with respect to the origin. Additional points are sums of these dim vectors. The variable <code>n_subdivisions</code> designates the number of subdivisions in each of the <code>dim</code> directions. Colorizing is done according to <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a3e16fb3b8412754508c3b574f3ccfdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e16fb3b8412754508c3b574f3ccfdbc">&#9670;&nbsp;</a></span>subdivided_parallelepiped() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>(&amp;)&#160;</td>
          <td class="paramname"><em>n_subdivisions</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A subdivided parallelepiped, i.e., the same as above, but where the number of subdivisions in each of the <code>dim</code> directions may vary. Colorizing is done according to <a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="aa93a16355ace7092f5160b44cfeac767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93a16355ace7092f5160b44cfeac767">&#9670;&nbsp;</a></span>subdivided_parallelepiped() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdivisions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A subdivided parallelepiped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be created. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">origin</td><td>First corner of the parallelepiped.</td></tr>
    <tr><td class="paramname">edges</td><td>An array of <code>dim</code> tensors describing the length and direction of the edges from <code>origin</code>.</td></tr>
    <tr><td class="paramname">subdivisions</td><td>Number of subdivisions in each of the dim directions. Each entry must be positive. An empty vector is equivalent to one subdivision in each direction.</td></tr>
    <tr><td class="paramname">colorize</td><td>Assign different boundary ids if set to true (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for all combinations of <code>dim</code> and <code>spacedim</code>.</dd>
<dd>
You likely need to help the compiler by explicitly specifying the two template parameters when calling this function. </dd></dl>

</div>
</div>
<a id="a2c537aebe22842ec22de2c8b5c545896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c537aebe22842ec22de2c8b5c545896">&#9670;&nbsp;</a></span>enclosed_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::enclosed_hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>thickness</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hypercube with a layer of hypercubes around it. Parameters <code>left</code> and <code>right</code> give the lower and upper bound of the inner hypercube in all coordinate directions. <code>thickness</code> marks the size of the layer cells.</p>
<p>If the flag <code>colorize</code> is set, the outer cells get material ids according to the following scheme: extending over the inner cube in (+/-) x-direction 1/2, y-direction 4/8, z-direction 16/32. A bitwise OR operation is used to get these values at the corners and edges (3d), (see also <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>).</p>
<p>Presently only available in 2d and 3d.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a533c4778cbc9bcbed365dcab42ca4418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533c4778cbc9bcbed365dcab42ca4418">&#9670;&nbsp;</a></span>hyper_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>attach_spherical_manifold_on_boundary_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation with several <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh cells</a> that cover a hyperball, i.e. a circle in 2d or a ball in 3d, around <code>center</code> with given <code>radius</code>. The function is used in step-6.</p>
<p>In order to avoid degenerate cells at the boundaries, the circle is triangulated by five cells, whereas in 3d the ball is subdivided by seven cells. Specifically, these cells are one cell in the center plus one "cap" cell on each of the faces of this center cell. This ensures that under repeated refinement, none of the cells at the outer boundary will degenerate to have an interior angle approaching 180 degrees, as opposed to the case where one might start with just one square (or cube) to approximate the domain. The diameter of the center cell is chosen so that the aspect ratio of the boundary cells after one refinement is optimized.</p>
<p>This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</p>
<p>By default, the manifold_id is set to 0 on the boundary faces, 1 on the boundary cells, and <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> on the central cell and on internal faces.</p>
<p>A <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached by default to the boundary faces for correct placement of boundary vertices upon refinement and to be able to use higher order mappings. However, it turns out that this strategy may not be the optimal one to create a good a mesh for a hyperball. The "Possibilities for extensions" section of step-6 has an extensive discussion of how one would construct better meshes and what one needs to do for it. Setting the argument <code>attach_spherical_manifold_on_boundary_cells</code> to true attaches a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> manifold also to the cells adjacent to the boundary, and not only to the boundary faces.</p>
<dl class="section note"><dt>Note</dt><dd>Since this is likely one of the earliest functions users typically consider to create meshes with curved boundaries, let us also comment on one aspect that is often confusing: Namely, that what one sees is not always what is actually happening. Specifically, if you output the coarse mesh with a function such as <a class="el" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">GridOut::write_vtk()</a> using default options, then one doesn't generally get to see curved faces at the boundary. That's because most file formats by default only store vertex locations, with the implicit understanding that cells are composed from these vertices and bounded by straight edges. At the same time, the fact that this function attaches a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> object to the boundary faces means that at least <em>internally</em>, edges really are curved. If you want to see them that way, you need to make sure that the function you use to output the mesh actually plots boundary faces as curved lines rather than straight lines characterized by only the locations of the two end points. For example, <a class="el" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">GridOut::write_gnuplot()</a> can do that if you set the corresponding flag in the <a class="el" href="structGridOutFlags_1_1Gnuplot.html">GridOutFlags::Gnuplot</a> structure. It is, however, an entirely separate consideration whether you are actually <em>computing</em> on curved cells. In typical finite element computations, one has to compute integrals and these are computed by transforming back actual cells using a mapping to the reference cell. What mapping is used determines what shape the cells have for these internal computations: For example, with the widely used \(Q_1\) mapping (implicitly used in step-6), integration always happens on cells that are assumed to have straight boundaries described by only the vertex locations. In other words, if such a mapping is used, then the cells of the domain really do have straight edges, regardless of the manifold description attached to these edges and regardless of the flags given when generating output. As a consequence of all of this, it is important to distinguish three things: (i) the manifold description attached to an object in the mesh; (ii) the mapping used in integration; and (iii) the style used in outputting graphical information about the mesh. All of these can be chosen more or less independently of each other, and what you see visualized is not necessarily exactly what is happening.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a1a07e4609d568267cab4a2f0414cd913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a07e4609d568267cab4a2f0414cd913">&#9670;&nbsp;</a></span>hyper_ball_balanced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_ball_balanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an alternative to hyper_ball with 12 cells in 2d and 32 cells in 3d, which provides a better balance between the size of the cells around the outer curved boundaries and the cell in the interior. The mesh is based on the cells used by <a class="el" href="namespaceGridGenerator.html#a712f95340c7002afbd5d6fb755e12a61">GridGenerator::quarter_hyper_ball()</a> with appropriate copies and rotations to fill the whole ball.</p>
<p>The following pictures show the resulting mesh in 2D (left) and 3D: </p><table align="center" class="doxtable">
<tr>
<td> <style>div.image
        img[src="hyper_ball_balanced_2d.png"]{width:40%}</style>
       <div class="image">
<img src="hyper_ball_balanced_2d.png" alt="hyper_ball_balanced_2d.png"/>
</div>
  </td><td> <style>div.image
        img[src="hyper_ball_balanced_3d.png"]{width:40%}</style>
       <div class="image">
<img src="hyper_ball_balanced_3d.png" alt="hyper_ball_balanced_3d.png"/>
</div>
   </td></tr>
</table>
<p>By default, the manifold_id is set to 0 on the boundary faces, 1 on the boundary cells, and <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> on the central cell and on internal faces.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a7e98b4b3cd47554a365b55d175338be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e98b4b3cd47554a365b55d175338be0">&#9670;&nbsp;</a></span>non_standard_orientation_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::non_standard_orientation_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rotate_left_square</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rotate_right_square</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a 2D mesh consisting of the unit square joined with a copy shifted by \(s = (1,0)\). Depending on the flags passed either the right or the left square is rotated by \(\pi/2\). This way one can generate a mesh in which one square possibly contains an edge that has the opposite tangential (and hence also opposite normal) orientation of the neighboring edge of the other square.</p>
<p>This mesh is not overly useful from a practical point of view. For debugging purposes it can be used to check for orientation issues for vector- or tensor-valued finite elements.</p>
<dl class="section note"><dt>Note</dt><dd>If <code>rotate_left_square==rotate_right_square</code> the mesh is consistently oriented.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tria</td><td>The input triangulation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotate_left_square</td><td><code>true</code> if the left square is rotated by \(\pi/2\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotate_right_square</td><td><code>true</code> if the right square is rotated by \(\pi/2\). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7faa3e36d4333d03a3cc865142f3d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7faa3e36d4333d03a3cc865142f3d2f">&#9670;&nbsp;</a></span>non_standard_orientation_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::non_standard_orientation_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>manipulate_left_cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a 3D mesh consisting of the unit cube joined with a copy shifted by \(s = (1,0,0)\). Depending on the flags passed either the right or the left cube (when looking at the positively oriented (x,z)-plane) contains a face that is either not in standard orientation and/or is rotated by either \(\pi/2\), \(\pi\) or \(3/2\pi\).</p>
<p>This mesh is not overly useful from a practical point of view. For debugging purposes it can be used to check for orientation issues for vector- or tensor-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tria</td><td>The input triangulation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_orientation</td><td><code>true</code> if the face is the not in standard orientation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_flip</td><td><code>true</code> if the face is rotated by +180 degrees </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_rotation</td><td><code>true</code> if the face is rotated (additionally) by +90 degrees </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">manipulate_left_cube</td><td><code>true</code> if the left cube is to be re-ordered. If <code>false</code>, it is the right cube. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2dc2f16fc52cf1e51b9afdc4264ac70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2dc2f16fc52cf1e51b9afdc4264ac70">&#9670;&nbsp;</a></span>hyper_sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_sphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; spacedim - 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;spacedim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a hyper sphere, i.e., a surface of a ball in <code>spacedim</code> dimensions. This function only exists for dim+1=spacedim in 2 and 3 space dimensions. (To create a mesh of a ball, use <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>.)</p>
<p>By default, all manifold ids of the triangulation are set to zero, and a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached to the grid.</p>
<p>The following pictures are generated with: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2,3&gt;</a>   triangulation;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ab2dc2f16fc52cf1e51b9afdc4264ac70">GridGenerator::hyper_sphere</a>(triangulation);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div></div><!-- fragment --><p>See the <a class="el" href="group__manifold.html">documentation module on manifolds</a> for more details.</p>
<div class="image">
<img src="sphere.png" alt="sphere.png"/>
</div>
 <div class="image">
<img src="sphere_section.png" alt="sphere_section.png"/>
</div>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a712f95340c7002afbd5d6fb755e12a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712f95340c7002afbd5d6fb755e12a61">&#9670;&nbsp;</a></span>quarter_hyper_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::quarter_hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function produces a hyper-ball intersected with the positive orthant relative to <code>center</code>, which contains three elements in 2d and four in 3d. The interior points of the mesh are chosen to balance the minimal singular value of the Jacobian of the mapping from reference to real coordinates among the cells around the interior point, which corresponds to a high mesh quality.</p>
<p>The boundary indicators for the final triangulation are 0 for the curved boundary and 1 for the cut plane. The manifold id for the curved boundary is set to zero, and a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached to it.</p>
<p>The resulting grid in 2D and 3D looks as follows: </p><table align="center" class="doxtable">
<tr>
<td> <style>div.image
        img[src="quarter_hyper_ball_2d.png"]{width:50%}</style>
       <div class="image">
<img src="quarter_hyper_ball_2d.png" alt="quarter_hyper_ball_2d.png"/>
</div>
  </td><td> <style>div.image
        img[src="quarter_hyper_ball_3d.png"]{width:46%}</style>
       <div class="image">
<img src="quarter_hyper_ball_3d.png" alt="quarter_hyper_ball_3d.png"/>
</div>
   </td></tr>
</table>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="af218d0939daf0732e3b507a27ea5d8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af218d0939daf0732e3b507a27ea5d8e3">&#9670;&nbsp;</a></span>half_hyper_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::half_hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function produces a half hyper-ball around <code>center</code>, which contains four elements in 2d and 6 in 3d. The cut plane is perpendicular to the <em>x</em>-axis.</p>
<p>The boundary indicators for the final triangulation are 0 for the curved boundary and 1 for the cut plane. The manifold id for the curved boundary is set to zero, and a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached to it.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a5cdda7b4a76d509af7d1a8dc1320ddb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdda7b4a76d509af7d1a8dc1320ddb0">&#9670;&nbsp;</a></span>cylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <code>dim</code> dimensional cylinder where the \(x\)-axis serves as the axis of the cylinder. For the purposes of this function, a cylinder is defined as a (<code>dim</code> - 1) dimensional disk of given <code>radius</code>, extruded along the axis of the cylinder (which is the first coordinate direction). Consequently, in three dimensions, the cylinder extends from <code>x=-half_length</code> to <code>x=+half_length</code> and its projection into the <code>yz-plane</code> is a circle of radius <code>radius</code>. In two dimensions, the cylinder is a rectangle from <code>x=-half_length</code> to <code>x=+half_length</code> and from <code>y=-radius</code> to <code>y=radius</code>.</p>
<p>The boundaries are colored according to the following scheme: 0 for the hull of the cylinder, 1 for the left hand face and 2 for the right hand face (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>).</p>
<p>The manifold id for the hull of the cylinder is set to zero, and a <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> is attached to it.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a95f6e6a7ae2fe3a862df035dd2cb4467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f6e6a7ae2fe3a862df035dd2cb4467">&#9670;&nbsp;</a></span>subdivided_cylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>x_subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <code>dim</code> dimensional cylinder where the \(x\)-axis serves as the axis of the cylinder. For the purposes of this function, a cylinder is defined as a (<code>dim</code> - 1) dimensional disk of given <code>radius</code>, extruded along the axis of the cylinder (which is the first coordinate direction). Consequently, in three dimensions, the cylinder extends from <code>x=-half_length</code> to <code>x=+half_length</code> and its projection into the <code>yz-plane</code> is a circle of radius <code>radius</code>. In two dimensions, the cylinder is a rectangle from <code>x=-half_length</code> to <code>x=+half_length</code> and from <code>y=-radius</code> to <code>y=radius</code>. This function is only implemented for dim==3.</p>
<p>The boundaries are colored according to the following scheme: 0 for the hull of the cylinder, 1 for the left hand face and 2 for the right hand face (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>).</p>
<p>The manifold id for the hull of the cylinder is set to zero, and a <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> is attached to it.</p>
<div class="image">
<img src="subdivided_cylinder_3D.png" alt="subdivided_cylinder_3D.png"/>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be created. It needs to be empty upon calling this function.</td></tr>
    <tr><td class="paramname">x_subdivisions</td><td>A positive integer denoting the number of cells to generate in the x direction. The default cylinder has x_repetitions=2.</td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the circle in the yz-plane used to extrude the cylinder.</td></tr>
    <tr><td class="paramname">half_length</td><td>The half-length of the cylinder in the x direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae63c93351f77276c20de07c91d3c1e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63c93351f77276c20de07c91d3c1e48">&#9670;&nbsp;</a></span>truncated_cone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::truncated_cone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius_0</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius_1</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a cut cone around the x-axis. The cone extends from <code>x=-half_length</code> to <code>x=half_length</code> and its projection into the <code>yz-plane</code> is a circle of radius <code>radius_0</code> at <code>x=-half_length</code> and a circle of radius <code>radius_1</code> at <code>x=+half_length</code>. In between the radius is linearly decreasing.</p>
<p>In two dimensions, the cone is a trapezoid from <code>x=-half_length</code> to <code>x=+half_length</code> and from <code>y=-radius_0</code> to <code>y=radius_0</code> at <code>x=-half_length</code> and from <code>y=-radius_1</code> to <code>y=radius_1</code> at <code>x=+half_length</code>. In between the range of <code>y</code> is linearly decreasing.</p>
<p>The boundaries are colored according to the following scheme: 0 for the hull of the cone, 1 for the left hand face, and 2 for the right hand face (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>). Both the boundary indicators and the manifold indicators are set.</p>
<p>In three dimensions, the manifold id of the hull is set to zero, and a <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> is attached to it.</p>
<p>Here are the grids in 2D and 3D after two mesh refinements:</p>
<div class="image">
<img src="truncated_cone_2d.png" alt="truncated_cone_2d.png"/>
</div>
 <div class="image">
<img src="truncated_cone_3d.png" alt="truncated_cone_3d.png"/>
</div>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a04f98a456ca1942a071d3a20ef5b4dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f98a456ca1942a071d3a20ef5b4dbe">&#9670;&nbsp;</a></span>hyper_cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A center cell with stacks of cell protruding from each surface. </p>
<p>Each of the square mesh cells is Cartesian and has size one in each coordinate direction. The center of cell number zero is the origin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>A <a class="el" href="classTriangulation.html">Triangulation</a> object which has to be empty.</td></tr>
    <tr><td class="paramname">sizes</td><td>A vector of integers of dimension <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">GeometryInfo&lt;dim&gt;::faces_per_cell</a> with the following meaning: the legs of the cross are stacked on the faces of the center cell, in the usual order of deal.II cells, namely first \(-x\), then \(x\), then \(-y\) and so on. The corresponding entries in <code>sizes</code> name the number of cells stacked on this face. All numbers may be zero, thus L- and T-shaped domains are specializations of this domain.</td></tr>
    <tr><td class="paramname">colorize_cells</td><td>If colorization is enabled, then the material id of a cells corresponds to the leg it is in. The id of the center cell is zero, and then the legs are numbered starting at one (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>).</td></tr>
  </table>
  </dd>
</dl>
<p>Examples in two and three dimensions are:</p>
<div class="image">
<img src="hyper_cross_2d.png" alt="hyper_cross_2d.png"/>
</div>
 <div class="image">
<img src="hyper_cross_3d.png" alt="hyper_cross_3d.png"/>
</div>
 
</div>
</div>
<a id="a3b2a4ad8296c2b72a11d23b5969e8cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2a4ad8296c2b72a11d23b5969e8cc0">&#9670;&nbsp;</a></span>hyper_L()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_L </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>-1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation with a hyper-L (in 2d or 3d) consisting of exactly <code>2^dim-1</code> cells. It produces the hypercube with the interval [<em>left,right</em>] without the hypercube made out of the interval [<em>(left+right)/2,right</em>] for each coordinate. Because the domain is about the simplest one with a reentrant (i.e., non-convex) corner, solutions of many partial differential equations have singularities at this corner. That is, at the corner, the gradient or a higher derivative (depending on the boundary conditions chosen) does not remain bounded. As a consequence, this domain is often used to test convergence of schemes when the solution lacks regularity.</p>
<p>If the <code>colorize</code> flag is <code>true</code>, the <code>boundary_ids</code> of the surfaces are assigned such that the left boundary is 0 and the others are assigned counterclockwise in ascending order (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>). The <code>colorize</code> option only works in two dimensions.</p>
<p>This function will create the classical L-shape in 2d and it will look like the following in 3d:</p>
<div class="image">
<img src="hyper_l.png" alt="hyper_l.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>The 3d domain is also often referred to as the "Fichera corner", named after Gaetano Fichera (1922-1996) who first computed an approximation of the corner singularity exponent of the lowest eigenfunction of the domain.</dd></dl>
<p>This function exists for triangulations of all space dimensions, but throws an error if called in 1d.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="aab74ba287a243b478588be824ad65ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab74ba287a243b478588be824ad65ba6">&#9670;&nbsp;</a></span>subdivided_hyper_L()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_L </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>top_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_cells_to_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given triangulation in 2D or 3D with a generalized subdivided hyper-L.</p>
<p>This function produces a subdivided hyper rectangle with dimensions given by <code>bottom_left</code> and <code>top_right</code>, with the given number of subdivisions in each direction given in the vector <code>repetitions</code>, and with a number of cells removed, given in the vector <code>n_cells_to_remove</code>. Note that <code>n_cells_to_remove</code> contains integers, meaning that its entries can be both positive and negative. A positive number denotes cutting away cells in the 'positive' orientation, for example left to right in the x-direction, bottom to top in the y-direction, and front to back in the z-direction. A negative number denotes cutting away cells in the reverse direction, so right to left, top to bottom, and back to front.</p>
<p>A demonstration of this grid can be found in step-75.</p>
<p>This function may be used to generate a mesh for a backward facing step, a useful domain for benchmark problems in fluid dynamics. The first image is a backward facing step in 3D, generated by removing all cells in the z-direction, and 2 cells in the positive x- and y-directions: </p><div class="image">
<img src="subdivided_hyper_L_3d.png" alt="subdivided_hyper_L_3d.png"/>
</div>
<p> And in 2D, we can cut away 1 cell in the negative x-direction, and 2 cells in the negative y-direction: </p><div class="image">
<img src="subdivided_hyper_L_2d.png" alt="subdivided_hyper_L_2d.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1D. </dd></dl>

</div>
</div>
<a id="a5114625911496e4f51758fe00562a14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5114625911496e4f51758fe00562a14a">&#9670;&nbsp;</a></span>hyper_cube_slit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube_slit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the given <a class="el" href="classTriangulation.html">Triangulation</a> with a hypercube with a slit. In each coordinate direction, the hypercube extends from <code>left</code> to <code>right</code>.</p>
<p>In 2d, the split goes in vertical direction from <code>x=(left+right)/2, y=left</code> to the center of the square at <code>x=y=(left+right)/2</code>.</p>
<p>In 3d, the 2d domain is just extended in the <em>z</em>-direction, such that a plane cuts the lower half of a rectangle in two. This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</p>
<p>If <code>colorize</code> is set to <code>true</code>, the faces forming the slit are marked with boundary id 1 and 2, respectively (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="ad85de345ccd86a53e63746709c8e1dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85de345ccd86a53e63746709c8e1dfc">&#9670;&nbsp;</a></span>hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a hyper-shell, the region between two spheres around <code>center</code>, with given <code>inner_radius</code> and <code>outer_radius</code>. The number <code>n_cells</code> indicates the number of cells of the resulting triangulation, i.e., how many cells form the ring (in 2d) or the shell (in 3d).</p>
<p>If the flag <code>colorize</code> is <code>true</code>, then the outer boundary will have the indicator 1 while the inner boundary has id zero. In 3d, this applies to both the faces and the edges of these boundaries. If the flag is <code>false</code>, both have indicator zero (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>).</p>
<p>All manifold ids are set to zero, and a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached to every cell and face of the triangulation.</p>
<p>In 2d, the number <code>n_cells</code> of elements for this initial triangulation can be chosen arbitrarily. If the number of initial cells is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio.</p>
<p>In 3d, only certain numbers are allowed: </p><ul>
<li>
6 (or the default 0) for a surface based on a hexahedron (i.e. 6 panels on the inner sphere extruded in radial direction to form 6 cells), </li>
<li>
12 for the rhombic dodecahedron, </li>
<li>
24 for the hexahedron-based surface refined once in the azimuthal directions but not in the radial direction, </li>
<li>
48 for the rhombic dodecahedron refined once in the azimuthal directions but not in the radial direction, </li>
<li>
96 for the rhombic dodecahedron refined once. This choice dates from an older version of deal.II before the <a class="el" href="classManifold.html">Manifold</a> classes were implemented: today this choce is equivalent to the rhombic dodecahedron after performing one global refinement. </li>
<li>
Numbers of the kind \(192\times 2^m\) with \(m\geq 0\) integer. This choice is similar to the 24 and 48 cell cases, but provides additional refinements in azimuthal direction combined with a single layer in radial direction. The base mesh is either the 6 or 12 cell version, depending on whether \(m\) in the power is odd or even, respectively. </li>
</ul>
<p>The versions with 24, 48, and \(2^m 192\) cells are useful if the shell is thin and the radial lengths should be made more similar to the circumferential lengths.</p>
<p>The 3d grids with 12 and 96 cells are plotted below:</p>
<div class="image">
<img src="hypershell3d-12.png" alt="hypershell3d-12.png"/>
</div>
 <div class="image">
<img src="hypershell3d-96.png" alt="hypershell3d-96.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>This function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a54f3256a8eccaaa366a9cca918a585ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f3256a8eccaaa366a9cca918a585ed">&#9670;&nbsp;</a></span>eccentric_hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::eccentric_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>outer_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce an eccentric hyper-shell, the region between two spheres centered on two distinct center points. One has to specify the <code>inner_center</code> and <code>outer_center</code>, with given <code>inner_radius</code> and <code>outer_radius</code>. The number <code>n_cells</code> indicates the number of cells of the resulting triangulation, i.e., how many cells form the ring (in 2d) or the shell (in 3d).</p>
<p>By default, the outer boundary has the indicator 1 while the inner boundary has id 0. In 3d, this applies to both the faces and the edges of these boundaries.</p>
<p>A <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached to the outer boundary with an id of 1 while another <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached to the inner boundary with an id of 0. A <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> is attached to all other cells and faces of the triangulation with an id of 2.</p>
<p>Here, the number <code>n_cells</code> of elements has the same meaning as in <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>.</p>
<p>The grids with a 30% offset of the inner shell in the x direction, 12 initial cells and 3 levels of global refinement are plotted below:</p>
<div class="image">
<img src="eccentric_hyper_shell_2D.png" alt="eccentric_hyper_shell_2D.png"/>
</div>
 <div class="image">
<img src="eccentric_hyper_shell_3D.png" alt="eccentric_hyper_shell_3D.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>Because it uses the definition of the hyper shell, this function is declared to exist for triangulations of all space dimensions, but throws an error if called in 1d.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a6f31aa1d176dd99c2183efdb4b9cb5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f31aa1d176dd99c2183efdb4b9cb5f5">&#9670;&nbsp;</a></span>half_hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::half_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a half hyper-shell, i.e. the space between two circles in two space dimensions and the region between two spheres in 3d, with given inner and outer radius and a given number of elements for this initial triangulation. However, opposed to the previous function, it does not produce a whole shell, but only one half of it, namely that part for which the first component is restricted to non-negative values. The purpose of this function is to enable computations for solutions which have rotational symmetry, in which case the half shell in 2d represents a shell in 3d.</p>
<p>If the number of initial cells <code>n_cells</code> is zero in 2d (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio. The argument is ignored in 3d, where the coarse mesh always has 5 cells.</p>
<p>If colorize is set to <code>true</code>, the inner, outer, and the part of the boundary where \(x=0\), get indicator 0, 1, and 2, respectively. Additionally, in 2d, the boundary indicator 3 is given to the vertical edge below the x-axis. Otherwise, if colorize is set to <code>false</code> all indicators are set to 0 (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>).</p>
<p>All manifold ids are set to zero, and a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached to the triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="acd7c51b0e8032db65db9a5ff73ccca50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7c51b0e8032db65db9a5ff73ccca50">&#9670;&nbsp;</a></span>quarter_hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::quarter_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a domain that is the intersection between a hyper-shell with given inner and outer radius, i.e. the space between two circles in two space dimensions and the region between two spheres in 3d, and the positive quadrant (in 2d) or octant (in 3d). In 2d, this is indeed a quarter of the full annulus, while the function is a misnomer in 3d because there the domain is not a quarter but one eighth of the full shell.</p>
<p>If the number of initial cells is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio in 2d.</p>
<p>If <code>colorize</code> is set to <code>true</code>, the inner, outer, left, and right boundary get indicator 0, 1, 2, and 3 in 2d, respectively. Otherwise all indicators are set to 0. In 3d indicator 2 is at the face \(x=0\), 3 at \(y=0\), 4 at \(z=0\) (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>).</p>
<p>All manifold ids are set to zero, and a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached to the triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function. </dd></dl>

</div>
</div>
<a id="a760789a93b1e0fe7f5c2675c31b6f14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760789a93b1e0fe7f5c2675c31b6f14f">&#9670;&nbsp;</a></span>cylinder_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cylinder_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_radial_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_axial_cells</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a domain that is the space between two cylinders in 3d, with given length, inner and outer radius and a given number of elements. The cylinder shell is built around the \(z\)-axis with the two faces located at \(z = 0\) and \(z = \) <code>length</code>.</p>
<p>If <code>n_radial_cells</code> is zero (as is the default), then it is computed adaptively such that the resulting elements have the least aspect ratio. The same holds for <code>n_axial_cells</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Although this function is declared as a template, it does not make sense in 1D and 2D. Also keep in mind that this object is rotated and positioned differently than the one created by <a class="el" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder()</a>.</dd></dl>
<p>All manifold ids are set to zero, and a <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> is attached to the triangulation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The triangulation passed as argument needs to be empty when calling this function.</dd></dl>
<div class="image">
<img src="cylinder_shell.png" alt="cylinder_shell.png"/>
</div>
<p>In this picture, a cylinder shell of length 2, inner radius 0.5, outer radius 1 is shown. The default argument for n_radial_cells and n_axial_cells are used and a single global refinement is carried out. </p>

</div>
</div>
<a id="a7e99c2ee8ac3332b50baa028b7ded526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e99c2ee8ac3332b50baa028b7ded526">&#9670;&nbsp;</a></span>torus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::torus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells_toroidal</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>phi</em> = <code>2.0&#160;*<a class="el" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce the volume or surface mesh of a torus. The axis of the torus is the \(y\)-axis while the plane of the torus is the \(x\)- \(z\) plane.</p>
<p>If <code>dim</code> is 3, the mesh will be the volume of the torus, using a mesh equivalent to the circle in the poloidal coordinates with 5 cells on the cross section. This function attaches a <a class="el" href="classTorusManifold.html">TorusManifold</a> to all boundary faces which are marked with a manifold id of 1, a <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> to the interior cells and all their faces which are marked with a manifold id of 2 (representing a flat state within the poloidal coordinates), and a <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to the cells between the <a class="el" href="classTorusManifold.html">TorusManifold</a> on the surface and the ToroidalManifold in the center, with cells marked with manifold id 0.</p>
<p>An example for the case if <code>dim</code> is 3 with a cut through the domain at \(z=0\), 6 toroidal cells, \(R=2\) and \(r=0.5\) without any global refinement is given here:</p>
<div class="image">
<img src="torus_manifold_ids.png" alt="torus_manifold_ids.png"/>
</div>
<p>In this picture, the light gray shade represents the manifold id 0 of the transfinite interpolation, which is applied to smoothly add new points between the toroidal shape on the domain boundary and the inner rim where a cylindrical description around the y-axis is prescribed. The inner rim with the manifold id 2 is shown in red shade.</p>
<p>If <code>dim</code> is 2, the mesh will describe the surface of the torus and this function attaches a <a class="el" href="classTorusManifold.html">TorusManifold</a> to all cells and faces (which are marked with a manifold id of 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be filled.</td></tr>
    <tr><td class="paramname">R</td><td>The radius of the circle, which forms the middle line of the torus containing the loop of cells. Must be greater than <code>r</code>.</td></tr>
    <tr><td class="paramname">r</td><td>The inner radius of the torus.</td></tr>
    <tr><td class="paramname">n_cells_toroidal</td><td>Optional argument to set the number of cell layers in toroidal direction. The default is 6 cell layers.</td></tr>
    <tr><td class="paramname">phi</td><td>Optional argument to generate an open torus with angle \(0 &lt; \varphi &lt;= 2 \pi\). The default value is \(2 \pi\), in which case a closed torus is generated. If the torus is open, the torus is cut at two planes perpendicular to the torus centerline. The center of these two planes are located at \((x_1, y_1, z_1) = (R, 0, 0)\) and \((x_2, y_2, z_2) = (R \cos(\varphi), 0, R \sin(\varphi))\).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Implemented for Triangulation&lt;2,3&gt; and Triangulation&lt;3,3&gt;. </dd></dl>

</div>
</div>
<a id="add14cab546d033c1eaacc9234c64ebcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add14cab546d033c1eaacc9234c64ebcd">&#9670;&nbsp;</a></span>hyper_cube_with_cylindrical_hole()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube_with_cylindrical_hole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em> = <code>.25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em> = <code>.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>L</em> = <code>.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>repetitions</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function produces a square in the <em>xy</em>-plane with a cylindrical hole in the middle. The square and the circle are centered at the origin. In 3d, this geometry is extruded in \(z\) direction to the interval \([0,L]\).</p>
<p>The inner boundary has a manifold id of \(0\) and a boundary id of \(6\). This function attaches a <a class="el" href="classPolarManifold.html">PolarManifold</a> or <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> to the interior boundary in 2d and 3d respectively. The other faces have boundary ids of \(0, 1, 2, 3, 4\), or \(5\) given in the standard order of faces in 2d or 3d.</p>
<div class="image">
<img src="cubes_hole.png" alt="cubes_hole.png"/>
</div>
<p>It is implemented in 2d and 3d, and takes the following arguments:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>The triangulation to be filled. </td></tr>
    <tr><td class="paramname">inner_radius</td><td>Radius of the internal hole. </td></tr>
    <tr><td class="paramname">outer_radius</td><td>Half of the edge length of the square. </td></tr>
    <tr><td class="paramname">L</td><td>Extension in <code>z-direction</code> (only used in 3d). </td></tr>
    <tr><td class="paramname">repetitions</td><td>Number of subdivisions along the <code>z-direction</code>. </td></tr>
    <tr><td class="paramname">colorize</td><td>Whether to assign different boundary indicators to different faces (see <a class="el" href="DEALGlossary.html#GlossColorization">the glossary entry on colorization</a>). The colors are given in lexicographic ordering for the flat faces (0 to 3 in 2d, 0 to 5 in 3d) plus the curved hole (4 in 2d, and 6 in 3d). If <code>colorize</code> is set to false, then flat faces get the number 0 and the hole gets number 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfcc142a9fc905a1abec9315693a57d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcc142a9fc905a1abec9315693a57d4">&#9670;&nbsp;</a></span>concentric_hyper_shells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::concentric_hyper_shells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em> = <code>0.125</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em> = <code>0.25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_shells</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>skewness</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells_per_shell</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a grid consisting of concentric shells. The primary difference between this function and <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> is that this function permits unevenly spaced (in the radial direction) <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse level cells</a>.</p>
<p>The parameters <code>center</code>, <code>inner_radius</code>, and <code>outer_radius</code> behave in the same way as the first three arguments to <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>. <code>n_shells</code> gives the total number of shells to use (i.e., the number of cells in the radial direction). The outer radius of the \(k\)th shell is given by</p>
<p class="formulaDsp">
\[ r = r_{\mathrm{inner}} + (r_\mathrm{outer} - r_\mathrm{inner}) \frac{1 - \tanh(\mathrm{skewness}(1 - k/\mathrm{n\_shells}))} {\tanh(\mathrm{skewness})} \]
</p>
<p>where <code>skewness</code> is a parameter controlling the shell spacing in the radial direction: values of <code>skewness</code> close to zero correspond to even spacing, while larger values of <code>skewness</code> (such as \(2\) or \(3\)) correspond to shells biased to the inner radius.</p>
<p><code>n_cells_per_shell</code> is the same as in <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>: in 2d the default choice of zero will result in 8 cells per shell (and 12 in 3d). The only valid values in 3d are 6 (the default), 12, and 96 cells: see the documentation of <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> for more information.</p>
<p>If <code>colorize</code> is <code>true</code> then the outer boundary of the merged shells has a boundary id of \(1\) and the inner boundary has a boundary id of \(0\).</p>
<p>Example: The following code (see, e.g., step-10 for instructions on how to visualize GNUPLOT output)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#abfcc142a9fc905a1abec9315693a57d4">GridGenerator::concentric_hyper_shells</a>(triangulation,</div><div class="line">                                         <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(),</div><div class="line">                                         1.0,</div><div class="line">                                         2.0,</div><div class="line">                                         5u,</div><div class="line">                                         2.0);</div><div class="line"></div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line">  <a class="code" href="structGridOutFlags_1_1Gnuplot.html">GridOutFlags::Gnuplot</a> gnuplot_flags(<span class="keyword">false</span>, 10, <span class="keyword">true</span>);</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a239955214cc9b881e9eb66053564d5d5">set_flags</a>(gnuplot_flags);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;2&gt;</a> mapping(3);</div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;out.gpl&quot;</span>);</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a>(triangulation, out, &amp;mapping);</div><div class="line">}</div></div><!-- fragment --><p>generates the following output:</p>
<div class="image">
<object type="image/svg+xml" data="concentric_hyper_shells_2d.svg">concentric_hyper_shells_2d.svg</object>
</div>
 
</div>
</div>
<a id="a626225354aa3f249f64dc67319e34bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626225354aa3f249f64dc67319e34bf8">&#9670;&nbsp;</a></span>moebius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::moebius </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_rotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a ring of cells in 3d that is cut open, twisted and glued together again. This results in a kind of moebius-loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be worked on. </td></tr>
    <tr><td class="paramname">n_cells</td><td>The number of cells in the loop. Must be greater than 4. </td></tr>
    <tr><td class="paramname">n_rotations</td><td>The number of rotations ( \(\pi/2\) each) to be performed before gluing the loop together. </td></tr>
    <tr><td class="paramname">R</td><td>The radius of the circle, which forms the middle line of the torus containing the loop of cells. Must be greater than <code>r</code>. </td></tr>
    <tr><td class="paramname">r</td><td>The radius of the cylinder bent together as a loop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e6c4dcc63863449f08a78a22ec73747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6c4dcc63863449f08a78a22ec73747">&#9670;&nbsp;</a></span>generate_from_name_and_arguments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::generate_from_name_and_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>grid_generator_function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>grid_generator_function_arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call one of the other <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions, parsing the name of the function to call from the string <code>grid_generator_function_name</code>, and the arguments to the function from the string <code>grid_generator_function_arguments</code>.</p>
<p>The string that supplies the arguments is passed to the function <a class="el" href="structPatterns_1_1Tools_1_1Convert.html#aad1e7362c24708ef3a82171e4c59da13">Patterns::Tools::Convert&lt;TupleTyple&gt;::to_value()</a>, where <code>TupleType</code> here is a tuple containing <b>all</b> the arguments of the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> function, including all optional arguments.</p>
<p>An example usage of this function is given by: </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">  tria,</div><div class="line">  <span class="stringliteral">&quot;hyper_ball&quot;</span>,</div><div class="line">  <span class="stringliteral">&quot;0.0, 0.0 : 1 : false&quot;</span>);</div></div><!-- fragment --><p> Here, the colon separates the function arguments, and the comma separates the coordinates of a <a class="el" href="classPoint.html">Point&lt;2&gt;</a> argument.</p>
<p>According to the arity of the <code>TupleType</code>, the arguments of the function may be separated by different separators (see the documentation of <a class="el" href="classPatterns_1_1Tuple.html">Patterns::Tuple</a> for the details of how the conversion is performed). If a wrong format is used, an exception is thrown, and the expected format is output as an error message.</p>
<p>All <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions are supported. If you find some that are missing, please open an issue on GitHub.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The triangulation to be worked on </td></tr>
    <tr><td class="paramname">grid_generator_function_name</td><td>The name of the function to call </td></tr>
    <tr><td class="paramname">grid_generator_function_arguments</td><td>The arguments of the function, in the format of a tuple-convertible string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cd88e7eacd46697dee80ad2b8438d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd88e7eacd46697dee80ad2b8438d54">&#9670;&nbsp;</a></span>merge_triangulations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::merge_triangulations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>duplicated_vertex_tolerance</em> = <code>1.0e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the two triangulations specified as the first two arguments, create the triangulation that contains the cells of both triangulation and store it in the third parameter. Previous content of <code>result</code> will be deleted. One of the two input triangulations can also be the <code>result</code> triangulation.</p>
<p>This function is most often used to compose meshes for more complicated geometries if the geometry can be composed of simpler parts for which functions exist to generate <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse meshes</a>. For example, the channel mesh used in step-35 could in principle be created using a mesh created by the <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> function and several rectangles, and merging them using the current function. The rectangles will have to be translated to the right for this, a task that can be done using the <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> function (other tools to transform individual mesh building blocks are <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, <a class="el" href="namespaceGridTools.html#a910bb99ec34eac082da97c08e7dd17c3">GridTools::rotate</a>, and <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>).</p>
<p>Vertices that are less than <code>duplicated_vertex_tolerance</code> apart will be merged together. It is usually necessary to set this value to something that depends on the input triangulations in some way. One reasonable choice is to use the minimum distance between all adjacent vertices of the input mesh divided by some constant:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> min_line_length = [](<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;tria) -&gt; <span class="keywordtype">double</span></div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> length = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : tria.active_cell_iterators())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; GeometryInfo&lt;dim&gt;::lines_per_cell; ++n)</div><div class="line">      length = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(length, (cell-&gt;line(n)-&gt;vertex(0) -</div><div class="line">                                 cell-&gt;line(n)-&gt;vertex(1)).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">  <span class="keywordflow">return</span> length;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_line_length(triangulation_1),</div><div class="line">                                  min_line_length(triangulation_2)) / 2.0;</div></div><!-- fragment --><p>This will merge any vertices that are closer than any pair of vertices on the input meshes.</p>
<dl class="section note"><dt>Note</dt><dd>The two input triangulations must be <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse meshes</a>, i.e., they can not have any refined cells.</dd>
<dd>
The function copies the material ids of the cells of the two input triangulations into the output triangulation. If <code>copy_manifold_ids</code> is set to <code>true</code>, manifold ids will be copied. Boundary indicators are never copied. In other words, if the two coarse meshes have anything but the default boundary indicators, then you will have to set boundary indicators again by hand in the output triangulation.</dd>
<dd>
This function does not attach any manifolds to <code>result</code>, nor does it set any manifold ids. In particular, manifolds attached to the two input triangulations will be lost in the <code>result</code> triangulation.</dd>
<dd>
For a related operation on refined meshes when both meshes are derived from the same coarse mesh, see <a class="el" href="namespaceGridGenerator.html#a843fe2c5c77374c51fcd18f05690b902">GridGenerator::create_union_triangulation()</a>. </dd></dl>

</div>
</div>
<a id="a860c7b922eaac094ca4acd506c60ad6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860c7b922eaac094ca4acd506c60ad6f">&#9670;&nbsp;</a></span>merge_triangulations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::merge_triangulations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>duplicated_vertex_tolerance</em> = <code>1.0e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but allows to merge more than two triangulations at once. The following gives an example of how to use this function: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria_1, tria_2, tria_3;</div><div class="line"><span class="comment">// initialize tria_1, tria_2 and tria_3</span></div><div class="line">...</div><div class="line"><a class="code" href="classTriangulation.html#a67f431ce66c6df985caf5587bf329ebc">Triangulation</a>&lt;2&gt; merged_triangulation;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>({&amp;tria_1, &amp;tria_2, &amp;tria_3},</div><div class="line">                                    merged_triangulation,</div><div class="line">                                    1.0e-10,</div><div class="line">                                    <span class="keyword">false</span>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a31cde6da3b561768a26f6c531cc93c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cde6da3b561768a26f6c531cc93c48">&#9670;&nbsp;</a></span>replicate_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::replicate_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replicate a given triangulation in multiple coordinate axes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The triangulation which will be replicated along the coordinate axes.</td></tr>
    <tr><td class="paramname">extents</td><td>A vector with <code>dim</code> entries specifying how many copies of a triangulation should be present along each coordinate axis.</td></tr>
    <tr><td class="paramname">result</td><td>The triangulation to be created. It needs to be empty upon calling this function.</td></tr>
  </table>
  </dd>
</dl>
<p>This function creates a new <a class="el" href="classTriangulation.html">Triangulation</a> equal to a <code>dim</code>-dimensional array of copies of <code>input</code>. Copies of <code>input</code> are created by translating <code>input</code> along the coordinate axes. Boundary ids of faces (but not lines in 3D) and all manifold ids are copied but <a class="el" href="classManifold.html">Manifold</a> objects are not since most <a class="el" href="classManifold.html">Manifold</a> objects do not work correctly when a <a class="el" href="classTriangulation.html">Triangulation</a> has been translated.</p>
<p>To see how this works, consider the following code: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> input;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(input);</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> output;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a31cde6da3b561768a26f6c531cc93c48">GridGenerator::replicate_triangulation</a>(input, {3, 2}, output);</div></div><!-- fragment --><p> results in</p>
<div class="image">
<img src="replicated_tria_2d.png" alt="replicated_tria_2d.png"/>
</div>
<p>And, similarly, in 3D: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> input;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a04f98a456ca1942a071d3a20ef5b4dbe">GridGenerator::hyper_cross</a>(1, 1, 1, 2, 1, 2);</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> output;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a31cde6da3b561768a26f6c531cc93c48">GridGenerator::replicate_triangulation</a>(input, {3, 2, 1}, output);</div></div><!-- fragment --><p> results in</p>
<div class="image">
<img src="replicated_tria_3d.png" alt="replicated_tria_3d.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>This function determines the spacing of the copies of <code>input</code> based on the <a class="el" href="classBoundingBox.html">BoundingBox</a> of <code>input</code>. If the boundary faces of <code>input</code> are not aligned with the coordinate axes then the copies might not share common faces; i.e., this function is intended for simple geometries with boundary faces aligned along the coordinate axes. </dd></dl>

</div>
</div>
<a id="a843fe2c5c77374c51fcd18f05690b902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843fe2c5c77374c51fcd18f05690b902">&#9670;&nbsp;</a></span>create_union_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::create_union_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the two triangulations specified as the first two arguments, create the triangulation that contains the finest cells of both triangulation and store it in the third parameter. Previous content of <code>result</code> will be deleted.</p>
<dl class="section note"><dt>Note</dt><dd>This function is intended to create an adaptively refined triangulation that contains the <em>most refined cells</em> from two input triangulations that were derived from the <em>same</em> <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a> by adaptive refinement. This is an operation sometimes needed when one solves for two variables of a coupled problem on separately refined meshes on the same domain (for example because these variables have boundary layers in different places) but then needs to compute something that involves both variables or wants to output the result into a single file. In both cases, in order not to lose information, the two solutions can not be interpolated onto the respectively other mesh because that may be coarser than the ones on which the variable was computed. Rather, one needs to have a mesh for the domain that is at least as fine as each of the two initial meshes. This function computes such a mesh.</dd>
<dd>
If you want to create a mesh that is the merger of two other <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse meshes</a>, for example in order to compose a mesh for a complicated geometry from meshes for simpler geometries, then this is not the function for you. Instead, consider <a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations()</a>.</dd>
<dd>
This function assumes that both <code>triangulation_1</code> and <code>triangulation_2</code> have the same manifold descriptions. The output <a class="el" href="classTriangulation.html">Triangulation</a> <code>has</code> the same manifold ids as these two triangulations.</dd>
<dd>
Both of the source conditions need to be available entirely locally. In other words, they can not be objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. </dd></dl>

</div>
</div>
<a id="ada140ece81bf38a23e738e0e57f89e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada140ece81bf38a23e738e0e57f89e97">&#9670;&nbsp;</a></span>create_triangulation_with_removed_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::create_triangulation_with_removed_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells_to_remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function creates a triangulation that consists of the same cells as are present in the first argument, except those cells that are listed in the second argument. The purpose of the function is to generate geometries <em>subtractively</em> from the geometry described by an existing triangulation. A prototypical case is a 2d domain with rectangular holes. This can be achieved by first meshing the entire domain and then using this function to get rid of the cells that are located at the holes. A demonstration of this particular use case is part of step-27. Likewise, you could create the mesh that <a class="el" href="namespaceGridGenerator.html#a3b2a4ad8296c2b72a11d23b5969e8cc0">GridGenerator::hyper_L()</a> produces by starting with a <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, refining it once, and then calling the current function with a single cell in the second argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_triangulation</td><td>The original triangulation that serves as the template from which the new one is to be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells_to_remove</td><td>A list of cells of the triangulation provided as first argument that should be removed (i.e., that should not show up in the result. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The resulting triangulation that consists of the same cells as are in <code>input_triangulation</code>, with the exception of the cells listed in <code>cells_to_remove</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unlike most <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> functions, this function does not attach any manifolds to <code>result</code>, nor does it set any manifold ids.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Because we cannot create triangulations de novo that contain adaptively refined cells, the input triangulation needs to have all of its cells on the same level. Oftentimes, this will in fact be the coarsest level, but it is allowed to pass in a triangulation that has been refined <em>globally</em> a number of times. The output triangulation will in that case simply be a mesh with only one level that consists of the active cells of the input minus the ones listed in the second argument. However, the input triangulation must not have been <em>adaptively</em> refined. </dd></dl>

</div>
</div>
<a id="a6cc0ff3b4e5226c3e06a4aa6ac79f90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">&#9670;&nbsp;</a></span>extrude_triangulation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_priorities</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extrude the <a class="el" href="classTriangulation.html">Triangulation</a> <code>input</code> in the \(z\) direction from \(z = 0\) to \(z = \text{height}\) and store it in <code>result</code>.</p>
<p>The number of <em>slices</em>, or layers of cells perpendicular to the \(z = 0\) plane, will be <code>n_slices</code> slices (minimum is 2). The boundary indicators of the faces of <code>input</code> will be assigned to the corresponding side walls in \(z\) direction. The bottom and top get the next two free boundary indicators: i.e., if <code>input</code> has boundary ids of \(0\), \(1\), and \(42\), then the \(z = 0\) boundary id of <code>result</code> will be \(43\) and the \(z = \text{height}\) boundary id will be \(44\).</p>
<p>This function does not, by default, copy manifold ids. The reason for this is that there is no way to set the manifold ids on the lines of the resulting <a class="el" href="classTriangulation.html">Triangulation</a> without more information: for example, if two faces of <code>input</code> with different manifold ids meet at a shared vertex then there is no <em>a priori</em> reason to pick one manifold id or another for the lines created in <code>result</code> that are parallel to the \(z\)-axis and pass through that point. If <code>copy_manifold_ids</code> is <code>true</code> then this function sets line manifold ids by picking the one that appears <em>first</em> in <code>manifold_priorities</code>. For example: if <code>manifold_priorities</code> is <code>{0, 42, <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>}</code> and the line under consideration is adjacent to faces with manifold ids of <code>0</code> and <code>42</code>, then that line will have a manifold id of <code>0</code>. The correct ordering is almost always </p><ol>
<li>
manifold ids set on the boundary, </li>
<li>
manifold ids that describe most of the cells in the <a class="el" href="classTriangulation.html">Triangulation</a> (e.g., <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>), and </li>
<li>
any manifold ids corresponding to <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> manifolds. </li>
</ol>
<p>In particular, since <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> interpolates between surrounding manifolds, its manifold id should usually not be set on lines or faces that are adjacent to cells with different manifold ids. The default value for <code>manifold_priorities</code> follows this ranking (where each category is sorted in ascending order): </p><ol>
<li>
manifold ids associated with manifolds that are not <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a>, and </li>
<li>
manifold ids associated with any <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> objects. </li>
</ol>
<p>Note that <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> (should it be a manifold id of <code>input</code>) will always be the last entry in the first category.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The 2d input triangulation <code>input</code> must be a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a>, i.e., it cannot have any refined cells.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since <code>input</code> and <code>output</code> have different spatial dimensions, no manifold objects are copied by this function regardless of the value of <code>copy_manifold_ids</code>. </dd></dl>

</div>
</div>
<a id="a15c5b7ad43c366f2dcb559782457efda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c5b7ad43c366f2dcb559782457efda">&#9670;&nbsp;</a></span>extrude_triangulation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_priorities</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">extrude_triangulation()</a> to allow dimension independent code to compile. This function throws an error when called, as <a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">extrude_triangulation()</a> is only implemented to extrude a dim=2 to a dim=3 <a class="el" href="classTriangulation.html">Triangulation</a>. </p>

</div>
</div>
<a id="a8a9ce3fd3bac556d634d62d785452f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ce3fd3bac556d634d62d785452f8c">&#9670;&nbsp;</a></span>extrude_triangulation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_priorities</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of the previous function. Take a 2d <a class="el" href="classTriangulation.html">Triangulation</a> that is being extruded. Differing from the previous function taking height and number of slices for uniform extrusion, this function takes z-axis values <code>slice_coordinates</code> where the slicing will happen. The boundary indicators of the faces of <code>input</code> are going to be assigned to the corresponding side walls in z direction. The bottom and top get the next two free boundary indicators.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The 2d input triangulation <code>input</code> must be a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a>, i.e., it cannot have any refined cells.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since <code>input</code> and <code>output</code> have different spatial dimensions no manifold objects are copied (nor are any manifold ids set) by this function. </dd></dl>

</div>
</div>
<a id="acc920b19e79502facbffa861528b71d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc920b19e79502facbffa861528b71d4">&#9670;&nbsp;</a></span>extrude_triangulation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_priorities</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">extrude_triangulation()</a> to allow dimension independent code to compile. This function throws an error when called, as <a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">extrude_triangulation()</a> is only implemented to extrude a dim=2 to a dim=3 <a class="el" href="classTriangulation.html">Triangulation</a>. </p>

</div>
</div>
<a id="afe86bf1a4502131ec811a6de41ab41e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe86bf1a4502131ec811a6de41ab41e9">&#9670;&nbsp;</a></span>flatten_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim1, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::flatten_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an input triangulation <code>in_tria</code>, this function makes a new flat triangulation <code>out_tria</code> which contains a single level with all active cells of the input triangulation. If <code>spacedim1</code> and <code>spacedim2</code> are different, only the smallest spacedim components of the vertices are copied over. This is useful to create a Triangulation&lt;2,3&gt; out of a Triangulation&lt;2,2&gt;, or to project a Triangulation&lt;2,3&gt; into a Triangulation&lt;2,2&gt;, by neglecting the z components of the vertices.</p>
<p>No internal checks are performed on the vertices, which are assumed to make sense topologically in the target <code>spacedim2</code> dimensional space. If this is not the case, you will encounter problems when using the triangulation later on.</p>
<p>All information about cell manifold_ids and material ids are copied from one triangulation to the other, and only the boundary manifold_ids and boundary_ids are copied over from the faces of <code>in_tria</code> to the faces of <code>out_tria</code>. If you need to specify manifold ids on interior faces, they have to be specified manually after the triangulation is created.</p>
<p>This function will fail if the input <a class="el" href="classTriangulation.html">Triangulation</a> is of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, as well as when the input <a class="el" href="classTriangulation.html">Triangulation</a> contains hanging nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_tria</td><td>The base input for a new flat triangulation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_tria</td><td>The desired flattened triangulation constructed from the in_tria.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Since <code>input</code> and <code>output</code> have different spatial dimensions no manifold objects are copied by this function: you must attach new manifold objects to <code>out_tria</code>. </dd></dl>

</div>
</div>
<a id="ac7515d2b17c025dddc0e37286fb8d216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7515d2b17c025dddc0e37286fb8d216">&#9670;&nbsp;</a></span>convert_hypercube_to_simplex_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::convert_hypercube_to_simplex_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a triangulation consisting only of hypercube cells (quadrilaterals, hexahedra) to a triangulation only consisting of simplices (triangles, tetrahedra).</p>
<p>As an example, the following image shows how a set of three hexahedra meshing one eighths of a sphere are subdivided into tetrahedra, and how the curved surface is taken into account. Colors indicate how boundary indicators are inherited: </p><div class="image">
<img src="convert_hypercube_to_simplex_mesh_visualization_octant.png" alt="convert_hypercube_to_simplex_mesh_visualization_octant.png"/>
</div>
<p>In general, each quadrilateral in 2d is subdivided into eight triangles, and each hexahedron in 3d into 24 tetrahedra as shown here: </p><div class="image">
<img src="convert_hypercube_to_simplex_mesh_visualization.png" alt="convert_hypercube_to_simplex_mesh_visualization.png"/>
</div>
<p>Material ID and boundary IDs are inherited upon conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_tria</td><td>The triangulation containing hex elements. </td></tr>
    <tr><td class="paramname">out_tria</td><td>The converted triangulation containing tet elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No manifold objects are copied by this function: you must copy existing manifold objects from <code>in_tria</code> to <code>out_tria</code>, e.g., with the following code: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : in_tria.get_manifold_ids())</div><div class="line">  <span class="keywordflow">if</span> (i != <a class="code" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>)</div><div class="line">    out_tria.set_manifold(i, in_tria.get_manifold(i));</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a01c9d0d7ff5858b45531b626c3a94c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c9d0d7ff5858b45531b626c3a94c2e">&#9670;&nbsp;</a></span>convert_hypercube_to_simplex_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::convert_hypercube_to_simplex_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization of the above function for 1D: simply copy triangulation. </p>

</div>
</div>
<a id="a8f1570ce89e692943efa1bef1d4d4446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1570ce89e692943efa1bef1d4d4446">&#9670;&nbsp;</a></span>extract_boundary_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; int, int &gt; class MeshType, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type GridGenerator::extract_boundary_mesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshType&lt; dim - 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements a boundary subgrid extraction. Given a &lt;dim,spacedim&gt;-Triangulation (the "volume mesh") the function extracts a subset of its boundary (the "surface mesh"). The boundary to be extracted is specified by a list of boundary_ids. If none is specified the whole boundary will be extracted. The function is used in step-38.</p>
<p>The function also builds a mapping linking the cells on the surface mesh to the corresponding faces on the volume one. This mapping is the return value of the function.</p>
<dl class="section note"><dt>Note</dt><dd>The function builds the surface mesh by creating a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a> from the selected faces of the coarse cells of the volume mesh. It copies the boundary indicators of these faces to the cells of the coarse surface mesh. The surface mesh is then refined in the same way as the faces of the volume mesh are. In order to ensure that the surface mesh has the same vertices as the volume mesh, it is therefore important that you assign appropriate boundary descriptions through <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> to the surface mesh object before calling this function. If you don't, the refinement will happen under the assumption that all faces are straight (i.e using the <a class="el" href="classFlatManifold.html">FlatManifold</a> class) rather than utilizing the <a class="el" href="classManifold.html">Manifold</a> object you may want to use to determine the location of new vertices.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MeshType</td><td>A type that satisfies the requirements of the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a>. The map that is returned will be between cell iterators pointing into the container describing the surface mesh and face iterators of the volume mesh container. If MeshType is <a class="el" href="classDoFHandler.html">DoFHandler</a>, then the function will re-build the triangulation underlying the second argument and return a map between appropriate iterators into the MeshType arguments. However, the function will not actually distribute degrees of freedom on this newly created surface mesh.</td></tr>
    <tr><td class="paramname">dim</td><td>The dimension of the cells of the volume mesh. For example, if dim==2, then the cells are quadrilaterals that either live in the plane, or form a surface in a higher-dimensional space. The dimension of the cells of the surface mesh is consequently dim-1. </td></tr>
    <tr><td class="paramname">spacedim</td><td>The dimension of the space in which both the volume and the surface mesh live.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">volume_mesh</td><td>A container of cells that define the volume mesh. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">surface_mesh</td><td>A container whose associated triangulation will be built to consist of the cells that correspond to the (selected portion of) the boundary of the volume mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_ids</td><td>A list of boundary indicators denoting that subset of faces of volume cells for which this function should extract the surface mesh. If left at its default, i.e., if the set is empty, then the function operates on <em>all</em> boundary faces.</td></tr>
  </table>
  </dd>
</dl>
<p>To prevent printing a very long type in the doxygen documentation the actual return type of this function is</p>
<div class="fragment"><div class="line">std::map&lt;<span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler</a>&lt;dim - 1, spacedim&gt;::cell_iterator,</div><div class="line">         <span class="keyword">typename</span> <a class="code" href="group__Iterators.html#ga5c58f6795f69ef6645afd10906343141">DoFHandler&lt;dim, spacedim&gt;::face_iterator</a>&gt;</div></div><!-- fragment --><p>when <code>MeshType</code> is <a class="el" href="classDoFHandler.html">DoFHandler</a> and</p>
<div class="fragment"><div class="line">std::map&lt;<span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim - 1, spacedim&gt;::cell_iterator,</div><div class="line">         <span class="keyword">typename</span> <a class="code" href="classTriaIterator.html">Triangulation&lt;dim, spacedim&gt;::face_iterator</a>&gt;</div></div><!-- fragment --><p>when <code>MeshType</code> is <a class="el" href="classTriangulation.html">Triangulation</a> and and not the shorter stub provided here.</p>
<dl class="section return"><dt>Returns</dt><dd>A map that for each cell of the surface mesh (key) returns an iterator to the corresponding face of a cell of the volume mesh (value). The keys include both active and non-active cells of the surface mesh. The order of vertices of surface cells and the corresponding volume faces may not match in order to ensure that each surface cell is associated with an outward facing normal. As a consequence, if you want to match quantities on the faces of the domain cells and on the cells of the surface mesh, you may have to translate between vertex locations or quadrature points.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm outlined above assumes that all faces on higher refinement levels always have exactly the same boundary indicator as their parent face. Consequently, we can start with coarse level faces and build the surface mesh based on that. It would not be very difficult to extend the function to also copy boundary indicators from finer level faces to their corresponding surface mesh cells, for example to accommodate different geometry descriptions in the case of curved boundaries (but this is not currently implemented).</dd>
<dd>
Since <code>volume_mesh</code> and <code>surface_mesh</code> have different spatial dimensions no manifold objects are copied by this function: you must attach new manifold objects to <code>surface_mesh</code>. </dd></dl>

</div>
</div>
<a id="ad7b4805db66d34e56837dfef047f7fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b4805db66d34e56837dfef047f7fe0">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidRadii&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="aeb2334f33e83f0937aa82a9522d03b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2334f33e83f0937aa82a9522d03b1b">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidRepetitions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The number of repetitions &quot;&lt;&lt; arg1&lt;&lt; &quot; must be &gt;=1.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a764d32da2c6ffefa0759861a295395df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764d32da2c6ffefa0759861a295395df">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidRepetitionsDimension&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The vector of repetitions must have &quot;&lt;&lt; arg1&lt;&lt; &quot; elements.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a9f83e890d6e88b3dac100d994ac53217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f83e890d6e88b3dac100d994ac53217">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidInputOrientation&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The input to this function is oriented in a way that will&quot; &quot; cause all cells to have negative measure.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception for input that is not properly oriented. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
