<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceGridGenerator.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: GridGenerator Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<div class="title">GridGenerator Namespace Reference<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceGridGenerator_1_1Airfoil"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator_1_1Airfoil.html">Airfoil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">为基本几何形状创建网格</div></td></tr>
<tr class="memitem:acea0cbcd68e52ce8113d1134b87de403"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:acea0cbcd68e52ce8113d1134b87de403"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:acea0cbcd68e52ce8113d1134b87de403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1a8bdb6ff5ca4d25a7f709c543b798"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7a1a8bdb6ff5ca4d25a7f709c543b798"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a7a1a8bdb6ff5ca4d25a7f709c543b798">simplex</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, dim &gt; &amp;tria, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>)</td></tr>
<tr class="separator:a7a1a8bdb6ff5ca4d25a7f709c543b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9a83e353f8d69ce49ebdd191a3a51f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aeb9a83e353f8d69ce49ebdd191a3a51f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aeb9a83e353f8d69ce49ebdd191a3a51f">reference_cell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;reference_cell)</td></tr>
<tr class="separator:aeb9a83e353f8d69ce49ebdd191a3a51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358d5bd545bc115c8645d93fa79b64bc"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a358d5bd545bc115c8645d93fa79b64bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a358d5bd545bc115c8645d93fa79b64bc">subdivided_hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> repetitions, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a358d5bd545bc115c8645d93fa79b64bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56019d263ae45708302d5d7599f0d458"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a56019d263ae45708302d5d7599f0d458"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a56019d263ae45708302d5d7599f0d458">hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a56019d263ae45708302d5d7599f0d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76417d7404b75cf53c732f456e6e971"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac76417d7404b75cf53c732f456e6e971"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;repetitions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:ac76417d7404b75cf53c732f456e6e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af215d99be737f1c91f166669e783449e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:af215d99be737f1c91f166669e783449e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#af215d99be737f1c91f166669e783449e">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;step_sizes, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p_1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p_2, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:af215d99be737f1c91f166669e783449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19141a2f24b10ce86f7f90d1661e2ced"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a19141a2f24b10ce86f7f90d1661e2ced"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a19141a2f24b10ce86f7f90d1661e2ced">subdivided_hyper_rectangle</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;spacing, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p, const <a class="el" href="classTable.html">Table</a>&lt; dim, <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> &gt; &amp;material_id, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a19141a2f24b10ce86f7f90d1661e2ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c54698f4666a44ac3982ee62f87ee9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a76c54698f4666a44ac3982ee62f87ee9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a76c54698f4666a44ac3982ee62f87ee9">cheese</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;holes)</td></tr>
<tr class="memdesc:a76c54698f4666a44ac3982ee62f87ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">带矩形孔的矩形域 域本身是矩形的，非常像由subdivided_hyper_rectangle()生成的。参数 <code>holes</code> 指定了域在每个坐标方向上应该有多少个方孔。该方向上的网格单元总数是这个数字的两倍加一。 一个方向上的孔的数量必须至少是一个。 一个有二乘三孔的例子是  <a href="#a76c54698f4666a44ac3982ee62f87ee9">More...</a><br /></td></tr>
<tr class="separator:a76c54698f4666a44ac3982ee62f87ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cef2def7a0b1ce88eef4ec630b1e3b8"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a1cef2def7a0b1ce88eef4ec630b1e3b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a1cef2def7a0b1ce88eef4ec630b1e3b8">plate_with_a_hole</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> inner_radius=0.4, const <a class="el" href="classdouble.html">double</a> outer_radius=1., const <a class="el" href="classdouble.html">double</a> pad_bottom=2., const <a class="el" href="classdouble.html">double</a> pad_top=2., const <a class="el" href="classdouble.html">double</a> pad_left=1., const <a class="el" href="classdouble.html">double</a> pad_right=1., const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> polar_manifold_id=0, const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> tfi_manifold_id=1, const <a class="el" href="classdouble.html">double</a> L=1., const unsigned <a class="el" href="classint.html">int</a> n_slices=2, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="memdesc:a1cef2def7a0b1ce88eef4ec630b1e3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">带有一个（偏移）圆柱形孔的矩形板。 生成一个带有（偏移）圆柱形孔的矩形板。该几何体由2个区域组成。 第一个是一个正方形区域，长度为 <code>outer_radius</code> ，半径为 <code>inner_radius</code> 的孔。 这个区域的单元格将有流形id为 <code>tfi_manifold_id</code> 的TransfiniteInterpolationManifold连接到它们。此外，洞的边界面将与PolarManifold（二维）或CylindricalManifold（三维）相关。这个区域的中心可以通过 <code>center</code> 规定，即孔的轴线将位于 <code>center</code> 处。 第二个区域描述了散装材料的剩余部分。它通过填充参数 <code>pad_bottom</code>, <code>padding_top</code>, <code>padding_left</code> 和 <code>padding_right</code>. 指定，这个区域的所有单元将有一个FlatManifold连接到它们。 板块的最终宽度将是<code>padding_left + 2*outer_radius + padding_right</code>，而其长度为<code>padding_top + 2*outer_radius + padding_bottom</code>。 下面是非对称网格（经过一次全局细化，根据流形ID着色），分别是2D和3D的。 <style>div.image img[src="plate_with_a_hole.png"]{width:25%;}</style>   <a href="#a1cef2def7a0b1ce88eef4ec630b1e3b8">More...</a><br /></td></tr>
<tr class="separator:a1cef2def7a0b1ce88eef4ec630b1e3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0b8a34fe5ca58425aa1fcf0d6132f1"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a9d0b8a34fe5ca58425aa1fcf0d6132f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a9d0b8a34fe5ca58425aa1fcf0d6132f1">channel_with_cylinder</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> shell_region_width=0.03, const unsigned <a class="el" href="classint.html">int</a> n_shells=2, const <a class="el" href="classdouble.html">double</a> skewness=2.0, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a9d0b8a34fe5ca58425aa1fcf0d6132f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a8e0666bdbfa278179377c47536b8e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a22a8e0666bdbfa278179377c47536b8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a22a8e0666bdbfa278179377c47536b8e">general_cell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a22a8e0666bdbfa278179377c47536b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324b8447f05b148e2f58bdbcf89f5325"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a324b8447f05b148e2f58bdbcf89f5325"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a324b8447f05b148e2f58bdbcf89f5325">parallelogram</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a324b8447f05b148e2f58bdbcf89f5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c6b55bcadf6596001a1e232a8faad"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a016c6b55bcadf6596001a1e232a8faad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a016c6b55bcadf6596001a1e232a8faad">parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a016c6b55bcadf6596001a1e232a8faad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91269092ac149bdc6df9baabad785d02"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a91269092ac149bdc6df9baabad785d02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a91269092ac149bdc6df9baabad785d02">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> n_subdivisions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a91269092ac149bdc6df9baabad785d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e16fb3b8412754508c3b574f3ccfdbc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a3e16fb3b8412754508c3b574f3ccfdbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a3e16fb3b8412754508c3b574f3ccfdbc">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a>(&amp;n_subdivisions)[dim], const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;corners)[dim], const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a3e16fb3b8412754508c3b574f3ccfdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93a16355ace7092f5160b44cfeac767"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aa93a16355ace7092f5160b44cfeac767"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aa93a16355ace7092f5160b44cfeac767">subdivided_parallelepiped</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;origin, const std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, dim &gt; &amp;edges, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;subdivisions={}, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:aa93a16355ace7092f5160b44cfeac767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c537aebe22842ec22de2c8b5c545896"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2c537aebe22842ec22de2c8b5c545896"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a2c537aebe22842ec22de2c8b5c545896">enclosed_hyper_cube</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classdouble.html">double</a> thickness=1., const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a2c537aebe22842ec22de2c8b5c545896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533c4778cbc9bcbed365dcab42ca4418"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a533c4778cbc9bcbed365dcab42ca4418"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1., const <a class="el" href="classbool.html">bool</a> attach_spherical_manifold_on_boundary_cells=false)</td></tr>
<tr class="separator:a533c4778cbc9bcbed365dcab42ca4418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a07e4609d568267cab4a2f0414cd913"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a1a07e4609d568267cab4a2f0414cd913"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a1a07e4609d568267cab4a2f0414cd913">hyper_ball_balanced</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:a1a07e4609d568267cab4a2f0414cd913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e98b4b3cd47554a365b55d175338be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a7e98b4b3cd47554a365b55d175338be0">non_standard_orientation_mesh</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> rotate_left_square, const <a class="el" href="classbool.html">bool</a> rotate_right_square)</td></tr>
<tr class="separator:a7e98b4b3cd47554a365b55d175338be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7faa3e36d4333d03a3cc865142f3d2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#af7faa3e36d4333d03a3cc865142f3d2f">non_standard_orientation_mesh</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> face_orientation, const <a class="el" href="classbool.html">bool</a> face_flip, const <a class="el" href="classbool.html">bool</a> face_rotation, const <a class="el" href="classbool.html">bool</a> manipulate_left_cube)</td></tr>
<tr class="separator:af7faa3e36d4333d03a3cc865142f3d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dc2f16fc52cf1e51b9afdc4264ac70"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:ab2dc2f16fc52cf1e51b9afdc4264ac70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ab2dc2f16fc52cf1e51b9afdc4264ac70">hyper_sphere</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; spacedim - 1, spacedim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:ab2dc2f16fc52cf1e51b9afdc4264ac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712f95340c7002afbd5d6fb755e12a61"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a712f95340c7002afbd5d6fb755e12a61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a712f95340c7002afbd5d6fb755e12a61">quarter_hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:a712f95340c7002afbd5d6fb755e12a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af218d0939daf0732e3b507a27ea5d8e3"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:af218d0939daf0732e3b507a27ea5d8e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#af218d0939daf0732e3b507a27ea5d8e3">half_hyper_ball</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>=<a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(), const <a class="el" href="classdouble.html">double</a> radius=1.)</td></tr>
<tr class="separator:af218d0939daf0732e3b507a27ea5d8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> radius=1., const <a class="el" href="classdouble.html">double</a> half_length=1.)</td></tr>
<tr class="separator:a5cdda7b4a76d509af7d1a8dc1320ddb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f6e6a7ae2fe3a862df035dd2cb4467"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a95f6e6a7ae2fe3a862df035dd2cb4467"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a95f6e6a7ae2fe3a862df035dd2cb4467">subdivided_cylinder</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> x_subdivisions, const <a class="el" href="classdouble.html">double</a> radius=1., const <a class="el" href="classdouble.html">double</a> half_length=1.)</td></tr>
<tr class="separator:a95f6e6a7ae2fe3a862df035dd2cb4467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63c93351f77276c20de07c91d3c1e48"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ae63c93351f77276c20de07c91d3c1e48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ae63c93351f77276c20de07c91d3c1e48">truncated_cone</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> radius_0=1.0, const <a class="el" href="classdouble.html">double</a> radius_1=0.5, const <a class="el" href="classdouble.html">double</a> half_length=1.0)</td></tr>
<tr class="separator:ae63c93351f77276c20de07c91d3c1e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a04f98a456ca1942a071d3a20ef5b4dbe">hyper_cross</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;sizes, const <a class="el" href="classbool.html">bool</a> colorize_cells=false)</td></tr>
<tr class="memdesc:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">一个中心单元，每个表面都有堆积的单元突出。 每个正方形网格单元都是笛卡尔的，在每个坐标方向都有一个大小。零号单元的中心是原点。  <a href="#a04f98a456ca1942a071d3a20ef5b4dbe">More...</a><br /></td></tr>
<tr class="separator:a04f98a456ca1942a071d3a20ef5b4dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2a4ad8296c2b72a11d23b5969e8cc0"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a3b2a4ad8296c2b72a11d23b5969e8cc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a3b2a4ad8296c2b72a11d23b5969e8cc0">hyper_L</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=-1., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a3b2a4ad8296c2b72a11d23b5969e8cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab74ba287a243b478588be824ad65ba6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aab74ba287a243b478588be824ad65ba6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aab74ba287a243b478588be824ad65ba6">subdivided_hyper_L</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;repetitions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;bottom_left, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;top_right, const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;n_cells_to_remove)</td></tr>
<tr class="separator:aab74ba287a243b478588be824ad65ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114625911496e4f51758fe00562a14a"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a5114625911496e4f51758fe00562a14a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a5114625911496e4f51758fe00562a14a">hyper_cube_slit</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> left=0., const <a class="el" href="classdouble.html">double</a> right=1., const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a5114625911496e4f51758fe00562a14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85de345ccd86a53e63746709c8e1dfc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad85de345ccd86a53e63746709c8e1dfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells=0, <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:ad85de345ccd86a53e63746709c8e1dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f3256a8eccaaa366a9cca918a585ed"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a54f3256a8eccaaa366a9cca918a585ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a54f3256a8eccaaa366a9cca918a585ed">eccentric_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;inner_center, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;outer_center, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells)</td></tr>
<tr class="separator:a54f3256a8eccaaa366a9cca918a585ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a6f31aa1d176dd99c2183efdb4b9cb5f5">half_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells=0, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:a6f31aa1d176dd99c2183efdb4b9cb5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#acd7c51b0e8032db65db9a5ff73ccca50">quarter_hyper_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_cells=0, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:acd7c51b0e8032db65db9a5ff73ccca50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a760789a93b1e0fe7f5c2675c31b6f14f">cylinder_shell</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> length, const <a class="el" href="classdouble.html">double</a> inner_radius, const <a class="el" href="classdouble.html">double</a> outer_radius, const unsigned <a class="el" href="classint.html">int</a> n_radial_cells=0, const unsigned <a class="el" href="classint.html">int</a> n_axial_cells=0)</td></tr>
<tr class="separator:a760789a93b1e0fe7f5c2675c31b6f14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e99c2ee8ac3332b50baa028b7ded526"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7e99c2ee8ac3332b50baa028b7ded526"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a7e99c2ee8ac3332b50baa028b7ded526">torus</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classdouble.html">double</a> R, const <a class="el" href="classdouble.html">double</a> r, const unsigned <a class="el" href="classint.html">int</a> n_cells_toroidal=6, const <a class="el" href="classdouble.html">double</a> phi=2.0 *<a class="el" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>)</td></tr>
<tr class="separator:a7e99c2ee8ac3332b50baa028b7ded526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add14cab546d033c1eaacc9234c64ebcd"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:add14cab546d033c1eaacc9234c64ebcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">hyper_cube_with_cylindrical_hole</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classdouble.html">double</a> inner_radius=.25, const <a class="el" href="classdouble.html">double</a> outer_radius=.5, const <a class="el" href="classdouble.html">double</a> L=.5, const unsigned <a class="el" href="classint.html">int</a> repetitions=1, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:add14cab546d033c1eaacc9234c64ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcc142a9fc905a1abec9315693a57d4"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:abfcc142a9fc905a1abec9315693a57d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#abfcc142a9fc905a1abec9315693a57d4">concentric_hyper_shells</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classdouble.html">double</a> inner_radius=0.125, const <a class="el" href="classdouble.html">double</a> outer_radius=0.25, const unsigned <a class="el" href="classint.html">int</a> n_shells=1, const <a class="el" href="classdouble.html">double</a> skewness=0.1, const unsigned <a class="el" href="classint.html">int</a> n_cells_per_shell=0, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:abfcc142a9fc905a1abec9315693a57d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626225354aa3f249f64dc67319e34bf8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a626225354aa3f249f64dc67319e34bf8">moebius</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> n_cells, const unsigned <a class="el" href="classint.html">int</a> n_rotations, const <a class="el" href="classdouble.html">double</a> R, const <a class="el" href="classdouble.html">double</a> r)</td></tr>
<tr class="separator:a626225354aa3f249f64dc67319e34bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6c4dcc63863449f08a78a22ec73747"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1e6c4dcc63863449f08a78a22ec73747"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">generate_from_name_and_arguments</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::string &amp;grid_generator_function_name, const std::string &amp;grid_generator_function_arguments)</td></tr>
<tr class="separator:a1e6c4dcc63863449f08a78a22ec73747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">从其他网格中创建网格</div></td></tr>
<tr class="memitem:a7cd88e7eacd46697dee80ad2b8438d54"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7cd88e7eacd46697dee80ad2b8438d54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">merge_triangulations</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_2, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result, const <a class="el" href="classdouble.html">double</a> duplicated_vertex_tolerance=1.0e-12, const bool copy_manifold_ids=false)</td></tr>
<tr class="separator:a7cd88e7eacd46697dee80ad2b8438d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860c7b922eaac094ca4acd506c60ad6f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a860c7b922eaac094ca4acd506c60ad6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a860c7b922eaac094ca4acd506c60ad6f">merge_triangulations</a> (const std::vector&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&gt; &amp;triangulations, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result, const <a class="el" href="classdouble.html">double</a> duplicated_vertex_tolerance=1.0e-12, const bool copy_manifold_ids=false)</td></tr>
<tr class="separator:a860c7b922eaac094ca4acd506c60ad6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cde6da3b561768a26f6c531cc93c48"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:a31cde6da3b561768a26f6c531cc93c48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a31cde6da3b561768a26f6c531cc93c48">replicate_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;input, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;extents, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="memdesc:a31cde6da3b561768a26f6c531cc93c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate a given triangulation in multiple coordinate axes.  <a href="#a31cde6da3b561768a26f6c531cc93c48">More...</a><br /></td></tr>
<tr class="separator:a31cde6da3b561768a26f6c531cc93c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843fe2c5c77374c51fcd18f05690b902"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a843fe2c5c77374c51fcd18f05690b902"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a843fe2c5c77374c51fcd18f05690b902">create_union_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_1, const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;triangulation_2, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="separator:a843fe2c5c77374c51fcd18f05690b902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada140ece81bf38a23e738e0e57f89e97"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ada140ece81bf38a23e738e0e57f89e97"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ada140ece81bf38a23e738e0e57f89e97">create_triangulation_with_removed_cells</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;input_triangulation, const std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;cells_to_remove, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;result)</td></tr>
<tr class="separator:ada140ece81bf38a23e738e0e57f89e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc0ff3b4e5226c3e06a4aa6ac79f90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const unsigned <a class="el" href="classint.html">int</a> n_slices, const <a class="el" href="classdouble.html">double</a> height, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;result, const <a class="el" href="classbool.html">bool</a> copy_manifold_ids=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_priorities={})</td></tr>
<tr class="separator:a6cc0ff3b4e5226c3e06a4aa6ac79f90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c5b7ad43c366f2dcb559782457efda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a15c5b7ad43c366f2dcb559782457efda">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const unsigned <a class="el" href="classint.html">int</a> n_slices, const <a class="el" href="classdouble.html">double</a> height, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;result, const <a class="el" href="classbool.html">bool</a> copy_manifold_ids=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_priorities={})</td></tr>
<tr class="separator:a15c5b7ad43c366f2dcb559782457efda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ce3fd3bac556d634d62d785452f8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a8a9ce3fd3bac556d634d62d785452f8c">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;slice_coordinates, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;result, const <a class="el" href="classbool.html">bool</a> copy_manifold_ids=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_priorities={})</td></tr>
<tr class="separator:a8a9ce3fd3bac556d634d62d785452f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc920b19e79502facbffa861528b71d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#acc920b19e79502facbffa861528b71d4">extrude_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;input, const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;slice_coordinates, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;result, const <a class="el" href="classbool.html">bool</a> copy_manifold_ids=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_priorities={})</td></tr>
<tr class="separator:acc920b19e79502facbffa861528b71d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe86bf1a4502131ec811a6de41ab41e9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim1, int spacedim2&gt; </td></tr>
<tr class="memitem:afe86bf1a4502131ec811a6de41ab41e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#afe86bf1a4502131ec811a6de41ab41e9">flatten_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim1 &gt; &amp;in_tria, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim2 &gt; &amp;out_tria)</td></tr>
<tr class="separator:afe86bf1a4502131ec811a6de41ab41e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7515d2b17c025dddc0e37286fb8d216"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac7515d2b17c025dddc0e37286fb8d216"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ac7515d2b17c025dddc0e37286fb8d216">convert_hypercube_to_simplex_mesh</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;in_tria, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;out_tria)</td></tr>
<tr class="separator:ac7515d2b17c025dddc0e37286fb8d216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c9d0d7ff5858b45531b626c3a94c2e"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a01c9d0d7ff5858b45531b626c3a94c2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a01c9d0d7ff5858b45531b626c3a94c2e">convert_hypercube_to_simplex_mesh</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;in_tria, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;out_tria)</td></tr>
<tr class="separator:a01c9d0d7ff5858b45531b626c3a94c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f07aec3ce0611f459d2f692ade0c17"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga88f07aec3ce0611f459d2f692ade0c17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__simplex.html#ga88f07aec3ce0611f459d2f692ade0c17">subdivided_hyper_rectangle_with_simplices</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;repetitions, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:ga88f07aec3ce0611f459d2f692ade0c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00002873580ef3b74d81c5ed4250bfbc"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga00002873580ef3b74d81c5ed4250bfbc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__simplex.html#ga00002873580ef3b74d81c5ed4250bfbc">subdivided_hyper_cube_with_simplices</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const unsigned <a class="el" href="classint.html">int</a> repetitions, const <a class="el" href="classdouble.html">double</a> p1=0.0, const <a class="el" href="classdouble.html">double</a> p2=1.0, const <a class="el" href="classbool.html">bool</a> <a class="el" href="grid__out_8cc.html#a6b19797eabf24813c42dbeaabb5b4e17">colorize</a>=false)</td></tr>
<tr class="separator:ga00002873580ef3b74d81c5ed4250bfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">创建低维网格 从高维网格的一部分创建。</div></td></tr>
<tr class="memitem:a45440e91a38475333d937938bbd3b046"><td class="memTemplParams" colspan="2">template&lt;template&lt; int, int &gt; class MeshType, int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a45440e91a38475333d937938bbd3b046"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; typename MeshType&lt; dim - 1, spacedim &gt;::cell_iterator, typename MeshType&lt; dim, spacedim &gt;::face_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">extract_boundary_mesh</a> (const MeshType&lt; dim, spacedim &gt; &amp;volume_mesh, MeshType&lt; dim - 1, spacedim &gt; &amp;surface_mesh, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a45440e91a38475333d937938bbd3b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">异常情况</div></td></tr>
<tr class="memitem:ad7b4805db66d34e56837dfef047f7fe0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#ad7b4805db66d34e56837dfef047f7fe0">DeclException0</a> (ExcInvalidRadii)</td></tr>
<tr class="separator:ad7b4805db66d34e56837dfef047f7fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2334f33e83f0937aa82a9522d03b1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#aeb2334f33e83f0937aa82a9522d03b1b">DeclException1</a> (ExcInvalidRepetitions, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of repetitions &quot;&lt;&lt; arg1&lt;&lt; &quot; must be &gt;=1.&quot;)</td></tr>
<tr class="separator:aeb2334f33e83f0937aa82a9522d03b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764d32da2c6ffefa0759861a295395df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a764d32da2c6ffefa0759861a295395df">DeclException1</a> (ExcInvalidRepetitionsDimension, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The vector of repetitions  must have &quot;&lt;&lt; arg1&lt;&lt; &quot; elements.&quot;)</td></tr>
<tr class="separator:a764d32da2c6ffefa0759861a295395df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f83e890d6e88b3dac100d994ac53217"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceGridGenerator.html#a9f83e890d6e88b3dac100d994ac53217">DeclExceptionMsg</a> (ExcInvalidInputOrientation, &quot;The input to this function is oriented in a way that will&quot; &quot; cause all cells to have negative measure.&quot;)</td></tr>
<tr class="separator:a9f83e890d6e88b3dac100d994ac53217"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>这个命名空间提供了一个函数集合，用于为一些基本的几何体生成三角图。 如果域是弯曲的，应该按照适当的Manifold描述进行细化的每个域部分将收到不同的 <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">流形指标</a> ，并且正确的Manifold描述符将被附加到三角图中。请注意，如果你以后对三角测量进行转换，你必须确保将正确的新Manifold附加到三角测量中。 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acea0cbcd68e52ce8113d1134b87de403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea0cbcd68e52ce8113d1134b87de403">&#9670;&nbsp;</a></span>hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用一个恰好由一个单元组成的超立方体（一维的线，二维的方，等等）初始化给定的三角结构。超立方体的体积是目前维数中的张量乘积区间 \([left,right]^{\text{dim}}\) ，其中极限作为参数给出。它们默认为零和一，然后产生单位超立方体。 如果参数 <code>colorize</code> 是假的，那么2d和3d的所有边界指标都被设置为零（默认边界指标）。如果它是真，那么边界就会像hyper_rectangle()中那样被 <a class="el" href="DEALGlossary.html#GlossColorization">着色</a> 。在1d中，指标总是被着色的，见hyper_rectangle()。 </p><div class="image">
<img src="hyper_cubes.png" alt="hyper_cubes.png"/>
<div class="caption">
如果 <code>dim</code> &lt; <code>spacedim</code>,</div></div>
<p> 这将在第一个 <code>dim</code> 坐标方向创建一个 <code>dim</code> 维的对象，嵌入到 <code>spacedim</code> 维的空间，其余的条目设置为零。例如，一个<code><a class="el" href="classTriangulation.html">Triangulation</a> &lt;2,3&gt;</code> 将是xy平面上的一个正方形，z=0。对于由多个单元组成的粗略网格，也请参见subdivided_hyper_cube()。如果需要在不同的序数方向上有不同的长度，参见hyper_rectangle()。 </p><dl class="section pre"><dt>Precondition</dt><dd>当调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="a7a1a8bdb6ff5ca4d25a7f709c543b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1a8bdb6ff5ca4d25a7f709c543b798">&#9670;&nbsp;</a></span>simplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::simplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个 \(d\) -<a href="https://en.wikipedia.org/wiki/Simplex">simplex</a>（即2D中的三角形，或3D中的四面体），其角为 \(d+1\) 。由于deal.II不支持三角形和四面体单元，输入参数所描述的单面体通过增加边缘、面和单面体中点被细分为四边形和六面体，从而得到一个由 \(d+1\) 四边形或六面体单元组成的网格。 <code>vertices</code> 参数包含一个向量，其中包含所有定义单线角的d+1个顶点。它们必须以这样的顺序给出，即从第一个顶点到其他每个顶点的向量形成一个右手系统。 在二维和三维中生成的网格是。 </p><div class="image">
<img src="simplex_2d.png" alt="simplex_2d.png"/>
<div class="caption">
html simplex_3d.png  tria 要创建的三角结构。在调用此函数时，它需要是空的。  顶点 单纯线的dim+1角。</div></div>
 <dl class="section note"><dt>Note</dt><dd>为<code>三角法 &lt;2,2&gt;</code>, <code>三角法 &lt;3,3&gt;</code>. 实现。 </dd></dl>

</div>
</div>
<a id="aeb9a83e353f8d69ce49ebdd191a3a51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9a83e353f8d69ce49ebdd191a3a51f">&#9670;&nbsp;</a></span>reference_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::reference_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;&#160;</td>
          <td class="paramname"><em>reference_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a358d5bd545bc115c8645d93fa79b64bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358d5bd545bc115c8645d93fa79b64bc">&#9670;&nbsp;</a></span>subdivided_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与hyper_cube()相同，但不同的是，不仅创建一个单元，而且每个坐标方向被细分为 <code>repetitions</code> 个单元。因此，填充给定体积的单元的数量是<code>repetitions<sup>dim</sup></code>。 如果 <code>dim</code> &lt; <code>spacedim</code>, ，这将在第一个 <code>dim</code> 坐标方向创建一个 <code>dim</code> 维度的对象，嵌入到 <code>spacedim</code> 维度的空间，其余条目设置为零。例如， &lt;2,3&gt; 三角形将是xy平面上的一个正方形，z=0。 </p><dl class="section pre"><dt>Precondition</dt><dd>在调用此函数时，作为参数传递的三角形需要为空。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>要创建的三角结构。调用此函数时，它必须为空。 </td></tr>
    <tr><td class="paramname">repetitions</td><td>一个无符号整数，表示在每个方向上生成的单元数。 </td></tr>
    <tr><td class="paramname">left</td><td>用于创建超立方体的区间的下限。 </td></tr>
    <tr><td class="paramname">右</td><td>用于创建超立方体的区间的上界。 </td></tr>
    <tr><td class="paramname">colorize</td><td>如果设置为 "true"，则指定不同的边界ID。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56019d263ae45708302d5d7599f0d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56019d263ae45708302d5d7599f0d458">&#9670;&nbsp;</a></span>hyper_rectangle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac76417d7404b75cf53c732f456e6e971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76417d7404b75cf53c732f456e6e971">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从两个斜对角的角点 <code>p1</code> 和 <code>p2</code>. 创建一个坐标平行的砖块，坐标方向 <code>i</code> 的单元格数量由整数<code>repetitions[i]<code>给出。 为了得到与域的长宽比不同的单元，使用不同的细分数，由不同坐标方向的 <code>repetitions</code>, 给出。如果 <code>colorize</code> 的标志是 <code>true</code> ，则分配曲面的 <code>boundary_ids</code> ，这样 <code>x-direction</code> 中较低的是0，较高的是1（左边和右边的垂直面）。 <code>y-direction</code> 中表面的指标是2和3， <code>z</code> 的指标是4和5。 此外，材料ID是根据单元格的中心所在的八度空间来分配的：对于任何坐标方向<em>x<sub>i</sub></em>来说，在右半面都会增加2<sup>i</sup>（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇条</a> ）。 例如，中心点（1,-1,1）产生一个材料id 5（这意味着在2d中只有材料id 0,1,2,3被分配，与重复的数量无关）。 请注意， <code>colorize</code> 标志在1d中被忽略，并被假定为始终为真。这意味着边界指标在左边是0，在右边是1。 详见 <a class="el" href="step_15.html">step-15</a> 。 如果 <code>dim</code> &lt; <code>spacedim</code>, ，这将在第一个 <code>dim</code> 坐标方向创建一个 <code>dim</code> 维度的对象，嵌入到 <code>spacedim</code> 维度空间，其余条目设置为零。例如，一个<code>三角法 &lt;2,3&gt;</code> 将是xy平面上的一个矩形，z=0，由两个相对的角 <code>p1</code> 和 <code>p2</code>. 定义。 </p><dl class="section note"><dt>Note</dt><dd>关于这个函数的使用实例，见 <a class="el" href="step_28.html">step-28</a> 教程程序。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>要创建的三角结构。在调用此函数时，它需要是空的。 </td></tr>
    <tr><td class="paramname">Repetitions</td><td><code>dim</code> 正值的向量，表示在该方向上生成的单元的数量。 </td></tr>
    <tr><td class="paramname">p1</td><td>第一个角点。 </td></tr>
    <tr><td class="paramname">p2</td><td>第二个角点与 <code>p1</code>. 相对 </td></tr>
    <tr><td class="paramname">colorize</td><td>如果设置为真，则指定不同的边界id。与hyper_rectangle()函数适用的注释相同。 </td></tr>
  </table>
  </dd>
</dl>
<p></code></code></p>

</div>
</div>
<a id="af215d99be737f1c91f166669e783449e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af215d99be737f1c91f166669e783449e">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>step_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样。然而，这里的第二个参数并不表示每个坐标方向上的细分数量，而是表示每个坐标方向上的步长序列。因此，域将在坐标方向 <code>i</code> 上被细分为 <code>step_sizes[i].size()</code> 个单元，宽度为 <code>step_sizes[i][j]</code> for the <code>j</code> 个单元。 因此，这个函数适合于生成分级网格，单元集中在某些区域，而不是像前一个函数生成的均匀细分的网格。 步长必须加到由点 <code>p1</code> 和 <code>p2</code>. 指定的超矩形的尺寸。 </p>

</div>
</div>
<a id="a19141a2f24b10ce86f7f90d1661e2ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19141a2f24b10ce86f7f90d1661e2ced">&#9670;&nbsp;</a></span>subdivided_hyper_rectangle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_rectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>spacing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; dim, <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>material_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就像之前的函数一样，但有以下变化： <code>的material_id参数是一个dim-dimensional数组，对于每个单元，它指示应该设置哪个material_id。此外，这是主要的新功能，如果一个单元格的</code> material_id 是 <code>(unsigned char)(-1)</code>，那么这个单元格就会从三角结构中删除，也就是说，域中会有一个空白。 </p><dl class="section note"><dt>Note</dt><dd>如果你需要大量的孔，你可以考虑cheese()。 </dd></dl>

</div>
</div>
<a id="a76c54698f4666a44ac3982ee62f87ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c54698f4666a44ac3982ee62f87ee9">&#9670;&nbsp;</a></span>cheese()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cheese </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>holes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>带矩形孔的矩形域 域本身是矩形的，非常像由subdivided_hyper_rectangle()生成的。参数 <code>holes</code> 指定了域在每个坐标方向上应该有多少个方孔。该方向上的网格单元总数是这个数字的两倍加一。 一个方向上的孔的数量必须至少是一个。 一个有二乘三孔的例子是 </p>
<div class="image">
<img src="cheese_2d.png" alt="cheese_2d.png"/>
<div class="caption">
如果 <code>dim</code> &lt; <code>spacedim</code>, 这将在第一个 <code>dim</code> 坐标方向创建一个 <code>dim</code> 维度的对象，嵌入到 <code>spacedim</code> 维度的空间，其余条目设置为零。  tria 要创建的三角结构。在调用此函数时，它需要是空的。  holes 在每个dim方向上的孔的正数。</div></div>
 
</div>
</div>
<a id="a1cef2def7a0b1ce88eef4ec630b1e3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cef2def7a0b1ce88eef4ec630b1e3b8">&#9670;&nbsp;</a></span>plate_with_a_hole()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::plate_with_a_hole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em> = <code>0.4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>pad_bottom</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>pad_top</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>pad_left</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>pad_right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>polar_manifold_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>tfi_manifold_id</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>L</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_slices</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>带有一个（偏移）圆柱形孔的矩形板。 生成一个带有（偏移）圆柱形孔的矩形板。该几何体由2个区域组成。 第一个是一个正方形区域，长度为 <code>outer_radius</code> ，半径为 <code>inner_radius</code> 的孔。 这个区域的单元格将有流形id为 <code>tfi_manifold_id</code> 的TransfiniteInterpolationManifold连接到它们。此外，洞的边界面将与PolarManifold（二维）或CylindricalManifold（三维）相关。这个区域的中心可以通过 <code>center</code> 规定，即孔的轴线将位于 <code>center</code> 处。 第二个区域描述了散装材料的剩余部分。它通过填充参数 <code>pad_bottom</code>, <code>padding_top</code>, <code>padding_left</code> 和 <code>padding_right</code>. 指定，这个区域的所有单元将有一个FlatManifold连接到它们。 板块的最终宽度将是<code>padding_left + 2*outer_radius + padding_right</code>，而其长度为<code>padding_top + 2*outer_radius + padding_bottom</code>。 下面是非对称网格（经过一次全局细化，根据流形ID着色），分别是2D和3D的。 <style>div.image img[src="plate_with_a_hole.png"]{width:25%;}</style>  </p>
<div class="image">
<img src="plate_with_a_hole.png@htmlonly" alt="plate_with_a_hole.png@htmlonly"/>
<div class="caption">
div.image img[src="plate_with_a_hole_3D.png"]{width:25%;}   html plate_with_a_hole_3D.png ] 在3D中，三角形将在Z方向上被挤压，总高度为 <code>L</code> 使用 <code>n_slices</code> 片（最小为2）。</div></div>
<p> 如果 <code>colorize</code> 标志是 <code>true</code> ，则边界面的边界_id被分配为，在x方向上的低位是0，高位是1（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇条</a> ）。 y方向的面的指标是2和3，z方向的是5和6。孔洞边界的指标是4。 <code>tria</code> 是要创建的三角形。在调用这个函数时，它需要是空的。 </p>

</div>
</div>
<a id="a9d0b8a34fe5ca58425aa1fcf0d6132f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0b8a34fe5ca58425aa1fcf0d6132f1">&#9670;&nbsp;</a></span>channel_with_cylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::channel_with_cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>shell_region_width</em> = <code>0.03</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_shells</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>skewness</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>生成一个由通道与圆柱体组成的网格。这是纳维-斯托克斯求解器的一个常见基准。该几何体包括一个尺寸为 \([0, 2.2] \times [0, 0.41] \times [0, 0.41] \) 的通道（其中 \(z\) 尺寸在二维中被省略），该通道有一个圆柱体，平行于 \(z\) 轴，直径为 \(0.1\) ，中心为 \((0.2, 0.2, 0)\) 。该通道有三个不同的区域。 </p><ol>
<li>
如果 <code>n_shells</code> 大于零，那么就有那么多以圆柱体为中心的壳，  </li>
<li>
是壳和三角形其他部分之间的混合区域，以及  </li>
<li>
是由笛卡尔单元组成的散装区域。  </li>
</ol>
<p>由于圆柱体略微偏离通道中心，这种几何形状导致了中等雷诺数下的涡流脱落。下面是二维的网格（没有额外的全局细化）： </p><div class="image">
<img src="channel_with_cylinder_2d.png" alt="channel_with_cylinder_2d.png"/>
<div class="caption">
和三维的网格：  html channel_with_cylinder_3d.png 由此产生的三角形使用了三个流形：一个PolarManifold（二维）或CylindricalManifold（三维），流形ID为 \((0.2, 0.2, 0)\)#1243 ，一个TransfiniteInterpolationManifold，流形ID为 \((0.2, 0.2, 0)\)#1244 ，其他地方为FlatManifold。关于这一主题的更多信息，请参见  GlossManifoldIndicator "流形指标的词汇表条目"。 圆柱体和周围贝壳上的单元面的流形指标为 \((0.2, 0.2, 0)\)#1243 ，而与贝壳相邻的单元体（如果不存在，则为圆柱体）的流形指标为 \((0.2, 0.2, 0)\)#1244 。换句话说：这个网格使用TransfiniteInterpolationManifold来平滑地从壳（用 GridGenerator::concentric_hyper_shells) 生成）过渡到体块区域。所有其他单元体和面的流形ID为 numbers::flat_manifold_id 并使用FlatManifold。所有id为 numbers::flat_manifold_id 的单元都是与坐标轴对齐的矩形棱镜。 下图显示了两次全局细化后的部分二维网格（使用该函数的所有默认参数）。流形标识 \((0.2, 0.2, 0)\)#1243 的单元为橙色（极坐标流形标识），流形标识 \((0.2, 0.2, 0)\)#1244 的单元为黄色（无限插值流形标识），流形标识 numbers::flat_manifold_id 的单元为青色：  html channel_with_cylinder_2d_manifolds.png  tria 要创建的三角形。调用此函数时必须为空。  shell_region_width 围绕圆柱体的壳层的宽度。 这个值应该在 \((0.2, 0.2, 0)\)#1243 和 \((0.2, 0.2, 0)\)#1245 之间；默认值是 \((0.2, 0.2, 0)\)#1246 。  n_shells 在壳层中使用的壳的数量。  skewness 控制壳与圆柱体的接近程度的参数：见 GridGenerator::concentric_hyper_shells. 中给出的数学定义  colorize 如果设置为true，则分配不同的边界ID。关于边界指示器的更多信息见  GlossBoundaryIndicator "本词汇表条目"。 左边的边界（在 \((0.2, 0.2, 0)\)#1247 处）被分配一个 \((0.2, 0.2, 0)\)#1243 的id，右边的边界（在 \((0.2, 0.2, 0)\)#1248 处）被分配一个 \((0.2, 0.2, 0)\)#1244 的id，圆柱体的边界被分配一个 \((0.2, 0.2, 0)\)#1249 的id，而通道壁被分配一个 \((0.2, 0.2, 0)\)#1250 的id 。 更多信息请参见原始论文。</div></div>
 <div class="fragment"><div class="line">@inbook{schafer1996,</div><div class="line">author    = {Sch{\&quot;a}fer, M. and Turek, S. and Durst, F. and Krause, E.</div><div class="line">           and Rannacher, R.},</div><div class="line">title     = {Benchmark Computations of Laminar Flow Around a Cylinder},</div><div class="line">bookTitle = {Flow Simulation with High-Performance Computers II: DFG</div><div class="line">           Priority Research Programme Results 1993--1995},</div><div class="line">year      = {1996},</div><div class="line">publisher = {Vieweg+Teubner Verlag},</div><div class="line">address   = {Wiesbaden},</div><div class="line">pages     = {547--566},</div><div class="line">isbn      = {978-3-322-89849-4},</div><div class="line">doi       = {10.1007/978-3-322-89849-4_39},</div><div class="line">url       = {https://doi.org/10.1007/978-3-322-89849-4_39}</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a22a8e0666bdbfa278179377c47536b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a8e0666bdbfa278179377c47536b8e">&#9670;&nbsp;</a></span>general_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::general_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个一般的 <code>dim</code> </p>
<ul>
<li>浸入 <code>dim</code> 的一般单元（如果dim为1，则为线段，如果 <code>dim</code> 为2，则为四边形，如果 <code>dim</code> 为3，则为六面体）。</li>
<li>膨胀空间。用户有责任按照正确的顺序提供顶点（参见GeometryInfo类的文档），因为顶点是按照给出的顺序存储的。确保单元格的体积为正值也很重要。 如果参数 <code>colorize</code> 是假的，那么2d和3d的所有边界指标都被设置为零。如果是true，边界就会像hyper_rectangle()中那样被着色（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇表条目</a>）。 在1d中，指标总是被着色的，见hyper_rectangle()。 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>将被创建的三角形 </td></tr>
    <tr><td class="paramname">vertices</td><td>单元的2^dim顶点 </td></tr>
    <tr><td class="paramname">colorize</td><td>如果为真，设置不同的边界id。 </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a324b8447f05b148e2f58bdbcf89f5325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324b8447f05b148e2f58bdbcf89f5325">&#9670;&nbsp;</a></span>parallelogram()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::parallelogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个平行四边形。第一个角点是原点。接下来的 <code>dim</code> 顶点是第二个参数中给出的顶点，最后一个顶点将是连接原点和这些点的两个向量之和。着色的方式与hyper_rectangle()中的方式相同。 </p><dl class="section note"><dt>Note</dt><dd>这个函数只在2d中实现。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>要创建的三角结构。在调用此函数时，它需要是空的。 </td></tr>
    <tr><td class="paramname">corners</td><td>平行四边形的第二个和第三个顶点。 </td></tr>
    <tr><td class="paramname">colorize</td><td>如果为真，则指定不同的边界ID。参见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇表条目</a> ）。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a016c6b55bcadf6596001a1e232a8faad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016c6b55bcadf6596001a1e232a8faad">&#9670;&nbsp;</a></span>parallelepiped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个平行四边形。第一个角点是原点。 <code>dim</code> 相邻的点是描述平行四边形相对于原点的边缘的向量。额外的点是这些凹陷向量的总和。着色是根据hyper_rectangle()进行的。 </p><dl class="section note"><dt>Note</dt><dd>这个函数默默地将单元格上的顶点重新排序为lexicographic排序（见 <code>GridReordering::reorder_grid</code> ）。 换句话说，如果顶点的重新排序确实发生了， <code>corners</code> 的数组中的顶点排序将不再是指同一个三角形。 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="a91269092ac149bdc6df9baabad785d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91269092ac149bdc6df9baabad785d02">&#9670;&nbsp;</a></span>subdivided_parallelepiped() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个细分的平行四边形。第一个角点是原点。 <code>相邻的dim点是描述平行四边形相对于原点的边缘的向量。其他的点是这些dim向量的总和。变量</code> <code>n_subdivisions</code> 指定了每个 <code>dim</code> 方向上的细分数量。着色是根据hyper_rectangle()来完成的。 </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角图需要为空。 </dd></dl>

</div>
</div>
<a id="a3e16fb3b8412754508c3b574f3ccfdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e16fb3b8412754508c3b574f3ccfdbc">&#9670;&nbsp;</a></span>subdivided_parallelepiped() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>(&amp;)&#160;</td>
          <td class="paramname"><em>n_subdivisions</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>corners</em>[dim], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个细分的平行四边形，即与上述相同，但每个 <code>dim</code> 方向上的细分数量可能不同。 着色是根据hyper_rectangle()进行的。 </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角图需要为空。 </dd></dl>

</div>
</div>
<a id="aa93a16355ace7092f5160b44cfeac767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93a16355ace7092f5160b44cfeac767">&#9670;&nbsp;</a></span>subdivided_parallelepiped() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_parallelepiped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdivisions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>对 <code>dim</code> 和 <code>spacedim</code>. 的所有组合实施。 </dd>
<dd>
你可能需要帮助编译器，在调用此函数时明确指定两个模板参数。 </dd></dl>

</div>
</div>
<a id="a2c537aebe22842ec22de2c8b5c545896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c537aebe22842ec22de2c8b5c545896">&#9670;&nbsp;</a></span>enclosed_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::enclosed_hyper_cube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>thickness</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>超立方体，周围有一层超立方体。参数 <code>left</code> 和 <code>right</code> 给出了所有坐标方向上的内超立方体的下限和上限。 <code>thickness</code> 标记了层单元的大小。 如果标志 <code>colorize</code> 被设置，外部单元根据以下方案获得材料ID：在（+/-）x方向1/2、y方向4/8、z方向16/32的内立方体上延伸。在角落和边缘（3D），使用一个比特OR操作来获得这些值，（也见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的术语条目</a> ）。 目前只有2d和3d版本可用。 </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="a533c4778cbc9bcbed365dcab42ca4418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533c4778cbc9bcbed365dcab42ca4418">&#9670;&nbsp;</a></span>hyper_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>attach_spherical_manifold_on_boundary_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>由于这可能是用户通常最早考虑的创建具有曲线边界的网格的函数之一，让我们也来评论一下经常令人困惑的一个方面。也就是说，人们看到的并不总是实际发生的情况。具体来说，如果你使用默认选项，用 <a class="el" href="classGridOut.html#a6b72484c35abc1f84abb8bf1bc1048dc">GridOut::write_vtk()</a> 这样的函数输出粗略的网格，那么人们一般不会看到边界上的曲面。 这是因为大多数文件格式默认只存储顶点位置，隐含的理解是单元由这些顶点组成，并以直边为界。同时，这个函数将SphericalManifold对象附加到边界面的事实意味着，至少在内部*，边缘确实是弯曲的。如果你想看到它们，你需要确保你用来输出网格的函数实际上是将边界面绘制成曲线，而不是仅由两个端点的位置来描述的直线。例如，如果你在 <a class="el" href="structGridOutFlags_1_1Gnuplot.html">GridOutFlags::Gnuplot</a> 结构中设置相应的标志， <a class="el" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">GridOut::write_gnuplot()</a> 就可以做到这一点。然而，你是否真的在曲线单元上进行计算*，这是一个完全独立的考虑。在典型的有限元计算中，我们必须计算积分，这些积分是通过使用参考单元的映射将实际单元转换回来计算的。使用什么样的映射决定了这些内部计算的单元的形状。例如，使用广泛使用的 \(Q_1\) 映射（隐含在 <a class="el" href="step_6.html">step-6</a> 中使用），积分总是发生在假定只有顶点位置描述的直线边界的单元上。换句话说，如果使用这样的映射，那么域的单元就真的有直的边缘，而不管这些边缘的流形描述如何，也不管生成输出时的标志是什么。综上所述，有必要区分三件事。(i)附加在网格中物体上的流形描述；(ii)用于集成的映射；以及(iii)用于输出网格图形信息的风格。所有这些都可以或多或少地独立选择，你所看到的可视化的东西不一定就是正在发生的。 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角形需要为空。 </dd></dl>

</div>
</div>
<a id="a1a07e4609d568267cab4a2f0414cd913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a07e4609d568267cab4a2f0414cd913">&#9670;&nbsp;</a></span>hyper_ball_balanced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_ball_balanced </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是一个替代hyper_ball的方法，在2D中使用12个单元，在3D中使用32个单元，这样可以更好地平衡外部弯曲边界周围的单元和内部的单元的大小。网格是基于 <a class="el" href="namespaceGridGenerator.html#a712f95340c7002afbd5d6fb755e12a61">GridGenerator::quarter_hyper_ball()</a> 所使用的单元，并进行适当的复制和旋转以填充整个球。 下面的图片显示了二维（左）和三维的网格结果： </p><table align="center" class="doxtable">
<tr>
<td> 
<style>div.image img[src="hyper_ball_balanced_2d.png"]{width:40%}</style>
 <div class="image">
<img src="hyper_ball_balanced_2d.png" alt="hyper_ball_balanced_2d.png"/>
</div>
  </td><td> <style>div.image
img[src="hyper_ball_balanced_3d.png"]{width:40%}</style>  <div class="image">
<img src="hyper_ball_balanced_3d.png" alt="hyper_ball_balanced_3d.png"/>
</div>
   </td></tr>
</table>
<p>默认情况下，manifold_id在边界面设置为0，在边界单元设置为1， <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> 在中心单元和内部面设置为1。 </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="a7e98b4b3cd47554a365b55d175338be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e98b4b3cd47554a365b55d175338be0">&#9670;&nbsp;</a></span>non_standard_orientation_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::non_standard_orientation_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rotate_left_square</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rotate_right_square</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>生成一个二维网格，该网格由单元格和一个移位 \(s = (1,0)\) 的副本组成。根据所传递的标志，右边或左边的正方形将被旋转 \(\pi/2\) 。这样就可以产生一个网格，其中一个正方形可能包含一个与另一个正方形的相邻边的切向（因此也是相反的法向）的边。 从实用的角度来看，这种网格并没有太大用处。出于调试的目的，它可以用来检查矢量或张量有限元的方向问题。 </p><dl class="section note"><dt>Note</dt><dd>如果 <code>rotate_left_square==rotate_right_square</code> 网格的方向一致。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tria</td><td>输入的三角剖面。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotate_left_square</td><td><code>true</code> 如果左边的正方形被旋转 \(\pi/2\) . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotate_right_square</td><td><code>true</code> 如果右边的正方形被 \(\pi/2\) 旋转。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7faa3e36d4333d03a3cc865142f3d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7faa3e36d4333d03a3cc865142f3d2f">&#9670;&nbsp;</a></span>non_standard_orientation_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::non_standard_orientation_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_flip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>face_rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>manipulate_left_cube</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>生成一个由单位立方体和一个移位 \(s = (1,0,0)\) 的副本组成的三维网格。根据所传递的标志，右边或左边的立方体（当看到正向的(x,z)平面时）包含一个不是标准方向的面和/或被 \(\pi/2\) , \(\pi\) 或 \(3/2\pi\) 旋转过的面。 从实用的角度来看，这个网格没有太大用处。出于调试的目的，它可以用来检查矢量或张量的有限元的方向问题。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">tria</td><td>输入的三角形网格。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_orientation</td><td><code>true</code> 如果该面不是标准方向。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_flip</td><td><code>true</code> 如果面被旋转+180度 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_rotation</td><td><code>true</code> 如果面被旋转（另外）+90度 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">manipulate_left_cube</td><td><code>true</code> 如果左侧立方体要被重新排序。如果<code>false</code>，则是右方的立方体。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2dc2f16fc52cf1e51b9afdc4264ac70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2dc2f16fc52cf1e51b9afdc4264ac70">&#9670;&nbsp;</a></span>hyper_sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_sphere </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; spacedim - 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;spacedim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个超球体，即在 <code>spacedim</code> 维度上的球的表面。这个函数只存在于dim+1=spacedim的2和3空间维度。(要创建一个球的网格，请使用 <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>.) 默认情况下，三角形的所有流形id被设置为零，并且一个SphericalManifold被附加到网格上。 下面的图片是用以下方法生成的。 </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2,3&gt;</a>   <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ab2dc2f16fc52cf1e51b9afdc4264ac70">GridGenerator::hyper_sphere</a>(triangulation);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div></div><!-- fragment --><p> 参见 <a class="el" href="group__manifold.html">流形的文件模块</a> ，以了解更多细节。 </p><div class="image">
<img src="sphere.png" alt="sphere.png"/>
<div class="caption">
html</div></div>
<p> sphere_section.png </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="a712f95340c7002afbd5d6fb755e12a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712f95340c7002afbd5d6fb755e12a61">&#9670;&nbsp;</a></span>quarter_hyper_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::quarter_hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数产生一个与相对于 <code>center</code>, 的正交的超球体，它包含了2d的三个元素和3d的四个元素。网格的内部点的选择是为了平衡内部点周围的单元中从参考坐标到实坐标的映射的最小单值，这相当于一个高的网格质量。 最终三角化的边界指标是：曲线边界为0，切割面为1。弯曲边界的流形ID被设置为0，并且一个SphericalManifold被附加到它。 由此产生的二维和三维网格看起来如下。 </p><table align="center" class="doxtable">
<tr>
<td> <style>div.image
img[src="quarter_hyper_ball_2d.png"]{width:50%}</style>  <div class="image">
<img src="quarter_hyper_ball_2d.png" alt="quarter_hyper_ball_2d.png"/>
</div>
  </td><td> <style>div.image
img[src="quarter_hyper_ball_3d.png"]{width:46%}</style>  <div class="image">
<img src="quarter_hyper_ball_3d.png" alt="quarter_hyper_ball_3d.png"/>
</div>
   </td></tr>
</table>
<dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="af218d0939daf0732e3b507a27ea5d8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af218d0939daf0732e3b507a27ea5d8e3">&#9670;&nbsp;</a></span>half_hyper_ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::half_hyper_ball </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;&#160;dim&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数在 <code>center</code>, 周围产生一个半超球，它在2d中包含4个元素，在3d中包含6个。切割面垂直于<em>x</em>轴。 最终三角化的边界指标为：弯曲边界为0，切割面为1。弯曲边界的流形ID被设置为0，并且一个SphericalManifold被连接到它。 </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角剖面需要为空。 </dd></dl>

</div>
</div>
<a id="a5cdda7b4a76d509af7d1a8dc1320ddb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdda7b4a76d509af7d1a8dc1320ddb0">&#9670;&nbsp;</a></span>cylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个 <code>dim</code> 维圆柱体，其中 \(x\) -轴作为圆柱体的轴。在这个函数中，圆柱体被定义为一个（ <code>dim</code> ）。</p>
<p>-1）维的圆盘，其给定的 <code>radius</code>, 沿着圆柱体的轴线（即第一坐标方向）挤压。因此，在三维空间中，圆柱体从<code>x=-半长</code>延伸到<code>x=+半长</code>，它在 <code>yz-plane</code> 的投影是一个半径为 <code>的圆。在二维空间中，圆柱体是一个从<code>x=-半长</code>到<code>x=+半长</code>，从<code>y=-半径</code>到<code>y=半径</code>的矩形。</code> 边界按照以下方案着色：0代表圆柱体的外壳，1代表左手面，2代表右手面（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的术语条目</a> ）。 圆柱体外壳的流形ID被设置为0，并将一个CylindricalManifold连接到它。 </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="a95f6e6a7ae2fe3a862df035dd2cb4467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f6e6a7ae2fe3a862df035dd2cb4467">&#9670;&nbsp;</a></span>subdivided_cylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_cylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>x_subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个 <code>dim</code> 维圆柱体，其中 \(x\) -轴作为圆柱体的轴。在本函数中，圆柱体被定义为一个（ <code>dim</code> ）。</p>
<p>-1）的维度盘，其给定的 <code>radius</code>, 沿着圆柱体的轴线（即第一坐标方向）挤压。因此，在三维空间中，圆柱体从<code>x=-半长</code>延伸到<code>x=+半长</code>，它在 <code>yz-plane</code> 的投影是一个半径为 <code>的圆。在二维空间中，圆柱体是一个从<code>x=-半长</code>到<code>x=+半长</code>，从<code>y=-半径</code>到<code>y=半径</code>的矩形。这个函数只在dim==3时实现。</code> 边界按照以下方案着色：0代表圆柱体的外壳，1代表左手面，2代表右手面（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇表条目</a> ）。 圆柱体的流形ID被设置为0，并将一个CylindricalManifold连接到它。 </p><div class="image">
<img src="subdivided_cylinder_3D.png" alt="subdivided_cylinder_3D.png"/>
<div class="caption">
tria</div></div>
<p> 要创建的三角剖面。在调用此函数时，它需要是空的。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_subdivisions</td><td>一个正整数，表示在x方向上生成的单元的数量。默认圆柱体的x_repetitions=2。 </td></tr>
    <tr><td class="paramname">radius</td><td>用于挤出圆柱体的YZ平面上的圆的半径。 </td></tr>
    <tr><td class="paramname">half_length</td><td>圆柱体在x方向的半长。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae63c93351f77276c20de07c91d3c1e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63c93351f77276c20de07c91d3c1e48">&#9670;&nbsp;</a></span>truncated_cone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::truncated_cone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius_0</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>radius_1</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>half_length</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>围绕x轴创建一个切割锥体。 该圆锥体从<code>x=-半长</code>延伸到<code>x=半长</code>，其在 <code>yz-plane</code> 的投影是在<code>x=半长</code>处半径为 <code>radius_0</code> 的圆和在<code>x=+半长</code>处半径为 <code>radius_1</code> 的圆。在这两者之间，半径是线性递减的。 在二维空间中。圆锥体是一个梯形，从<code>x=-半长</code>到<code>x=+半长</code>，从<code>y=-半径_0</code>到<code>y=半径_0</code>在<code>x=-半长</code>，从<code>y=-半径_1</code>到<code>y=半径_1</code>在<code>x=+半长&gt;。 在这之间，<code>y</code>的范围是线性递减的。 边界按照以下方案着色：0代表圆锥体，1代表左手面，2代表右手面（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的术语条目</a> ）。 边界指标和流形指标都被设定。 在三维空间中，船体的流形指标被设置为零，并且一个CylindricalManifold被附加到它上面。 下面是两次网格细化后的二维和三维网格。 </p><div class="image">
<img src="truncated_cone_2d.png" alt="truncated_cone_2d.png"/>
<div class="caption">
html truncated_cone_3d.png </div></div>
<p> 调用此函数时，作为参数传递的三角结构需要为空。 </code></p>

</div>
</div>
<a id="a04f98a456ca1942a071d3a20ef5b4dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f98a456ca1942a071d3a20ef5b4dbe">&#9670;&nbsp;</a></span>hyper_cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>一个中心单元，每个表面都有堆积的单元突出。 每个正方形网格单元都是笛卡尔的，在每个坐标方向都有一个大小。零号单元的中心是原点。 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>一个三角形对象，必须是空的。 </td></tr>
    <tr><td class="paramname">sizes</td><td>一个维度为 <a class="el" href="structGeometryInfo.html#a5d3e48d5e97a217c149a33c0b42a51c2">GeometryInfo&lt;dim&gt;::faces_per_cell</a> 的整数向量，其含义如下：十字形的腿在中心单元格的面上堆叠，按照deal.II单元格的通常顺序，即首先是 \(-x\) ，然后是 \(x\) ，然后是 \(-y\) 等等。在 <code>sizes</code> 中的相应条目命名了堆积在这个面上的单元格的数量。所有的数字都可能是零，因此L型和T型域是这个域的特化。 </td></tr>
    <tr><td class="paramname">colorize_cells</td><td>如果着色被启用，那么一个单元格的材料ID就对应于它所在的腿。中心单元的id为0，然后各腿从1开始编号（参见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的术语条目</a> ）。 二维和三维的例子是。 <div class="image">
<img src="hyper_cross_2d.png" alt="hyper_cross_2d.png"/>
<div class="caption">
html hyper_cross_3d.png 。</div></div>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b2a4ad8296c2b72a11d23b5969e8cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2a4ad8296c2b72a11d23b5969e8cc0">&#9670;&nbsp;</a></span>hyper_L()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_L </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>-1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用一个恰好由<code>2^dim-1</code>单元组成的超L（2D或3D）初始化给定的三角结构。它产生的超立方体的区间[<em>left,right</em>]没有每个坐标的区间[<em>(left+right)/2,right</em>]做出来的超立方体。因为该域是大约最简单的一个有重心（即非凸）角的域，许多偏微分方程的解在这个角有奇点。也就是说，在拐角处，梯度或高阶导数（取决于所选择的边界条件）并不保持有界。因此，当溶液缺乏规律性时，这个域经常被用来测试方案的收敛性。 如果 <code>colorize</code> 的标志是 <code>true</code> ，则曲面的 <code>boundary_ids</code> 被分配为左边的边界为0，其他的则按逆时针升序分配（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇条</a> ）。 <code>着色选项只在二维空间工作。</code> 这个函数将在二维中创建经典的L形，在三维中看起来就像下面这样。 </p><div class="image">
<img src="hyper_l.png" alt="hyper_l.png"/>
</div>
 <dl class="section note"><dt>Note</dt><dd>3d域也经常被称为 "Fichera角"，这是以Gaetano Fichera（1922-1996）命名的，他首次计算了域的最低特征函数的角奇异指数的近似值。 这个函数存在于所有空间维度的三角形中，但如果在1d中调用，则会产生错误。 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角形需要为空。 </dd></dl>

</div>
</div>
<a id="aab74ba287a243b478588be824ad65ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab74ba287a243b478588be824ad65ba6">&#9670;&nbsp;</a></span>subdivided_hyper_L()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::subdivided_hyper_L </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>repetitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>top_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>n_cells_to_remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在二维或三维中用广义的细分超L来初始化给定的三角结构。 这个函数产生一个细分的超矩形，其尺寸由 <code>bottom_left</code> 和 <code>top_right</code>, 给出，每个方向上的细分数量由向量 <code>repetitions</code>, 给出，并去除一定数量的单元格，由向量 <code>n_cells_to_remove</code>. 给出。注意， <code>n_cells_to_remove</code> 包含整数，意味着其条目可以是正数和负数。正数表示在 "正 "的方向切割细胞，例如在X方向从左到右，在Y方向从下到上，在Z方向从前到后。负数表示以相反的方向切割单元，如从右到左，从上到下，从后到前。 这个网格的演示可以在 step-75 中找到。 这个函数可以用来生成一个面向后方的网格，这是一个对流体动力学基准问题有用的领域。 第一张图片是一个3D的后向台阶，通过去除z方向的所有单元，以及正x和y方向的2个单元而生成。 </p><div class="image">
<img src="subdivided_hyper_L_3d.png" alt="subdivided_hyper_L_3d.png"/>
<div class="caption">
而在二维中，我们可以剪去负x方向的1个单元，负y方向的2个单元。  html subdivided_hyper_L_2d.png</div></div>
 <dl class="section note"><dt>Note</dt><dd>这个函数被声明存在于所有空间维度的三角形中，但如果在一维中调用则会产生错误。 </dd></dl>

</div>
</div>
<a id="a5114625911496e4f51758fe00562a14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5114625911496e4f51758fe00562a14a">&#9670;&nbsp;</a></span>hyper_cube_slit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube_slit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>left</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>right</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用一个带狭缝的超立方体初始化给定的三角测量。在每个坐标方向上，超立方体从 <code>left</code> 延伸到 <code>right</code>. 。 在2D中，分割在垂直方向上从<code>x=(left+right)/2, y=left</code>到广场中心<code>x=y=(left+right)/2</code>。 在3D中，2D域只是在<em>z</em>方向延伸，这样一个平面将矩形的下半部分一分为二。 这个函数被声明存在于所有空间维度的三角形中，但如果在1d中调用，会抛出一个错误。 如果 <code>colorize</code> 被设置为 <code>true</code>, ，形成狭缝的面将分别被标记为边界id 1和2（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇条</a> ）。 </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="ad85de345ccd86a53e63746709c8e1dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85de345ccd86a53e63746709c8e1dfc">&#9670;&nbsp;</a></span>hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>产生一个超壳，即围绕<code>中心</code>的两个球体之间的区域，给定<code>内半径</code>和<code>外半径</code>。数字<code>n_cells</code>表示所产生的三角形的单元数，即有多少单元构成环（在2D）或壳（在3D）。 如果标志 <code>colorize</code> 是 <code>true</code> ，那么外边界将有指标1，而内边界的id为0。在三维中，这同时适用于这些边界的面和边。如果标志是 <code>false</code>, ，则两者的指标都是0（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇条</a>）。 所有流形的id都被设置为零，并且一个SphericalManifold被附加到三角形的每个单元和面。 在2d中，这个初始三角形的元素数量<code>n_cells</code>可以任意选择。如果初始单元的数量为零（默认情况下），那么它将被自适应地计算，从而使生成的元素具有最小的长宽比。 在3D中，只有某些数字是允许的。 </p><ul>
<li>
6（或默认的0）用于基于六面体的曲面（即在内球面上的6个面板沿径向挤压形成6个单元）， </li>
<li>
12用于菱形十二面体， </li>
<li>
] 24个为基于六面体的表面，在方位角方向上精炼一次，但不在径向方向上精炼， </li>
<li>
48个为菱形十二面体，在方位角方向上精炼一次，但不在径向方向上精炼， </li>
<li>
96个为菱形十二面体精炼一次。这个选择可以追溯到Manifold类实现之前的旧版本deal.II：今天这个选择等同于执行一次全局细化后的菱形十二面体。 </li>
<li>
\(192\times 2^m\) 类的数字与 \(m\geq 0\) 的整数。这种选择与24和48单元的情况类似，但提供了方位角方向的额外细化与径向方向的单层细化相结合。基本网格是6个或12个单元的版本，分别取决于权力中的 \(m\) 是奇数还是偶数。 </li>
</ul>
<p>24、48和 \(2^m 192\) 单元的版本在壳薄而径向长度应与周向长度更相似的情况下是有用的。 下面是12和96单元的三维网格图。 </p><div class="image">
<img src="hypershell3d-12.png" alt="hypershell3d-12.png"/>
<div class="caption">
html hypershell3d-96.png 。</div></div>
 <dl class="section note"><dt>Note</dt><dd>这个函数被声明存在于所有空间维度的三角形中，但如果在1d中调用则会抛出一个错误。 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角形需要为空。 </dd></dl>

</div>
</div>
<a id="a54f3256a8eccaaa366a9cca918a585ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f3256a8eccaaa366a9cca918a585ed">&#9670;&nbsp;</a></span>eccentric_hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::eccentric_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>outer_center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>产生一个偏心的超壳，即以两个不同中心点为中心的两个球体之间的区域。我们必须指定<code>inner_center</code>和<code>outer_center</code>，并给出<code>inner_radius</code>和<code>outer_radius</code>。数字<code>n_cells</code>表示所产生的三角形的单元数，也就是说，有多少单元构成环（在2D）或壳（在3D）。 默认情况下，外边界的指标为1，而内边界的指标为0。在三维中，这适用于这些边界的面和边。 一个SphericalManifold连接到外边界，ID为1，而另一个SphericalManifold连接到内边界，ID为0。一个TransfiniteInterpolationManifold连接到三角形的所有其他单元和面，ID为2。这里，元素的数量<code>n_cells</code>与 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>. 中的含义相同。 </p><div class="image">
<img src="eccentric_hyper_shell_2D.png" alt="eccentric_hyper_shell_2D.png"/>
<div class="caption">
html eccentric_hyper_shell_3D.png 。</div></div>
 <dl class="section note"><dt>Note</dt><dd>因为它使用了超壳的定义，这个函数被声明为存在于所有空间维度的三角形中，但如果在1d中调用，会抛出一个错误。 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角形需要为空。 </dd></dl>

</div>
</div>
<a id="a6f31aa1d176dd99c2183efdb4b9cb5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f31aa1d176dd99c2183efdb4b9cb5f5">&#9670;&nbsp;</a></span>half_hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::half_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>产生一个半超壳，即两个空间维度中两个圆之间的空间和三维中两个球体之间的区域，对于这个初始三角剖面，具有给定的内外半径和给定的元素数。 然而，与前一个函数相反，它并不产生整个壳，而只是产生它的一半，即第一分量被限制为非负值的那部分。这个函数的目的是为了能够计算具有旋转对称性的解决方案，在这种情况下，2D的半壳代表3D的壳。 如果2d中初始单元 <code>n_cells</code> 的数量为零（默认值），那么它将被自适应地计算，从而使得到的元素具有最小的长宽比。这个参数在3D中被忽略，在3D中粗略的网格总是有5个单元。 如果colorize设置为 <code>true</code> ，内部、外部和边界 \(x=0\) 的部分分别得到指标0、1和2。此外，在2d中，边界指标3被赋予X轴以下的垂直边缘。否则，如果colorize设置为 <code>false</code> ，所有指标都被设置为0（见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇表条目</a> ）。 所有流形ID都被设置为0，并将SphericalManifold附加到三角剖面上。 </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="acd7c51b0e8032db65db9a5ff73ccca50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7c51b0e8032db65db9a5ff73ccca50">&#9670;&nbsp;</a></span>quarter_hyper_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::quarter_hyper_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>产生一个域，该域是具有给定内半径和外半径的超壳之间的交点，即两个空间维度中两个圆之间的空间和三维中两个球体之间的区域，以及正象限（在2d中）或八角形（在三维）。在2D中，这确实是全环形的四分之一，而在3D中，这个函数是一个错误的名称，因为在那里，域不是四分之一，而是全壳的八分之一。 如果初始单元的数量为零（默认情况下），那么它是自适应计算的，这样得到的元素具有2d中最小的长宽比。 如果 <code>colorize</code> 被设置为 <code>true</code> ，内、外、左、右边界分别得到2d中的指标0、1、2和3。在3D中，指标2位于面 \(x=0\) ，3位于 \(y=0\) ，4位于 \(z=0\) （见 <a class="el" href="DEALGlossary.html#GlossColorization">关于着色的词汇条</a> ）。 所有流形的id都被设置为零，并将一个SphericalManifold附加到三角结构上。 </p><dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角结构需要为空。 </dd></dl>

</div>
</div>
<a id="a760789a93b1e0fe7f5c2675c31b6f14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760789a93b1e0fe7f5c2675c31b6f14f">&#9670;&nbsp;</a></span>cylinder_shell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::cylinder_shell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_radial_cells</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_axial_cells</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>产生一个域，该域是3D中两个圆柱体之间的空间，具有给定的长度、内半径和外半径以及给定的元素数量。圆柱体外壳围绕 \(z\) 轴建立，两个面位于 \(z = 0\) 和 \(z = \) <code>length</code>. 如果 <code>n_radial_cells</code> 为零（默认值），那么它将被自适应地计算，使生成的元素具有最小的纵横比。对于 <code>n_axial_cells</code>. 也是如此。 </p><dl class="section note"><dt>Note</dt><dd>虽然这个函数被声明为模板，但它在一维和二维中没有意义。同时请记住，这个对象的旋转和定位与圆柱体（）创建的对象不同。 所有流形的id都被设置为零，并且一个CylindricalManifold被附加到三角形中。 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>调用此函数时，作为参数传递的三角剖面需要为空。 <div class="image">
<img src="cylinder_shell.png" alt="cylinder_shell.png"/>
<div class="caption">
在这张图片中，显示了一个长度为2，内半径为0.5，外半径为1的圆柱体外壳。使用了n_radial_cells和n_axial_cells的默认参数，进行了一次全局细化。</div></div>
 </dd></dl>

</div>
</div>
<a id="a7e99c2ee8ac3332b50baa028b7ded526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e99c2ee8ac3332b50baa028b7ded526">&#9670;&nbsp;</a></span>torus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::torus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells_toroidal</em> = <code>6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>phi</em> = <code>2.0&#160;*<a class="el" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>生成环状体的体积或表面网格。环状体的轴是 \(y\) -轴，而环状体的平面是 \(x\) - \(z\) 平面。 如果 <code>dim</code> 是3，网格将是环状体的体积，使用相当于圆的极坐标的网格，横截面上有5个单元。这个函数为所有边界面附加了一个环形Manifold，其流形ID为1；为内部单元及其所有面附加了一个CylindricalManifold，其流形ID为2（代表极坐标中的平面状态）；为表面的环形Manifold和中心的环形Manifold之间的单元附加了一个TransfiniteInterpolationManifold，其流形ID为0。 ]为3，在 \(z=0\) 处切开域，6个环形单元， \(R=2\) 和 \(r=0.5\) 没有任何全局细化的情况下，在此给出。 </p><div class="image">
<img src="torus_manifold_ids.png" alt="torus_manifold_ids.png"/>
<div class="caption">
在这张图片中，浅灰色的阴影代表了无限插值的流形id 0，它被应用于在域边界上的环形形状和内缘之间平滑地添加新的点，在那里围绕y轴的圆柱形描述被规定。具有流形id 2的内缘显示为红色阴影。 如果 <code>dim</code> 为2，网格将描述环形的表面，这个函数将TorusManifold附加到所有的单元和面（这些单元和面的流形id标记为0）。  tria 要填充的三角结构。  R 圆的半径，它构成了包含单元格环的环形的中间线。必须大于 <code>r</code>.  r 环状体的内半径。  n_cells_toroidal 可选参数，用于设置环形方向的细胞层数。默认为6个细胞层。  phi 可选参数，用于生成角度为 \(r=0.5\)#1265 的开放环形。默认值是 \(r=0.5\)#1266 ，在这种情况下会生成一个封闭的环形体。如果环状体是开放的，环状体将在垂直于环状体中心线的两个平面上被切割。 这两个平面的中心位于 \(r=0.5\)#1267 和 \(r=0.5\)#1268 。</div></div>
 <dl class="section note"><dt>Note</dt><dd>为Triangulation&lt;2,3&gt;和Triangulation&lt;3,3&gt;实现。 </dd></dl>

</div>
</div>
<a id="add14cab546d033c1eaacc9234c64ebcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add14cab546d033c1eaacc9234c64ebcd">&#9670;&nbsp;</a></span>hyper_cube_with_cylindrical_hole()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::hyper_cube_with_cylindrical_hole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em> = <code>.25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em> = <code>.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>L</em> = <code>.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>repetitions</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数在<em>xy</em>平面上产生一个正方形，中间有一个圆柱形的孔。正方形和圆形都以原点为中心。在三维空间中，这个几何体沿 \(z\) 方向被挤压到区间 \([0,L]\) 。 内边界的流形ID为 \(0\) ，边界ID为 \(6\) 。这个函数将一个PolarManifold或CylindricalManifold分别附着在2d和3d的内部边界上。其他面的边界ID为 \(0, 1, 2, 3, 4\) ，或 \(5\) ，按照2d或3d中面的标准顺序给出。 </p><div class="image">
<img src="cubes_hole.png" alt="cubes_hole.png"/>
<div class="caption">
它在2d和3d中实现，并接受以下参数。  triangulation 要填充的三角结构。  inner_radius 内部孔的半径。  outer_radius 正方形边长的一半。  L 在 <code>z-direction</code> 中的扩展（只在3D中使用）。  repetitions 沿着 <code>z-direction</code>.  colorize 是否给不同的面分配不同的边界指标（见  GlossColorization "关于着色的词汇表条目"</div></div>
<p> ）。 颜色是以词法排序给出的，平坦的面（2D中的0到3，3D中的0到5）加上弯曲的孔（2D中的4，3D中的6）。如果 <code>colorize</code> 被设置为false，那么平面就会得到数字0，孔就会得到数字1。 </p>

</div>
</div>
<a id="abfcc142a9fc905a1abec9315693a57d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfcc142a9fc905a1abec9315693a57d4">&#9670;&nbsp;</a></span>concentric_hyper_shells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::concentric_hyper_shells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>inner_radius</em> = <code>0.125</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>outer_radius</em> = <code>0.25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_shells</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>skewness</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells_per_shell</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>colorize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>生成一个由同心壳组成的网格。这个函数和 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> 的主要区别是，这个函数允许不均匀的间隔（在径向方向） <a class="el" href="DEALGlossary.html#GlossCoarseMesh">粗级单元</a> 。 参数 <code>center</code>, <code>inner_radius</code>, 和 <code>outer_radius</code> 的行为与 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>. 的前三个参数相同 <code>n_shells</code> 给出了要使用的壳的总数（即径向上的单元数）。 \(k\) 第1个壳的外半径由 </p><p class="formulaDsp">
\[ r = r_{\mathrm{inner}} + (r_\mathrm{outer} - r_\mathrm{inner}) \frac{1 - \tanh(\mathrm{skewness}(1 - k/\mathrm{n\_shells}))} {\tanh(\mathrm{skewness})} \]
</p>
<p>给出，其中 <code>skewness</code> 是控制径向方向上壳间距的参数： <code>skewness</code> 接近零的值对应于均匀的间距，而 <code>skewness</code> 的较大值（如 \(2\) 或 \(3\) ）对应于偏重于内半径的壳体。 <code>n_cells_per_shell</code> 与 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>: 相同，在2D中默认选择为0，将导致每个壳有8个单元（在3D中为12个）。3d中唯一有效的值是6（默认值）、12和96个单元：更多信息见 <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> 的文档。 如果 <code>colorize</code> 是 <code>true</code> ，那么合并后的壳的外部边界的边界ID为 \(1\) ，内部边界的边界ID为 \(0\) 。 例子。以下代码（关于如何可视化GNUPLOT输出的说明，请参见 <a class="el" href="step_10.html">step-10</a> ) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__generic_8h.html">deal.II/fe/mapping_q_generic.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#abfcc142a9fc905a1abec9315693a57d4">GridGenerator::concentric_hyper_shells</a>(triangulation,</div><div class="line">                                       <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(),</div><div class="line">                                       1.0,</div><div class="line">                                       2.0,</div><div class="line">                                       5u,</div><div class="line">                                       2.0);</div><div class="line"></div><div class="line"><a class="code" href="classGridOut.html">GridOut</a> grid_out;</div><div class="line"><a class="code" href="structGridOutFlags_1_1Gnuplot.html">GridOutFlags::Gnuplot</a> gnuplot_flags(<span class="keyword">false</span>, 10, <span class="keyword">true</span>);</div><div class="line">grid_out.<a class="code" href="classGridOut.html#a239955214cc9b881e9eb66053564d5d5">set_flags</a>(gnuplot_flags);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;2&gt;</a> mapping(3);</div><div class="line">std::ofstream out(<span class="stringliteral">&quot;out.gpl&quot;</span>);</div><div class="line">grid_out.<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a>(triangulation, out, &amp;mapping);</div><div class="line">}</div></div><!-- fragment --><p> 产生以下输出。 </p><div class="image">
<object type="image/svg+xml" data="concentric_hyper_shells_2d.svg">concentric_hyper_shells_2d.svg</object>
</div>
 
</div>
</div>
<a id="a626225354aa3f249f64dc67319e34bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626225354aa3f249f64dc67319e34bf8">&#9670;&nbsp;</a></span>moebius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::moebius </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_rotations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在3D中产生一个细胞环，将其切开、扭曲并再次粘在一起。这就产生了一种莫比乌斯环。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>要处理的三角结构。 </td></tr>
    <tr><td class="paramname">n_cells</td><td>循环中的单元数。必须大于4。 </td></tr>
    <tr><td class="paramname">n_rotations</td><td>在胶合循环之前要进行的旋转次数（ \(\pi/2\) 每次）。 </td></tr>
    <tr><td class="paramname">R</td><td>圆的半径，它构成了包含细胞环的环状体的中间线。必须大于 <code>r</code>. </td></tr>
    <tr><td class="paramname">r</td><td>圆柱体弯曲在一起作为环的半径。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e6c4dcc63863449f08a78a22ec73747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6c4dcc63863449f08a78a22ec73747">&#9670;&nbsp;</a></span>generate_from_name_and_arguments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::generate_from_name_and_arguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>grid_generator_function_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>grid_generator_function_arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用其他GridGenerator函数之一，从字符串 <code>grid_generator_function_name</code>, 中解析要调用的函数名称，从字符串 <code>grid_generator_function_arguments</code>. 中解析函数的参数，提供参数的字符串被传递给函数 <a class="el" href="structPatterns_1_1Tools_1_1Convert.html#aad1e7362c24708ef3a82171e4c59da13">Patterns::Tools::Convert&lt;TupleTyple&gt;::to_value()</a>, ，这里的<code>TupleType</code>是一个元组，包含*所有**GridGenerator函数的参数，包括所有可选参数。 这个函数的一个使用例子是由。 </p><div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#a1e6c4dcc63863449f08a78a22ec73747">GridGenerator::generate_from_name_and_arguments</a>(</div><div class="line">tria,</div><div class="line"><span class="stringliteral">&quot;hyper_ball&quot;</span>,</div><div class="line"><span class="stringliteral">&quot;0.0, 0.0 : 1 : false&quot;</span>);</div></div><!-- fragment --><p> 这里，冒号分隔了函数参数，逗号分隔了一个Point&lt;2&gt;参数的坐标。 根据<code>TupleType</code>的算数，函数的参数可以用不同的分隔符来分隔（关于如何进行转换的细节，请参见 <a class="el" href="classPatterns_1_1Tuple.html">Patterns::Tuple</a> 的文档）。如果使用了错误的格式，会抛出一个异常，并将预期的格式作为错误信息输出。 所有的GridGenerator函数都被支持。如果你发现有一些缺失，请在GitHub上开一个问题。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>要处理的三角形 </td></tr>
    <tr><td class="paramname">grid_generator_function_name</td><td>要调用的函数的名称 </td></tr>
    <tr><td class="paramname">grid_generator_function_arguments</td><td>函数的参数，格式为可转换元组的字符串 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="grid__generator__from__name_8cc_source.html#l00327">327</a> of file <a class="el" href="grid__generator__from__name_8cc_source.html">grid_generator_from_name.cc</a>.</p>

</div>
</div>
<a id="a7cd88e7eacd46697dee80ad2b8438d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd88e7eacd46697dee80ad2b8438d54">&#9670;&nbsp;</a></span>merge_triangulations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::merge_triangulations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>duplicated_vertex_tolerance</em> = <code>1.0e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出作为前两个参数指定的两个三角形，创建包含两个三角形的单元的三角形，并将其存储在第三个参数中。之前 <code>result</code> 的内容将被删除。 两个输入三角图中的一个也可以是 <code>result</code> 三角图。 如果几何体可以由较简单的部分组成，而这些部分存在生成 <a class="el" href="DEALGlossary.html#GlossCoarseMesh">粗略网格 </a> 的函数，那么这个函数最常被用来为更复杂的几何体组成网格。例如， <a class="el" href="step_35.html">step-35</a> 中使用的通道网格原则上可以用 <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> 函数创建的网格和几个矩形来创建，并使用当前函数将它们合并。矩形必须向右平移，这个任务可以用 <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> 函数来完成（其他转换单个网格构件的工具有 <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, <a class="el" href="namespaceGridTools.html#a910bb99ec34eac082da97c08e7dd17c3">GridTools::rotate</a>, 和 <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>). 相距小于 <code>duplicated_vertex_tolerance</code> 的顶点会被合并在一起。通常有必要将这个值设置为在某种程度上取决于输入三角形的东西。一个合理的选择是使用输入网格的所有相邻顶点之间的最小距离除以某个常数。 </p><div class="fragment"><div class="line"><span class="keyword">auto</span> min_line_length = [](<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;tria)</div><div class="line"></div><div class="line">-&gt; <span class="keywordtype">double</span></div><div class="line">{</div><div class="line"><span class="keywordtype">double</span> length = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : tria.active_cell_iterators())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; GeometryInfo&lt;dim&gt;::lines_per_cell; ++n)</div><div class="line">    length = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(length, (cell-&gt;line(n)-&gt;vertex(0)</div><div class="line"></div><div class="line">-</div><div class="line">                               cell-&gt;line(n)-&gt;vertex(1)).<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line"><span class="keywordflow">return</span> length;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> tolerance = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_line_length(triangulation_1),</div><div class="line">                                min_line_length(triangulation_2)) / 2.0;</div></div><!-- fragment --><p> 这将合并任何比输入网格上任何一对顶点更接近的顶点。 </p><dl class="section note"><dt>Note</dt><dd>两个输入三角形必须是 <a class="el" href="DEALGlossary.html#GlossCoarseMesh">粗略网格</a> ，即不能有任何细化单元。 </dd>
<dd>
该函数将两个输入三角形的单元的材料ID复制到输出三角形中。如果 <code>copy_manifold_ids</code> 被设置为 <code>true</code>, ，流形id将被复制。边界指标永远不会被复制。换句话说，如果两个粗略的网格除了默认的边界指示器之外还有其他的东西，那么你将不得不在输出的三角图中重新手工设置边界指示器。 </dd>
<dd>
该函数不会将任何流形附加到 <code>result</code>, ，也不会设置任何流形ID。特别是，附加到两个输入三角形的流形将在 <code>result</code> 三角形中丢失。 </dd>
<dd>
当两个网格都来自同一个粗网格时，对细化网格的相关操作，见 <a class="el" href="namespaceGridGenerator.html#a843fe2c5c77374c51fcd18f05690b902">GridGenerator::create_union_triangulation()</a>. 。 </dd></dl>

</div>
</div>
<a id="a860c7b922eaac094ca4acd506c60ad6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860c7b922eaac094ca4acd506c60ad6f">&#9670;&nbsp;</a></span>merge_triangulations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::merge_triangulations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>duplicated_vertex_tolerance</em> = <code>1.0e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但允许一次合并两个以上的三角形。 下面给出一个如何使用这个函数的例子。 </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria_1, tria_2, tria_3;</div><div class="line"><span class="comment">// initialize tria_1, tria_2 and tria_3</span></div><div class="line">...</div><div class="line"><a class="code" href="classTriangulation.html#a67f431ce66c6df985caf5587bf329ebc">Triangulation</a>&lt;2&gt; merged_triangulation;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>({&amp;tria_1, &amp;tria_2, &amp;tria_3},</div><div class="line">                                    merged_triangulation,</div><div class="line">                                    1.0e-10,</div><div class="line">                                    <span class="keyword">false</span>);</div></div><!-- fragment --> 
</div>
</div>
<a id="a31cde6da3b561768a26f6c531cc93c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cde6da3b561768a26f6c531cc93c48">&#9670;&nbsp;</a></span>replicate_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::replicate_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replicate a given triangulation in multiple coordinate axes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The triangulation which will be replicated along the coordinate axes. </td></tr>
    <tr><td class="paramname">extents</td><td>一个带有<code>dim</code>项的向量，指定沿每个坐标轴应存在多少个三角形的副本。 </td></tr>
    <tr><td class="paramname">result</td><td>要创建的三角剖面。调用此函数时，它需要为空。 这个函数创建一个新的三角形，等于一个<code>dim</code>-dimensional array of copies of <code>input</code>. <code>input</code> 的副本是通过沿坐标轴平移 <code>input</code> 创建的。面的边界ID（但不是3D中的线）和所有流形ID都被复制，但流形对象没有被复制，因为大多数流形对象在Triangulation被平移后不能正确工作。 为了了解这一点，请考虑以下代码。 <div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> input;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(input);</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> output;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a31cde6da3b561768a26f6c531cc93c48">GridGenerator::replicate_triangulation</a>(input, {3, 2}, output);</div></div><!-- fragment --> 结果是 <div class="image">
<img src="replicated_tria_2d.png" alt="replicated_tria_2d.png"/>
<div class="caption">
而且，类似地，在三维中。</div></div>
 <div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> input;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a04f98a456ca1942a071d3a20ef5b4dbe">GridGenerator::hyper_cross</a>(1, 1, 1, 2, 1, 2);</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> output;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a31cde6da3b561768a26f6c531cc93c48">GridGenerator::replicate_triangulation</a>(input, {3, 2, 1}, output);</div></div><!-- fragment --> 结果是 <div class="image">
<img src="replicated_tria_3d.png" alt="replicated_tria_3d.png"/>
<div class="caption">
。</div></div>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>这个函数根据 <code>input</code>. 的BoundingBox确定 <code>input</code> 副本的间距。 如果 <code>input</code> 的边界面没有与坐标轴对齐，那么这些副本可能不会有共同的面；也就是说，这个函数是针对边界面沿坐标轴对齐的简单几何图形。 </dd></dl>

</div>
</div>
<a id="a843fe2c5c77374c51fcd18f05690b902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843fe2c5c77374c51fcd18f05690b902">&#9670;&nbsp;</a></span>create_union_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::create_union_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出作为前两个参数指定的两个三角形，创建包含两个三角形中最细单元的三角形，并将其存储在第三个参数中。之前 <code>result</code> 的内容将被删除。 </p><dl class="section note"><dt>Note</dt><dd>这个函数的目的是创建一个自适应细化的三角剖面，该三角剖面包含了从<em>same</em> <a class="el" href="DEALGlossary.html#GlossCoarseMesh">粗网格 </a> 中通过自适应细化得到的两个输入三角剖面。当人们在同一领域的单独细化网格上求解一个耦合问题的两个变量时（例如，因为这些变量在不同的地方有边界层），但随后需要计算涉及这两个变量的东西，或者希望将结果输出到一个文件中，有时需要这样的操作。在这两种情况下，为了不丢失信息，这两个解不能分别内插到其他网格上，因为那可能比计算变量的网格更粗。相反，我们需要有一个至少和两个初始网格一样精细的网格。这个函数可以计算出这样的网格。 </dd>
<dd>
如果你想创建一个由另外两个 <a class="el" href="DEALGlossary.html#GlossCoarseMesh">粗略网格 </a> 合并而成的网格，例如，为了从较简单的几何体的网格组成一个复杂的几何体，那么这个函数就不适合你。相反，可以考虑 <a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations()</a>. 。 </dd>
<dd>
这个函数假设 <code>triangulation_1</code> 和 <code>triangulation_2</code> 具有相同的流形描述。输出的三角形 <code>has</code> 与这两个三角形的流形ID相同。 </dd>
<dd>
两个源条件都需要完全在本地提供。 换言之，它们不能是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. 类型的对象。 </dd></dl>

</div>
</div>
<a id="ada140ece81bf38a23e738e0e57f89e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada140ece81bf38a23e738e0e57f89e97">&#9670;&nbsp;</a></span>create_triangulation_with_removed_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::create_triangulation_with_removed_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells_to_remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数创建了一个由第一个参数中的相同单元组成的三角形，除了第二个参数中列出的那些单元。该函数的目的是从现有的三角形描述的几何体中生成<em>subtractively</em>的几何体。一个典型的案例是一个有矩形孔的2维领域。这可以通过首先对整个域进行网格划分，然后用这个函数来摆脱位于孔洞的单元来实现。这个特殊用例的演示是 <a class="el" href="step_27.html">step-27</a> 的一部分。同样的，你可以通过从 <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, 开始细化一次，然后在第二个参数中加入单个单元，来创建 <a class="el" href="namespaceGridGenerator.html#a3b2a4ad8296c2b72a11d23b5969e8cc0">GridGenerator::hyper_L()</a> 产生的网格。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input_triangulation</td><td>作为模板的原始三角图，新的三角图将由此产生。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cells_to_remove</td><td>作为第一个参数提供的三角剖面中应被移除的单元格的列表（即不应该出现在结果中。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">结果</td><td>由 <code>input_triangulation</code>, 中的相同单元组成的三角形，但 <code>cells_to_remove</code>. 中列出的单元除外。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>与大多数GridGenerator函数不同，该函数不会为 <code>result</code>, 附加任何流形，也不会设置任何流形ID。 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>因为我们不能从头开始创建包含自适应细化单元的三角形，所以输入的三角形需要将其所有单元放在同一水平线上。通常情况下，这实际上是最粗糙的层次，但它被允许在一个已经被细化<em>globally</em>多次的三角图中通过。在这种情况下，输出的三角形将是一个只有一个层次的网格，由输入的活动单元减去第二个参数中的单元组成。然而，输入的三角形必须没有经过<em>adaptively</em>的精炼。 </dd></dl>

</div>
</div>
<a id="a6cc0ff3b4e5226c3e06a4aa6ac79f90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">&#9670;&nbsp;</a></span>extrude_triangulation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_priorities</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>沿 <code>input</code> 方向从 \(z = 0\) 到 \(z = \text{height}\) 挤压三角图 <code>input</code> ，并将其存储在 <code>result</code>. 中。 <em> 片 </em> ，或垂直于 \(z = 0\) 平面的细胞层的数量将是 <code>n_slices</code> 片（最小是2）。 <code>input</code> 面的边界指标将被分配给 \(z\) 方向的相应侧壁。底部和顶部得到下两个自由边界指标：即如果 <code>input</code> 的边界ID为 \(0\) 、 \(1\) 和 \(42\) ，那么 \(z = 0\) 的边界ID将是 \(43\) ，而 \(z = \text{height}\) 的边界ID将是 \(44\) 。 该函数默认情况下不复制流形的id。原因是在没有更多信息的情况下，没有办法在所生成的三角形的线条上设置流形ID：例如，如果 <code>input</code> 中两个流形ID不同的面在一个共享顶点相遇，那么在  中创建的与 \(z\) 轴平行并通过该点的线条，就没有 <em> 先验的理由选择一个流形ID或另一个。如果 <code>copy_manifold_ids</code> 是 <code>true</code> ，那么该函数通过挑选 <em> 中首先出现的 </em> 在 <code>manifold_priorities</code>. 中的那个来设置线条流形的ID。 例如：如果 <code></code>] 的 manifold_priorities 是 <code>{0, 42, <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>}</code> ，并且所考虑的线与 manifold ids 为 <code>0</code> and <code>42</code> 的面相邻，那么该线的 manifold id 为 <code>0</code> 。正确的排序几乎总是 </p><ol>
<li>
设置在边界上的流形id，  </li>
<li>
描述三角形中大多数单元的流形id（例如， <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>), 和  </li>
<li>
任何对应于 <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> 流形的流形id。  </li>
</ol>
<p>特别是，由于TransfiniteInterpolationManifold在周围流形之间进行插值，其流形id通常不应设置在与不同流形id的单元格相邻的线或面上。 <code>manifold_priorities</code> 的默认值遵循这个排序（其中每个类别按升序排序）。 </p><ol>
<li>
与非TransfiniteInterpolationManifold的流形相关的流形ID，以及  </li>
<li>
与任何TransfiniteInterpolationManifold对象相关的流形ID。  </li>
</ol>
<p>注意 <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> （如果它是 <code>输入的流形ID）将始终是第一类中的最后一项。</code> </p><dl class="section pre"><dt>Precondition</dt><dd>2d输入三角形 <code>input</code> 必须是 <a class="el" href="DEALGlossary.html#GlossCoarseMesh">粗略网格</a>，即不能有任何细化单元。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>由于 <code>input</code> 和 <code>output</code> 具有不同的空间尺寸，无论 <code>copy_manifold_ids</code>. 的值如何，此函数都不会复制流形对象。 </dd></dl>
<p></em></p>

</div>
</div>
<a id="a15c5b7ad43c366f2dcb559782457efda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c5b7ad43c366f2dcb559782457efda">&#9670;&nbsp;</a></span>extrude_triangulation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_slices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_priorities</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">extrude_triangulation()</a>的重载，允许独立于维度的代码被编译。这个函数在调用时抛出一个错误，因为extrude_triangulation()只实现了将dim=2挤压到dim=3的三角关系。 </p>

</div>
</div>
<a id="a8a9ce3fd3bac556d634d62d785452f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ce3fd3bac556d634d62d785452f8c">&#9670;&nbsp;</a></span>extrude_triangulation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_priorities</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>前一个函数的重载。取一个被挤出的二维三角板。与前一个函数不同的是，这个函数采用高度和片数进行均匀挤压，这个函数采用Z轴值 <code>slice_coordinates</code> ，在这里将进行切片处理。 <code>input</code> 的面的边界指标将被分配给z方向上的相应侧壁。底部和顶部得到下两个自由边界指标。 </p><dl class="section pre"><dt>Precondition</dt><dd>2d输入三角形 <code>input</code> 必须是 <a class="el" href="DEALGlossary.html#GlossCoarseMesh">粗略网格</a> ，即不能有任何细化单元。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>由于 <code>input</code> 和 <code>output</code> 具有不同的空间尺寸，因此该函数不会复制流形对象（也不会设置任何流形ID）。 </dd></dl>

</div>
</div>
<a id="acc920b19e79502facbffa861528b71d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc920b19e79502facbffa861528b71d4">&#9670;&nbsp;</a></span>extrude_triangulation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::extrude_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slice_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>copy_manifold_ids</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_priorities</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">extrude_triangulation()</a>的重载，允许独立于维度的代码被编译。这个函数在调用时抛出一个错误，因为extrude_triangulation()只实现了将dim=2挤压到dim=3的三角结构。 </p>

</div>
</div>
<a id="afe86bf1a4502131ec811a6de41ab41e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe86bf1a4502131ec811a6de41ab41e9">&#9670;&nbsp;</a></span>flatten_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim1, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::flatten_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个输入三角形 <code>in_tria</code>, ，该函数生成一个新的平面三角形 <code>out_tria</code> ，其中包含一个具有输入三角形的所有活动单元的单一层次。如果 <code>spacedim1</code> 和 <code>spacedim2</code> 不同，只有顶点的最小间隔分量被复制过来。这对于从三角图&lt;2,2&gt;中创建三角图&lt;2,3&gt;，或者通过忽略顶点的Z分量将三角图&lt;2,3&gt;投影到三角图&lt;2,2&gt;中是很有用的。 不对顶点进行内部检查，假设顶点在目标 <code>spacedim2</code> 维空间中具有拓扑意义。如果不是这样，你在以后使用三角法时就会遇到问题。 所有关于单元格流形ID和材料ID的信息都会从一个三角剖面复制到另一个三角剖面，只有边界流形ID和边界ID会从 <code>in_tria</code> 的面复制到 <code>out_tria</code>. 的面，如果你需要指定内部面的流形ID，它们必须在三角剖面创建后手动指定。 如果输入的Triangulation是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 类型，以及输入的Triangulation包含悬空节点时，该函数将失败。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_tria</td><td>新的平面三角图的基本输入。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_tria</td><td>由in_tria构建的所需的扁平化三角图。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>由于 <code>input</code> 和 <code>output</code> 的空间尺寸不同，此函数不会复制流形对象：您必须将新的流形对象附加到 <code>out_tria</code>. 。 </dd></dl>

</div>
</div>
<a id="ac7515d2b17c025dddc0e37286fb8d216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7515d2b17c025dddc0e37286fb8d216">&#9670;&nbsp;</a></span>convert_hypercube_to_simplex_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::convert_hypercube_to_simplex_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将仅由超立方体单元（四边形、六面体）组成的三角剖面转换为仅由简单单元（三角形、四面体）组成的三角剖面。 作为一个例子，下面的图片显示了一组八分之一球体的三个六面体是如何被细分为四面体的，以及如何将曲面考虑在内。颜色表示边界指标是如何继承的。 </p><div class="image">
<img src="convert_hypercube_to_simplex_mesh_visualization_octant.png" alt="convert_hypercube_to_simplex_mesh_visualization_octant.png"/>
<div class="caption">
一般来说，每个2D的四边形被细分为八个三角形，每个3D的六面体被细分为24个四面体，如图所示。  html "convert_hypercube_to_simplex_mesh_visualization.png" 材料ID和边界ID在转换时将被继承。  in_tria 含有六面体元素的三角结构。  out_tria 转换后的包含tet元素的三角图。</div></div>
 <dl class="section note"><dt>Note</dt><dd>此函数不复制流形对象：您必须将现有的流形对象从 <code>in_tria</code> 复制到 <code>out_tria</code>, ，例如，使用以下代码。 <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : in_tria.get_manifold_ids())</div><div class="line"><span class="keywordflow">if</span> (i != <a class="code" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>)</div><div class="line">  out_tria.set_manifold(i, in_tria.get_manifold(i));</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a01c9d0d7ff5858b45531b626c3a94c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c9d0d7ff5858b45531b626c3a94c2e">&#9670;&nbsp;</a></span>convert_hypercube_to_simplex_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridGenerator::convert_hypercube_to_simplex_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数对一维的专门化：简单地复制三角函数。 </p>

</div>
</div>
<a id="a45440e91a38475333d937938bbd3b046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45440e91a38475333d937938bbd3b046">&#9670;&nbsp;</a></span>extract_boundary_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; int, int &gt; class MeshType, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;typename MeshType&lt;dim - 1, spacedim&gt;::cell_iterator, typename MeshType&lt;dim, spacedim&gt;::face_iterator&gt; GridGenerator::extract_boundary_mesh </td>
          <td>(</td>
          <td class="paramtype">const MeshType&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshType&lt; dim - 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数实现了边界子网格的提取。 给定一个&lt;dim,spacedim&gt;三角网格（"体网格"），该函数提取其边界的一个子集（"面网格"）。 要提取的边界是由一个 boundary_ids 列表指定的。 如果没有指定，整个边界将被提取出来。该函数在 <a class="el" href="step_38.html">step-38</a> 中使用。 该函数还建立了一个映射，将表面网格上的单元格与体积网格上的相应面连接起来。这个映射是该函数的返回值。 </p><dl class="section note"><dt>Note</dt><dd>上面概述的算法假定所有在较高细化水平上的面总是具有与它们的父面完全相同的边界指标。因此，我们可以从粗层次的面开始，在此基础上建立曲面网格。将这个函数扩展到将细化级面的边界指标复制到其相应的表面网格单元并不是很困难，例如，在弯曲边界的情况下适应不同的几何描述（但目前还没有实现）。 </dd>
<dd>
由于 <code>volume_mesh</code> 和 <code>surface_mesh</code> 有不同的空间维度，没有流形对象被这个函数复制：你必须将新的流形对象附加到 <code>surface_mesh</code>. 。 </dd></dl>

</div>
</div>
<a id="ad7b4805db66d34e56837dfef047f7fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b4805db66d34e56837dfef047f7fe0">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidRadii&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="aeb2334f33e83f0937aa82a9522d03b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2334f33e83f0937aa82a9522d03b1b">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidRepetitions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The number of repetitions &quot;&lt;&lt; arg1&lt;&lt; &quot; must be &gt;=1.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a764d32da2c6ffefa0759861a295395df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764d32da2c6ffefa0759861a295395df">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidRepetitionsDimension&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The vector of repetitions must have &quot;&lt;&lt; arg1&lt;&lt; &quot; elements.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a9f83e890d6e88b3dac100d994ac53217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f83e890d6e88b3dac100d994ac53217">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridGenerator::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidInputOrientation&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The input to this function is oriented in a way that will&quot; &quot; cause all cells to have negative measure.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>输入方向不正确的异常情况。 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
