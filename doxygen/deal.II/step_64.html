<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_64.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-64 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-64 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a>, <a class="el" href="step_37.html">step-37</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The test case</a>
        <li><a href="#Movingdatatoandfromthedevice">Moving data to and from the device</a>
        <li><a href="#Matrixvectorproductimplementation">Matrix-vector product implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#ClasscodeVaryingCoefficientFunctorcode">Class <code>VaryingCoefficientFunctor</code></a>
        <li><a href="#ClasscodeHelmholtzOperatorQuadcode">Class <code>HelmholtzOperatorQuad</code></a>
        <li><a href="#ClasscodeLocalHelmholtzOperatorcode">Class <code>LocalHelmholtzOperator</code></a>
        <li><a href="#ClasscodeHelmholtzOperatorcode">Class <code>HelmholtzOperator</code></a>
        <li><a href="#ClasscodeHelmholtzProblemcode">Class <code>HelmholtzProblem</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-64/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Bruno Turcksin and Daniel Arndt, Oak Ridge National Laboratory. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>这个例子展示了如何使用CUDA在GPU上实现超立方体上系数可变的亥姆霍兹方程的无矩阵方法。该线性系统将使用共轭梯度法进行求解，并通过MPI进行并行化。</p>
<p>在过去的几年里，一般的异构计算，特别是GPU，已经获得了很多的青睐。这是因为在给定的功率预算下，GPU比CPU提供更好的计算能力和内存带宽。在2019年初的架构中，对于PDE相关的任务，GPU的功率效率约为服务器CPU的2-3倍，宽<a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a>。GPU也是机器学习中最受欢迎的架构。另一方面，GPU并不容易编程。这个程序探索了deal.II的能力，看看这样的程序可以如何有效地实现。</p>
<p>虽然我们试图让CPU和GPU的无矩阵类的接口尽可能接近，但还是有一些区别。当在GPU上使用无矩阵框架时，人们必须编写一些CUDA代码。然而，其数量相当少，而且CUDA的使用仅限于几个关键词。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>在这个例子中，我们考虑亥姆霍兹问题 </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot \nabla u + a(\mathbf x) u &amp;=&amp;1,\\ u &amp;=&amp; 0 \quad \text{on } \partial \Omega \end{eqnarray*}
</p>
<p> 。</p>
<p>其中 \(a(\mathbf x)\) 是一个可变系数。</p>
<p>我们选择 \(\Omega=[0,1]^3\) 和 \(a(\mathbf x)=\frac{10}{0.05 + 2\|\mathbf x\|^2}\) 作为域。由于系数是围绕原点对称的，但域却不是，我们最终会得到一个非对称的解决方案。</p>
<p>如果你在本教程中读到这里，你就会知道这个问题的弱式表述是怎样的，以及原则上是怎样为它组建线性系统的。当然，在这个程序中，我们实际上不会形成矩阵，而只是表示它与之相乘时的作用。</p>
<p><a class="anchor" id="Movingdatatoandfromthedevice"></a></p><h3>Moving data to and from the device</h3>
<p>GPU（我们从现在开始用 "设备 "一词来指代GPU）有自己的内存，与CPU（我们从现在开始用 "主机 "一词）可访问的内存分开。设备上的正常计算可以分为三个独立的步骤。</p>
<ol type="1">
<li>数据从主机移到设备上。</li>
</ol>
<p>-#计算是在设备上完成的。</p>
<ol type="1">
<li>结果从设备移回主机。</li>
</ol>
<p>数据移动可以由用户代码显式完成，也可以使用UVM（统一虚拟内存）自动完成。在deal.II中，只支持第一种方法。虽然这意味着用户有额外的负担，但这可以更好地控制数据移动，更重要的是可以避免在主机而不是设备上错误地运行重要的内核。</p>
<p>deal.II中的数据移动是使用 <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>. 完成的，这些向量可以被看作是主机上的缓冲区，用于存储从设备接收的数据或向设备发送数据。有两种类型的向量可以在设备上使用。</p>
<ul>
<li><a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>, ，它类似于更常见的Vector&lt;Number&gt;，和</li>
<li>LinearAlgebra::distributed::Vector&lt;Number,   MemorySpace::CUDA&gt;, 这是一个普通的 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> ，我们已经指定了要使用哪个内存空间。</li>
</ul>
<p>如果没有指定内存空间，默认为 <a class="el" href="structMemorySpace_1_1Host.html">MemorySpace::Host</a>. 。</p>
<p>接下来，我们展示如何使用 <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>: 将数据移入/移出设备。</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = 10;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(size);</div><div class="line"></div><div class="line"></div><div class="line">...do something with the rw_vector...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Move the data to the device:</span></div><div class="line">LinearAlgebra::CUDAWrappers::Vector&lt;<span class="keywordtype">double</span>&gt; vector_dev(size);</div><div class="line">vector_dev.import(rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div><div class="line"></div><div class="line"></div><div class="line">...do some computations on the device...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Move the data back to the host:</span></div><div class="line">rw_vector.import(vector_dev, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --><p>这里使用的两个向量类都只在一台机器上工作，也就是说，一个内存空间在主机上，一个在设备上。</p>
<p>但在有些情况下，人们希望在一些机器上的多个MPI进程之间运行并行计算，而每个机器都配备了GPU。在这种情况下，人们希望使用 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number,<a class="el" href="structMemorySpace_1_1CUDA.html">MemorySpace::CUDA</a>&gt;</code>, ，它是类似的，但<code>import()</code>阶段可能涉及MPI通信。</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs, locally_relevant_dofs;</div><div class="line">...fill the two <a class="code" href="classIndexSet.html">IndexSet</a> objects...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Create the ReadWriteVector using an IndexSet instead of the size</span></div><div class="line">LinearAlgebra::ReadWriteVector&lt;<span class="keywordtype">double</span>&gt; owned_rw_vector(locally_owned_dofs);</div><div class="line"></div><div class="line"></div><div class="line">...do something with the rw_vector...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Move the data to the device:</span></div><div class="line">LinearAlgebra::distributed::Vector&lt;double, <a class="code" href="structMemorySpace_1_1CUDA.html">MemorySpace::CUDA</a>&gt;</div><div class="line">  distributed_vector_dev(locally_owned_dofs, MPI_COMM_WORLD);</div><div class="line">distributed_vector_dev.import(owned_rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div><div class="line"></div><div class="line"></div><div class="line">...do something with the dev_vector...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Create a ReadWriteVector with a different IndexSet:</span></div><div class="line">LinearAlgebra::ReadWriteVector&lt;<span class="keywordtype">double</span>&gt;</div><div class="line">  relevant_rw_vector(locally_relevant_dofs);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Move the data to the host, possibly using MPI communication:</span></div><div class="line">relevant_rw_vector.import(distributed_vector_dev, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --><p><code>relevant_rw_vector</code>是一个存储向量所有元素的子集的对象。通常情况下，这些是 <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">本地相关的DoF</a>，这意味着它们在不同的MPI进程之间是重叠的。因此，一台机器上存储在该向量中的元素可能与该机器上的GPU存储的元素不一致，需要MPI通信来导入它们。</p>
<p>在所有这些情况下，在导入矢量时，可以插入数值（使用 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>) 或添加到矢量的先前内容中（使用 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>). ）。</p>
<p><a class="anchor" id="Matrixvectorproductimplementation"></a></p><h3>Matrix-vector product implementation</h3>
<p>在设备上评估无矩阵算子所需的代码与主机上的代码非常相似。然而，也有一些区别，主要是<a class="el" href="step_37.html">step-37</a>中的<code>local_apply()</code>函数和正交点的循环都需要封装在自己的函数中。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First include the necessary files from the deal.II library known from the previous tutorials.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The following ones include the data structures for the implementation of matrix-free methods on GPU:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2cuda_8h.html">deal.II/base/cuda.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda__fe__evaluation_8h.html">deal.II/matrix_free/cuda_fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda__matrix__free_8h.html">deal.II/matrix_free/cuda_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>As usual, we enclose everything into a namespace of its own:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step64</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeVaryingCoefficientFunctorcode"></a> </p><h3>Class <code>VaryingCoefficientFunctor</code></h3>
<p>Next, we define a class that implements the varying coefficients we want to use in the Helmholtz operator. Later, we want to pass an object of this type to a <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> object that expects the class to have an <code>operator()</code> that fills the values provided in the constructor for a given cell. This operator needs to run on the device, so it needs to be marked as <code>__device__</code> for the compiler.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>VaryingCoefficientFunctor</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  VaryingCoefficientFunctor(<span class="keywordtype">double</span> *coefficient)</div><div class="line">    : coef(coefficient)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data);</div></div><!-- fragment --><p>Since <a class="el" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree::Data</a> doesn't know about the size of its arrays, we need to store the number of quadrature points and the numbers of degrees of freedom in this class to do necessary index conversions.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_1d = fe_degree + 1;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_dofs =</div><div class="line">    ::Utilities::pow(n_dofs_1d, dim);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    ::Utilities::pow(n_dofs_1d, dim);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> *coef;</div><div class="line">};</div></div><!-- fragment --><p>The following function implements this coefficient. Recall from the introduction that we have defined it as \(a(\mathbf x)=\frac{10}{0.05 + 2\|\mathbf x\|^2}\)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> VaryingCoefficientFunctor&lt;dim, fe_degree&gt;::operator()(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">    cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> q_point =</div><div class="line">    CUDAWrappers::get_quadrature_point&lt;dim, double&gt;(cell,</div><div class="line">                                                    gpu_data,</div><div class="line">                                                    n_dofs_1d);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> p_square = 0.;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coord = q_point[i];</div><div class="line">      p_square += coord * coord;</div><div class="line">    }</div><div class="line">  coef[pos] = 10. / (0.05 + 2. * p_square);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzOperatorQuadcode"></a> </p><h3>Class <code>HelmholtzOperatorQuad</code></h3>
<p>The class <code>HelmholtzOperatorQuad</code> implements the evaluation of the Helmholtz operator at each quadrature point. It uses a similar mechanism as the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework introduced in <a class="el" href="step_37.html">step-37</a>. In contrast to there, the actual quadrature point index is treated implicitly by converting the current thread index. As before, the functions of this class need to run on the device, so need to be marked as <code>__device__</code> for the compiler.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzOperatorQuad</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  __device__ HelmholtzOperatorQuad(<span class="keywordtype">double</span> coef)</div><div class="line">    : coef(coef)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span></div><div class="line">  operator()(<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt;</a> *fe_eval) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> coef;</div><div class="line">};</div></div><!-- fragment --><p>The Helmholtz problem we want to solve here reads in weak form as follows: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla v, \nabla u)+ (v, a(\mathbf x) u) &amp;=&amp;(v,1) \quad \forall v. \end{eqnarray*}
</p>
<p> If you have seen <a class="el" href="step_37.html">step-37</a>, then it will be obvious that the two terms on the left-hand side correspond to the two function calls here:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> HelmholtzOperatorQuad&lt;dim, fe_degree&gt;::</div><div class="line">                operator()(<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt;</a> *fe_eval)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a58daeed0b26fcaeee745936a62403623">submit_value</a>(coef * fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#aacf72a37d0ef60c9cd248b896fdafb99">get_value</a>());</div><div class="line">  fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a25fffdd57bc94870cc1bc4db2f4f6379">submit_gradient</a>(fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#ae14d61c332a97c1e2a5023db782f1155">get_gradient</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeLocalHelmholtzOperatorcode"></a> </p><h3>Class <code>LocalHelmholtzOperator</code></h3>
<p>Finally, we need to define a class that implements the whole operator evaluation that corresponds to a matrix-vector product in matrix-based approaches.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>LocalHelmholtzOperator</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LocalHelmholtzOperator(<span class="keywordtype">double</span> *coefficient)</div><div class="line">    : coef(coefficient)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data,</div><div class="line">    <a class="code" href="structCUDAWrappers_1_1SharedData.html">CUDAWrappers::SharedData&lt;dim, double&gt;</a> *                     shared_data,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> *                                              src,</div><div class="line">    <span class="keywordtype">double</span> *                                                    dst) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Again, the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> object doesn't know about the number of degrees of freedom and the number of quadrature points so we need to store these for index calculations in the call operator.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_1d    = fe_degree + 1;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_dofs = <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points   = <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> *coef;</div><div class="line">};</div></div><!-- fragment --><p>This is the call operator that performs the Helmholtz operator evaluation on a given cell similar to the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework on the CPU. In particular, we need access to both values and gradients of the source vector and we write value and gradient information to the destination vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> LocalHelmholtzOperator&lt;dim, fe_degree&gt;::operator()(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data,</div><div class="line">  <a class="code" href="structCUDAWrappers_1_1SharedData.html">CUDAWrappers::SharedData&lt;dim, double&gt;</a> *                     shared_data,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> *                                              src,</div><div class="line">  <span class="keywordtype">double</span> *                                                    dst)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">    cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line"></div><div class="line">  <a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a></div><div class="line">    fe_eval(cell, gpu_data, shared_data);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#ae0e594e5dc5dc91391190c4bb1d8c45c">read_dof_values</a>(src);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#aa50f53d6eb1b0416a791008a5e1a3b25">evaluate</a>(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#af54da23ff99a33dcd23ddccf52dee2f5">apply_for_each_quad_point</a>(</div><div class="line">    HelmholtzOperatorQuad&lt;dim, fe_degree&gt;(coef[pos]));</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a12939db3c43822e5cbf51520ad52dedb">integrate</a>(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a90c2f1b2718e90aa49b7d49fac3600d5">distribute_local_to_global</a>(dst);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzOperatorcode"></a> </p><h3>Class <code>HelmholtzOperator</code></h3>
<p>The <code>HelmholtzOperator</code> class acts as wrapper for <code>LocalHelmholtzOperator</code> defining an interface that can be used with linear solvers like <a class="el" href="classSolverCG.html">SolverCG</a>. In particular, like every class that implements the interface of a linear operator, it needs to have a <code>vmult()</code> function that performs the action of the linear operator on a source vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzOperator</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelmholtzOperator(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;          dof_handler,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;constraints);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vmult(<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;dst,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a></div><div class="line">          &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> initialize_dof_vector(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;vec) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;</a>       mf_data;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector&lt;double&gt;</a> coef;</div><div class="line">};</div></div><!-- fragment --><p>The following is the implementation of the constructor of this class. In the first part, we initialize the <code>mf_data</code> member variable that is going to provide us with the necessary information when evaluating the operator.</p>
<p>In the second half, we need to store the value of the coefficient for each quadrature point in every active, locally owned cell. We can ask the parallel triangulation for the number of active, locally owned cells but only have a <a class="el" href="classDoFHandler.html">DoFHandler</a> object at hand. Since <a class="el" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">DoFHandler::get_triangulation()</a> returns a <a class="el" href="classTriangulation.html">Triangulation</a> object, not a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> object, we have to downcast the return value. This is safe to do here because we know that the triangulation is a parallel:distributed::<a class="el" href="classTriangulation.html">Triangulation</a> object in fact.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">HelmholtzOperator&lt;dim, fe_degree&gt;::HelmholtzOperator(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;          dof_handler,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;constraints)</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe_degree);</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1AdditionalData.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::AdditionalData</a></div><div class="line">    additional_data;</div><div class="line">  additional_data.<a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1AdditionalData.html#a4fc9f434f93f40a8c1dff4ed6b9fd509">mapping_update_flags</a> = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a> quad(fe_degree + 1);</div><div class="line">  mf_data.reinit(mapping, dof_handler, constraints, quad, additional_data);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_owned_cells =</div><div class="line">    <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase&lt;dim&gt;</a> *<span class="keyword">&gt;</span>(</div><div class="line">      &amp;dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>())</div><div class="line">      -&gt;n_locally_owned_active_cells();</div><div class="line">  coef.reinit(<a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim) * n_owned_cells);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> VaryingCoefficientFunctor&lt;dim, fe_degree&gt; functor(coef.get_values());</div><div class="line">  mf_data.evaluate_coefficients(functor);</div><div class="line">}</div></div><!-- fragment --><p>The key step then is to use all of the previous classes to loop over all cells to perform the matrix-vector product. We implement this in the next function.</p>
<p>When applying the Helmholtz operator, we have to be careful to handle boundary conditions correctly. Since the local operator doesn't know about constraints, we have to copy the correct values from the source to the destination vector afterwards.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzOperator&lt;dim, fe_degree&gt;::vmult(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;src)<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  dst = 0.;</div><div class="line">  LocalHelmholtzOperator&lt;dim, fe_degree&gt; helmholtz_operator(</div><div class="line">    coef.get_values());</div><div class="line">  mf_data.cell_loop(helmholtz_operator, src, dst);</div><div class="line">  mf_data.copy_constrained_values(src, dst);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzOperator&lt;dim, fe_degree&gt;::initialize_dof_vector(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;vec)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  mf_data.initialize_dof_vector(vec);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzProblemcode"></a> </p><h3>Class <code>HelmholtzProblem</code></h3>
<p>This is the main class of this program. It defines the usual framework we use for tutorial programs. The only point worth commenting on is the <code>solve()</code> function and the choice of vector types.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelmholtzProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>                          constraints;</div><div class="line">  std::unique_ptr&lt;HelmholtzOperator&lt;dim, fe_degree&gt;&gt; system_matrix_dev;</div></div><!-- fragment --><p>Since all the operations in the <code>solve()</code> function are executed on the graphics card, it is necessary for the vectors used to store their values on the GPU as well. <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> can be told which memory space to use. There is also <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a> that always uses GPU memory storage but doesn't work with MPI. It might be worth noticing that the communication between different MPI processes can be improved if the MPI implementation is CUDA-aware and the configure flag <code>DEAL_II_MPI_WITH_CUDA_SUPPORT</code> is enabled. (The value of this flag needs to be set at the time you call <code>cmake</code> when installing deal.II.)</p>
<p>In addition, we also keep a solution vector with CPU storage such that we can view and display the solution as usual.</p>
<div class="fragment"><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</a></div><div class="line">                                                                ghost_solution_host;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> solution_dev;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a></div><div class="line">    system_rhs_dev;</div><div class="line"></div><div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">};</div></div><!-- fragment --><p>The implementation of all the remaining functions of this class apart from <code>Helmholtzproblem::solve()</code> doesn't contain anything new and we won't further comment much on the overall approach.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">HelmholtzProblem&lt;dim, fe_degree&gt;::HelmholtzProblem()</div><div class="line">  : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , triangulation(mpi_communicator)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line">  system_rhs_dev.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  system_matrix_dev.reset(</div><div class="line">    <span class="keyword">new</span> HelmholtzOperator&lt;dim, fe_degree&gt;(dof_handler, constraints));</div><div class="line"></div><div class="line">  ghost_solution_host.reinit(locally_owned_dofs,</div><div class="line">                             locally_relevant_dofs,</div><div class="line">                             mpi_communicator);</div><div class="line">  system_matrix_dev-&gt;initialize_dof_vector(solution_dev);</div><div class="line">  system_rhs_dev.reinit(solution_dev);</div><div class="line">}</div></div><!-- fragment --><p>Unlike programs such as <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a>, we will not have to assemble the whole linear system but only the right hand side vector. This looks in essence like we did in <a class="el" href="step_4.html">step-4</a>, for example, but we have to pay attention to using the right constraints object when copying local contributions into the global vector. In particular, we need to make sure the entries that correspond to boundary nodes are properly zeroed out. This is necessary for CG to converge. (Another solution would be to modify the <code>vmult()</code> function above in such a way that we pretend the source vector has zero entries by just not taking them into account in matrix-vector products. But the approach used here is simpler.)</p>
<p>At the end of the function, we can't directly copy the values from the host to the device but need to use an intermediate object of type <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a> to construct the correct communication pattern necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</a></div><div class="line">                    system_rhs_host(locally_owned_dofs,</div><div class="line">                    locally_relevant_dofs,</div><div class="line">                    mpi_communicator);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * 1.0 *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_rhs_host);</div><div class="line">      }</div><div class="line">  system_rhs_host.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(locally_owned_dofs);</div><div class="line">  rw_vector.import(system_rhs_host, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  system_rhs_dev.import(rw_vector, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">}</div></div><!-- fragment --><p>This solve() function finally contains the calls to the new classes previously discussed. Here we don't use any preconditioner, i.e., precondition by the identity matrix, to focus just on the peculiarities of the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> framework. Of course, in a real application the choice of a suitable preconditioner is crucial but we have at least the same restrictions as in <a class="el" href="step_37.html">step-37</a> since matrix entries are computed on the fly and not stored.</p>
<p>After solving the linear system in the first part of the function, we copy the solution from the device to the host to be able to view its values and display it in <code>output_results()</code>. This transfer works the same as at the end of the previous function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a> preconditioner;</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_rhs_dev.size(),</div><div class="line">                               1e-12 * system_rhs_dev.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a>&gt; cg(</div><div class="line">    solver_control);</div><div class="line">  cg.solve(*system_matrix_dev, solution_dev, system_rhs_dev, preconditioner);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;  Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(locally_owned_dofs);</div><div class="line">  rw_vector.import(solution_dev, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  ghost_solution_host.import(rw_vector, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(ghost_solution_host);</div><div class="line"></div><div class="line">  ghost_solution_host.update_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p>The output results function is as usual since we have already copied the values back from the GPU to the CPU.</p>
<p>While we're already doing something with the function, we might as well compute the \(L_2\) norm of the solution. We do this by calling <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>. That function is meant to compute the error by evaluating the difference between the numerical solution (given by a vector of values for the degrees of freedom) and an object representing the exact solution. But we can easily compute the \(L_2\) norm of the solution by passing in a zero function instead. That is, instead of evaluating the error \(\|u_h-u\|_{L_2(\Omega)}\), we are just evaluating \(\|u_h-0\|_{L_2(\Omega)}=\|u_h\|_{L_2(\Omega)}\) instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(ghost_solution_host, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, mpi_communicator, 2);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> cellwise_norm(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                    ghost_solution_host,</div><div class="line">                                    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                    cellwise_norm,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_norm =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      cellwise_norm,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;  solution norm: &quot;</span> &lt;&lt; global_norm &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>There is nothing surprising in the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function either. We simply compute the solution on a series of (globally) refined meshes.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HelmholtzProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 7 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step64</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>Finally for the <code>main()</code> function. By default, all the MPI ranks will try to access the device with number 0, which we assume to be the GPU device associated with the CPU on which a particular MPI rank runs. This works, but if we are running with MPI support it may be that multiple MPI processes are running on the same machine (for example, one per CPU core) and then they would all want to access the same GPU on that machine. If there is only one GPU in the machine, there is nothing we can do about it: All MPI ranks on that machine need to share it. But if there are more than one GPU, then it is better to address different graphic cards for different processes. The choice below is based on the MPI process id by assigning GPUs round robin to GPU ranks. (To work correctly, this scheme assumes that the MPI ranks on one machine are consecutive. If that were not the case, then the rank-GPU association may just not be optimal.) To make this work, MPI needs to be initialized before using this function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step64;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      <span class="keywordtype">int</span>         n_devices       = 0;</div><div class="line">      cudaError_t cuda_error_code = cudaGetDeviceCount(&amp;n_devices);</div><div class="line">      <a class="code" href="group__Exceptions.html#gac1b7e8a4a8d5d910cd9fbd8814e9955e">AssertCuda</a>(cuda_error_code);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_mpi_id =</div><div class="line">        <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> device_id = my_mpi_id % n_devices;</div><div class="line">      cuda_error_code     = cudaSetDevice(device_id);</div><div class="line">      <a class="code" href="group__Exceptions.html#gac1b7e8a4a8d5d910cd9fbd8814e9955e">AssertCuda</a>(cuda_error_code);</div><div class="line"></div><div class="line">      HelmholtzProblem&lt;3, 3&gt; helmholtz_problem;</div><div class="line">      helmholtz_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-64/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>由于本教程的主要目的是演示如何使用 <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> 接口，而不是计算任何有用的东西本身，所以我们在这里只是显示预期的输出。</p>
<div class="fragment"><div class="line">Cycle 0</div><div class="line">   Number of active cells:       8</div><div class="line">   Number of degrees of freedom: 343</div><div class="line">  Solved in 27 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205439</div><div class="line"></div><div class="line"></div><div class="line">Cycle 1</div><div class="line">   Number of active cells:       64</div><div class="line">   Number of degrees of freedom: 2197</div><div class="line">  Solved in 60 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205269</div><div class="line"></div><div class="line"></div><div class="line">Cycle 2</div><div class="line">   Number of active cells:       512</div><div class="line">   Number of degrees of freedom: 15625</div><div class="line">  Solved in 114 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205261</div><div class="line"></div><div class="line"></div><div class="line">Cycle 3</div><div class="line">   Number of active cells:       4096</div><div class="line">   Number of degrees of freedom: 117649</div><div class="line">  Solved in 227 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205261</div></div><!-- fragment --><p>在这里，我们可以做两个观察。首先，数值解的准则在收敛，大概是收敛到精确（但未知）解的准则。其次，每次细化网格时，迭代次数大约增加一倍。这与CG迭代次数随矩阵条件数的平方根增长的预期一致；而且我们知道二阶微分运算的矩阵条件数的增长方式是 \({\cal O}(h^{-2})\) 。这当然是相当低效的，因为一个最佳解算器的迭代次数与问题的大小无关。但是要有这样一个求解器，就需要使用比我们在这里使用的身份矩阵更好的预处理。</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>目前，这个程序完全没有使用预处理程序。这主要是因为构建一个高效的无矩阵预处理程序是不容易的。 然而，只需要相应矩阵的对角线的简单选择是很好的选择，这些也可以用无矩阵的方式计算。另外，也许更好的是，我们可以扩展教程，使用类似步骤37的切比雪夫平滑器的多重网格。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line">/* ---------------------------------------------------------------------</div><div class="line"> *</div><div class="line"> * Copyright (C) 2019 - 2020 by the deal.II authors</div><div class="line"> *</div><div class="line"> * This file is part of the deal.II library.</div><div class="line"> *</div><div class="line"> * The deal.II library is free software; you can use it, redistribute</div><div class="line"> * it, and/or modify it under the terms of the GNU Lesser General</div><div class="line"> * Public License as published by the Free Software Foundation; either</div><div class="line"> * version 2.1 of the License, or (at your option) any later version.</div><div class="line"> * The full text of the license can be found in the file LICENSE.md at</div><div class="line"> * the top level directory of deal.II.</div><div class="line"> *</div><div class="line"> * ---------------------------------------------------------------------</div><div class="line"></div><div class="line"> *</div><div class="line"> * Authors: Bruno Turcksin, Daniel Arndt, Oak Ridge National Laboratory, 2019</div><div class="line"> */</div><div class="line"></div><div class="line">#include &lt;deal.II/base/conditional_ostream.h&gt;</div><div class="line">#include &lt;deal.II/base/quadrature_lib.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/dofs/dof_tools.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/fe/fe_q.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/grid/grid_generator.h&gt;</div><div class="line">#include &lt;deal.II/grid/tria.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/lac/affine_constraints.h&gt;</div><div class="line">#include &lt;deal.II/lac/la_parallel_vector.h&gt;</div><div class="line">#include &lt;deal.II/lac/precondition.h&gt;</div><div class="line">#include &lt;deal.II/lac/solver_cg.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/numerics/data_out.h&gt;</div><div class="line">#include &lt;deal.II/numerics/vector_tools.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/base/cuda.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/matrix_free/cuda_fe_evaluation.h&gt;</div><div class="line">#include &lt;deal.II/matrix_free/cuda_matrix_free.h&gt;</div><div class="line">#include &lt;deal.II/matrix_free/operators.h&gt;</div><div class="line"></div><div class="line">#include &lt;fstream&gt;</div><div class="line"></div><div class="line"></div><div class="line">namespace Step64</div><div class="line">{</div><div class="line">  using namespace dealii;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class VaryingCoefficientFunctor</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    VaryingCoefficientFunctor(double *coefficient)</div><div class="line">      : coef(coefficient)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void operator()(</div><div class="line">      const unsigned int                                          cell,</div><div class="line">      const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data);</div><div class="line"></div><div class="line">    static const unsigned int n_dofs_1d = fe_degree + 1;</div><div class="line">    static const unsigned int n_local_dofs =</div><div class="line">      ::Utilities::pow(n_dofs_1d, dim);</div><div class="line">    static const unsigned int n_q_points =</div><div class="line">      ::Utilities::pow(n_dofs_1d, dim);</div><div class="line"></div><div class="line">  private:</div><div class="line">    double *coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void VaryingCoefficientFunctor&lt;dim, fe_degree&gt;::operator()(</div><div class="line">    const unsigned int                                          cell,</div><div class="line">    const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data)</div><div class="line">  {</div><div class="line">    const unsigned int pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">      cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line">    const Point&lt;dim&gt; q_point =</div><div class="line">      CUDAWrappers::get_quadrature_point&lt;dim, double&gt;(cell,</div><div class="line">                                                      gpu_data,</div><div class="line">                                                      n_dofs_1d);</div><div class="line"></div><div class="line">    double p_square = 0.;</div><div class="line">    for (unsigned int i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        const double coord = q_point[i];</div><div class="line">        p_square += coord * coord;</div><div class="line">      }</div><div class="line">    coef[pos] = 10. / (0.05 + 2. * p_square);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzOperatorQuad</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    __device__ HelmholtzOperatorQuad(double coef)</div><div class="line">      : coef(coef)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void</div><div class="line">    operator()(CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt; *fe_eval) const;</div><div class="line"></div><div class="line">  private:</div><div class="line">    double coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void HelmholtzOperatorQuad&lt;dim, fe_degree&gt;::</div><div class="line">                  operator()(CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt; *fe_eval) const</div><div class="line">  {</div><div class="line">    fe_eval-&gt;submit_value(coef * fe_eval-&gt;get_value());</div><div class="line">    fe_eval-&gt;submit_gradient(fe_eval-&gt;get_gradient());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class LocalHelmholtzOperator</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    LocalHelmholtzOperator(double *coefficient)</div><div class="line">      : coef(coefficient)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void operator()(</div><div class="line">      const unsigned int                                          cell,</div><div class="line">      const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data,</div><div class="line">      CUDAWrappers::SharedData&lt;dim, double&gt; *                     shared_data,</div><div class="line">      const double *                                              src,</div><div class="line">      double *                                                    dst) const;</div><div class="line"></div><div class="line">    static const unsigned int n_dofs_1d    = fe_degree + 1;</div><div class="line">    static const unsigned int n_local_dofs = Utilities::pow(fe_degree + 1, dim);</div><div class="line">    static const unsigned int n_q_points   = Utilities::pow(fe_degree + 1, dim);</div><div class="line"></div><div class="line">  private:</div><div class="line">    double *coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void LocalHelmholtzOperator&lt;dim, fe_degree&gt;::operator()(</div><div class="line">    const unsigned int                                          cell,</div><div class="line">    const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data,</div><div class="line">    CUDAWrappers::SharedData&lt;dim, double&gt; *                     shared_data,</div><div class="line">    const double *                                              src,</div><div class="line">    double *                                                    dst) const</div><div class="line">  {</div><div class="line">    const unsigned int pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">      cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line"></div><div class="line">    CUDAWrappers::FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</div><div class="line">      fe_eval(cell, gpu_data, shared_data);</div><div class="line">    fe_eval.read_dof_values(src);</div><div class="line">    fe_eval.evaluate(true, true);</div><div class="line">    fe_eval.apply_for_each_quad_point(</div><div class="line">      HelmholtzOperatorQuad&lt;dim, fe_degree&gt;(coef[pos]));</div><div class="line">    fe_eval.integrate(true, true);</div><div class="line">    fe_eval.distribute_local_to_global(dst);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzOperator</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    HelmholtzOperator(const DoFHandler&lt;dim&gt; &amp;          dof_handler,</div><div class="line">                      const AffineConstraints&lt;double&gt; &amp;constraints);</div><div class="line"></div><div class="line">    void</div><div class="line">    vmult(LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;dst,</div><div class="line">          const LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</div><div class="line">            &amp;src) const;</div><div class="line"></div><div class="line">    void initialize_dof_vector(</div><div class="line">      LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;vec) const;</div><div class="line"></div><div class="line">  private:</div><div class="line">    CUDAWrappers::MatrixFree&lt;dim, double&gt;       mf_data;</div><div class="line">    LinearAlgebra::CUDAWrappers::Vector&lt;double&gt; coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  HelmholtzOperator&lt;dim, fe_degree&gt;::HelmholtzOperator(</div><div class="line">    const DoFHandler&lt;dim&gt; &amp;          dof_handler,</div><div class="line">    const AffineConstraints&lt;double&gt; &amp;constraints)</div><div class="line">  {</div><div class="line">    MappingQGeneric&lt;dim&gt; mapping(fe_degree);</div><div class="line">    typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::AdditionalData</div><div class="line">      additional_data;</div><div class="line">    additional_data.mapping_update_flags = update_values | update_gradients |</div><div class="line">                                           update_JxW_values |</div><div class="line">                                           update_quadrature_points;</div><div class="line">    const QGauss&lt;1&gt; quad(fe_degree + 1);</div><div class="line">    mf_data.reinit(mapping, dof_handler, constraints, quad, additional_data);</div><div class="line"></div><div class="line"></div><div class="line">    const unsigned int n_owned_cells =</div><div class="line">      dynamic_cast&lt;const parallel::TriangulationBase&lt;dim&gt; *&gt;(</div><div class="line">        &amp;dof_handler.get_triangulation())</div><div class="line">        -&gt;n_locally_owned_active_cells();</div><div class="line">    coef.reinit(Utilities::pow(fe_degree + 1, dim) * n_owned_cells);</div><div class="line"></div><div class="line">    const VaryingCoefficientFunctor&lt;dim, fe_degree&gt; functor(coef.get_values());</div><div class="line">    mf_data.evaluate_coefficients(functor);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzOperator&lt;dim, fe_degree&gt;::vmult(</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;      dst,</div><div class="line">    const LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;src)</div><div class="line">    const</div><div class="line">  {</div><div class="line">    dst = 0.;</div><div class="line">    LocalHelmholtzOperator&lt;dim, fe_degree&gt; helmholtz_operator(</div><div class="line">      coef.get_values());</div><div class="line">    mf_data.cell_loop(helmholtz_operator, src, dst);</div><div class="line">    mf_data.copy_constrained_values(src, dst);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzOperator&lt;dim, fe_degree&gt;::initialize_dof_vector(</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;vec) const</div><div class="line">  {</div><div class="line">    mf_data.initialize_dof_vector(vec);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzProblem</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    HelmholtzProblem();</div><div class="line"></div><div class="line">    void run();</div><div class="line"></div><div class="line">  private:</div><div class="line">    void setup_system();</div><div class="line"></div><div class="line">    void assemble_rhs();</div><div class="line"></div><div class="line">    void solve();</div><div class="line"></div><div class="line">    void output_results(const unsigned int cycle) const;</div><div class="line"></div><div class="line">    MPI_Comm mpi_communicator;</div><div class="line"></div><div class="line">    parallel::distributed::Triangulation&lt;dim&gt; triangulation;</div><div class="line"></div><div class="line">    FE_Q&lt;dim&gt;       fe;</div><div class="line">    DoFHandler&lt;dim&gt; dof_handler;</div><div class="line"></div><div class="line">    IndexSet locally_owned_dofs;</div><div class="line">    IndexSet locally_relevant_dofs;</div><div class="line"></div><div class="line">    AffineConstraints&lt;double&gt;                          constraints;</div><div class="line">    std::unique_ptr&lt;HelmholtzOperator&lt;dim, fe_degree&gt;&gt; system_matrix_dev;</div><div class="line"></div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</div><div class="line">                                                                  ghost_solution_host;</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; solution_dev;</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</div><div class="line">      system_rhs_dev;</div><div class="line"></div><div class="line">    ConditionalOStream pcout;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  HelmholtzProblem&lt;dim, fe_degree&gt;::HelmholtzProblem()</div><div class="line">    : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , triangulation(mpi_communicator)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);</div><div class="line">    system_rhs_dev.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    constraints.reinit(locally_relevant_dofs);</div><div class="line">    DoFTools::make_hanging_node_constraints(dof_handler, constraints);</div><div class="line">    VectorTools::interpolate_boundary_values(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             Functions::ZeroFunction&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    system_matrix_dev.reset(</div><div class="line">      new HelmholtzOperator&lt;dim, fe_degree&gt;(dof_handler, constraints));</div><div class="line"></div><div class="line">    ghost_solution_host.reinit(locally_owned_dofs,</div><div class="line">                               locally_relevant_dofs,</div><div class="line">                               mpi_communicator);</div><div class="line">    system_matrix_dev-&gt;initialize_dof_vector(solution_dev);</div><div class="line">    system_rhs_dev.reinit(solution_dev);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</div><div class="line">                      system_rhs_host(locally_owned_dofs,</div><div class="line">                      locally_relevant_dofs,</div><div class="line">                      mpi_communicator);</div><div class="line">    const QGauss&lt;dim&gt; quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    FEValues&lt;dim&gt; fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            update_values | update_quadrature_points |</div><div class="line">                              update_JxW_values);</div><div class="line"></div><div class="line">    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    const unsigned int n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    for (const auto &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">      if (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          fe_values.reinit(cell);</div><div class="line"></div><div class="line">          for (unsigned int q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">            {</div><div class="line">              for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                cell_rhs(i) += (fe_values.shape_value(i, q_index) * 1.0 *</div><div class="line">                                fe_values.JxW(q_index));</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 system_rhs_host);</div><div class="line">        }</div><div class="line">    system_rhs_host.compress(VectorOperation::add);</div><div class="line"></div><div class="line">    LinearAlgebra::ReadWriteVector&lt;double&gt; rw_vector(locally_owned_dofs);</div><div class="line">    rw_vector.import(system_rhs_host, VectorOperation::insert);</div><div class="line">    system_rhs_dev.import(rw_vector, VectorOperation::insert);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">  {</div><div class="line">    PreconditionIdentity preconditioner;</div><div class="line"></div><div class="line">    SolverControl solver_control(system_rhs_dev.size(),</div><div class="line">                                 1e-12 * system_rhs_dev.l2_norm());</div><div class="line">    SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;&gt; cg(</div><div class="line">      solver_control);</div><div class="line">    cg.solve(*system_matrix_dev, solution_dev, system_rhs_dev, preconditioner);</div><div class="line"></div><div class="line">    pcout &lt;&lt; &quot;  Solved in &quot; &lt;&lt; solver_control.last_step() &lt;&lt; &quot; iterations.&quot;</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    LinearAlgebra::ReadWriteVector&lt;double&gt; rw_vector(locally_owned_dofs);</div><div class="line">    rw_vector.import(solution_dev, VectorOperation::insert);</div><div class="line">    ghost_solution_host.import(rw_vector, VectorOperation::insert);</div><div class="line"></div><div class="line">    constraints.distribute(ghost_solution_host);</div><div class="line"></div><div class="line">    ghost_solution_host.update_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::output_results(</div><div class="line">    const unsigned int cycle) const</div><div class="line">  {</div><div class="line">    DataOut&lt;dim&gt; data_out;</div><div class="line"></div><div class="line">    data_out.attach_dof_handler(dof_handler);</div><div class="line">    data_out.add_data_vector(ghost_solution_host, &quot;solution&quot;);</div><div class="line">    data_out.build_patches();</div><div class="line"></div><div class="line">    DataOutBase::VtkFlags flags;</div><div class="line">    flags.compression_level = DataOutBase::VtkFlags::best_speed;</div><div class="line">    data_out.set_flags(flags);</div><div class="line">    data_out.write_vtu_with_pvtu_record(</div><div class="line">      &quot;./&quot;, &quot;solution&quot;, cycle, mpi_communicator, 2);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; cellwise_norm(triangulation.n_active_cells());</div><div class="line">    VectorTools::integrate_difference(dof_handler,</div><div class="line">                                      ghost_solution_host,</div><div class="line">                                      Functions::ZeroFunction&lt;dim&gt;(),</div><div class="line">                                      cellwise_norm,</div><div class="line">                                      QGauss&lt;dim&gt;(fe.degree + 2),</div><div class="line">                                      VectorTools::L2_norm);</div><div class="line">    const double global_norm =</div><div class="line">      VectorTools::compute_global_error(triangulation,</div><div class="line">                                        cellwise_norm,</div><div class="line">                                        VectorTools::L2_norm);</div><div class="line">    pcout &lt;&lt; &quot;  solution norm: &quot; &lt;&lt; global_norm &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::run()</div><div class="line">  {</div><div class="line">    for (unsigned int cycle = 0; cycle &lt; 7 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; &quot;Cycle &quot; &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        if (cycle == 0)</div><div class="line">          GridGenerator::hyper_cube(triangulation, 0., 1.);</div><div class="line">        triangulation.refine_global(1);</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; &quot;   Number of active cells:       &quot;</div><div class="line">              &lt;&lt; triangulation.n_global_active_cells() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; &quot;   Number of degrees of freedom: &quot; &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} // namespace Step64</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">{</div><div class="line">  try</div><div class="line">    {</div><div class="line">      using namespace Step64;</div><div class="line"></div><div class="line">      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      int         n_devices       = 0;</div><div class="line">      cudaError_t cuda_error_code = cudaGetDeviceCount(&amp;n_devices);</div><div class="line">      AssertCuda(cuda_error_code);</div><div class="line">      const unsigned int my_mpi_id =</div><div class="line">        Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);</div><div class="line">      const int device_id = my_mpi_id % n_devices;</div><div class="line">      cuda_error_code     = cudaSetDevice(device_id);</div><div class="line">      AssertCuda(cuda_error_code);</div><div class="line"></div><div class="line">      HelmholtzProblem&lt;3, 3&gt; helmholtz_problem;</div><div class="line">      helmholtz_problem.run();</div><div class="line">    }</div><div class="line">  catch (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; &quot;Exception on processing: &quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      return 1;</div><div class="line">    }</div><div class="line">  catch (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; &quot;Unknown exception!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  return 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
