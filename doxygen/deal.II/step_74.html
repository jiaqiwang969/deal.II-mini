<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_74.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-74 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-74 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_12.html">step-12</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Overview">Overview</a>
        <li><a href="#Theequation">The equation</a>
        <li><a href="#Thepenaltyparameter">The penalty parameter</a>
        <li><a href="#Aposteriorierrorestimator">A posteriori error estimator</a>
        <li><a href="#Thetestcase">The test case</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Auxiliaryfunctions">Auxiliary functions</a>
        <li><a href="#TheCopyData">The CopyData</a>
        <li><a href="#TheSIPGLaplaceclass">The SIPGLaplace class</a>
        <li><a href="#Theassemble_systemfunction">The assemble_system function</a>
        <li><a href="#Thesolveandoutput_resultsfunction">The solve() and output_results() function</a>
        <li><a href="#Thecompute_error_estimatefunction">The compute_error_estimate() function</a>
        <li><a href="#Thecompute_energy_norm_errorfunction">The compute_energy_norm_error() function</a>
        <li><a href="#Therefine_gridfunction">The refine_grid() function</a>
        <li><a href="#Thecompute_errorsfunction">The compute_errors() function</a>
        <li><a href="#Therunfunction">The run() function</a>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-74/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Timo Heister and Jiaqi Zhang. <br />
 This material is based upon work partly supported by the National Science Foundation Award DMS-2028346, OAC-2015848, EAR-1925575, by the Computational Infrastructure in Geodynamics initiative (CIG), through the NSF under Award EAR-0949446 and EAR-1550901 and The University of California &ndash; Davis. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="emSymmetricinteriorpenaltyGalerkinemSIPGmethodforPoissonsequation"></a></p><h1><em>Symmetric interior penalty Galerkin</em> (SIPG) method for Poisson's equation</h1>
<p><a class="anchor" id="Overview"></a></p><h3>Overview</h3>
<p>在本教程中，我们展示了FEInterfaceValues类的用法，该类是为组装由不连续加尔金（DG）方法产生的面项而设计的。FEInterfaceValues类提供了一种简单的方法来获得形状函数的跳变和平均值以及跨单元面的解。本教程包括以下内容。</p><ol>
<li>
泊松方程的SIPG方法，在步骤39和步骤59中已经使用过。 </li>
<li>
使用FEInterfaceValues组装面项，使用 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>, 组装系统矩阵，这与步骤12类似。 </li>
<li>
使用误差估计器进行自适应网格细化。 </li>
<li>
两个测试案例：平滑函数的收敛测试和奇异解的适应性网格细化测试。 </li>
</ol>
<p><a class="anchor" id="Theequation"></a></p><h3>The equation</h3>
<p>在这个例子中，我们考虑泊松方程</p>
<p class="formulaDsp">
\[ - \nabla \cdot \left( \nu \nabla u\right) = f \qquad \mbox{in } \Omega, \]
</p>
<p>受制于边界条件</p>
<p class="formulaDsp">
\[ u = g_D \qquad \mbox{on } \partial \Omega. \]
</p>
<p>为了简单起见，我们假设扩散系数 \(\nu\) 在这里是常数。注意，如果 \(\nu\) 是不连续的，我们在计算单元面的跳跃项时需要考虑到这一点。</p>
<p>我们用 \({\mathbb T}_h\) 表示网格， \(K\in{\mathbb T}_h\) 是一个网格单元。内部和边界面的集合分别用 \({\mathbb F}^i_h\) 和 \({\mathbb F}^b_h\) 表示。让 \(K^0\) 和 \(K^1\) 是共享一个面 \(f\in F_h^i\) 的两个单元， \(\mathbf n\) 是 \(K^0\) 的外法向量。那么跳跃算子由 "这里减去那里 "公式给出。</p>
<p class="formulaDsp">
\[ \jump{v} = v^0 - v^1 \]
</p>
<p>和平均运算符为</p>
<p class="formulaDsp">
\[ \average{v} = \frac{v^0 + v^1}{2} \]
</p>
<p>分别。请注意，当 \(f\subset \partial \Omega\) 时，我们定义 \(\jump{v} = v\) 和 \(\average{v}=v\) 。使用SIPG的离散化由以下弱式给出（更多细节可以在 <b>[di2011mathematical]</b> 和其中的参考文献中找到）。</p>
<p class="formulaDsp">
\begin{align*} &amp;\sum_{K\in {\mathbb T}_h} (\nabla v_h, \nu \nabla u_h)_K\\ &amp;-\sum_{F \in F_h^i} \left\{ \left&lt; \jump{v_h}, \nu\average{ \nabla u_h} \cdot \mathbf n \right&gt;_F +\left&lt;\average{ \nabla v_h }\cdot \mathbf n,\nu\jump{u_h}\right&gt;_F -\left&lt;\jump{v_h},\nu \sigma \jump{u_h} \right&gt;_F \right\}\\ &amp;-\sum_{F \in F_h^b} \left\{ \left&lt;v_h, \nu \nabla u_h\cdot \mathbf n \right&gt;_F + \left&lt; \nabla v_h \cdot \mathbf n , \nu u_h\right&gt;_F - \left&lt; v_h,\nu \sigma u_h\right&gt;_F \right\}\\ &amp;=(v_h, f)_\Omega - \sum_{F \in F_h^b} \left\{ \left&lt; \nabla v_h \cdot \mathbf n, \nu g_D\right&gt;_F - \left&lt;v_h,\nu \sigma g_D\right&gt;_F \right\}. \end{align*}
</p>
<p><a class="anchor" id="Thepenaltyparameter"></a></p><h3>The penalty parameter</h3>
<p>惩罚参数定义为 \(\sigma = \gamma/h_f\) ，其中 \(h_f\) 是与细胞面相关的局部长度尺度；这里我们选择细胞在面的法线方向的长度近似值。 \(\frac 1{h_f} = \frac 12 \left(\frac 1{h_K} + \frac 1{h_{K&#39;}}\right)\) ，其中 \(K,K&#39;\) 是与面相邻的两个单元 \(f\) ，我们我们计算 \(h_K = \frac{|K|}{|f|}\) 。</p>
<p>在上述公式中， \(\gamma\) 是惩罚常数。为了确保离散矫捷性，惩罚常数必须足够大 <b>[ainsworth2007posteriori]</b> 。对于文献中提出的哪些公式应该被使用，人们并没有真正达成共识。这与第47步的 "结果 "部分讨论的情况类似）。人们可以直接挑选一个大的常数，而其他选择可以是 \((p+1)^2\) 或 \(p(p+1)\) 的倍数。在这段代码中，我们遵循步骤39，使用 \(\gamma = p(p+1)\) 。</p>
<p><a class="anchor" id="Aposteriorierrorestimator"></a></p><h3>A posteriori error estimator</h3>
<p>在这个例子中，稍作修改，我们使用Karakashian和Pascal的误差估计器 <b>[karakashian2003posteriori]</b> 。</p>
<p class="formulaDsp">
\[ \eta^2 = \sum_{K \in {\mathbb T}_h} \eta^2_{K} + \sum_{f_i \in {\mathbb F}^i_h} \eta^2_{f_i} + \sum_{f_b \in F^i_b}\eta^2_{f_b} \]
</p>
<p>其中</p>
<p class="formulaDsp">
\begin{align*} \eta^2_{K} &amp;= h_K^2 \left\| f + \nu \Delta u_h \right\|_K^2, \\ \eta^2_{f_i} &amp;= \sigma \left\| \jump{u_h} \right\|_f^2 + h_f \left\| \jump{\nu \nabla u_h} \cdot \mathbf n \right\|_f^2, \\ \eta_{f_b}^2 &amp;= \sigma \left\| u_h-g_D \right\|_f^2. \end{align*}
</p>
<p>这里我们用 \(\sigma = \gamma/h_f\) 代替 \(\gamma^2/h_f\) 来表示 \(u_h\) 的跳跃项（ \(\eta^2_{f_i}\) 和 \(\eta_{f_b}^2\) 的第一个项）。</p>
<p>为了计算这个估计值，在每个单元格 \(K\) 中，我们计算出</p>
<p class="formulaDsp">
\begin{align*} \eta_{c}^2 &amp;= h_K^2 \left\| f + \nu \Delta u_h \right\|_K^2, \\ \eta_{f}^2 &amp;= \sum_{f\in \partial K}\lbrace \sigma \left\| \jump{u_h} \right\|_f^2 + h_f \left\| \jump{\nu \nabla u_h} \cdot \mathbf n \right\|_f^2 \rbrace, \\ \eta_{b}^2 &amp;= \sum_{f\in \partial K \cap \partial \Omega} \sigma \left\| (u_h -g_D) \right\|_f^2. \end{align*}
</p>
<p>那么每个单元的误差估计的平方是</p>
<p class="formulaDsp">
\[ \eta_\text{local}^2 =\eta_{c}^2+0.5\eta_{f}^2+\eta_{b}^2. \]
</p>
<p>\(0.5\) 的系数是由于整体误差估计器只包括每个内部面一次，所以每个单元的估计器对它的计算是相邻两个单元的一半系数。注意，我们计算 \(\eta_\text{local}^2\) 而不是 \(\eta_\text{local}\) 以简化实现。然后，每个单元的误差估计方被存储在一个全局向量中，其 \(l_1\) 准则等于 \(\eta^2\) 。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>在第一个测试问题中，我们使用二维的 \(\nu =1\) 平滑制造的解决方案来进行收敛测试</p>
<p class="formulaDsp">
\begin{align*} u&amp;=\sin(2\pi x)\sin(2\pi y), &amp;\qquad\qquad &amp;(x,y)\in\Omega=(0,1)\times (0,1), \\ u&amp;=0, &amp;\qquad\qquad &amp;\text{on } \partial \Omega, \end{align*}
</p>
<p>和 \(f= 8\pi^2 u\) 。我们针对制造的解决方案计算误差并评估收敛率。</p>
<p>在第二个测试中，我们在二维的L形域 <a class="el" href="classFunctions_1_1LSingularityFunction.html">Functions::LSingularityFunction</a> 上选择 (<a class="el" href="namespaceGridGenerator.html#a3b2a4ad8296c2b72a11d23b5969e8cc0">GridGenerator::hyper_L</a>) 。该解在极坐标中由 \(u(r,\phi) = r^{\frac{2}{3}}\sin \left(\frac{2}{3}\phi \right)\) 给出，它在原点有一个奇点。构建了一个误差估计器来检测有大误差的区域，根据这个估计器来自适应地细化网格。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The first few files have already been covered in previous examples and will thus not be further commented on:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__lib_8h.html">deal.II/base/function_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span></div></div><!-- fragment --><p>Here the discontinuous finite elements and <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> are defined.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="convergence__table_8h.html">deal.II/base/convergence_table.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step74</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Here we define two test cases: convergence_rate for a smooth function and l_singularity for the <a class="el" href="classFunctions_1_1LSingularityFunction.html">Functions::LSingularityFunction</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> TestCase</div><div class="line">{</div><div class="line">  convergence_rate,</div><div class="line">  l_singularity</div><div class="line">};</div></div><!-- fragment --><p>A smooth solution for the convergence test:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SmoothSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SmoothSolution()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">  <a class="code" href="classFunction.html#a4b0aadc89a827b39c20f12889aa88625">gradient</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; point,</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SmoothSolution&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">    values[i] =</div><div class="line">      std::sin(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * points[i][0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * points[i][1]);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">SmoothSolution&lt;dim&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;point,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> return_value;</div><div class="line">  <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  return_value[0] =</div><div class="line">    2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * point[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * point[1]);</div><div class="line">  return_value[1] =</div><div class="line">    2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * point[0]) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * point[1]);</div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p>The corresponding right-hand side of the smooth function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SmoothRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SmoothRightHandSide()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">SmoothRightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">    values[i] = 8. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * std::sin(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * points[i][0]) *</div><div class="line">                <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * points[i][1]);</div><div class="line">}</div></div><!-- fragment --><p>The right-hand side that corresponds to the function <a class="el" href="classFunctions_1_1LSingularityFunction.html">Functions::LSingularityFunction</a>, where we assume that the diffusion coefficient \(\nu = 1\):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SingularRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SingularRightHandSide()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1LSingularityFunction.html">Functions::LSingularityFunction</a> ref;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">SingularRightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">    values[i] = -ref.laplacian(points[i]);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Auxiliaryfunctions"></a> </p><h3>Auxiliary functions</h3>
<p>The following two auxiliary functions are used to compute jump terms for \(u_h\) and \(\nabla u_h\) on a face, respectively.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> get_function_jump(<span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv,</div><div class="line">                       <span class="keyword">const</span> Vector&lt;double&gt; &amp;        solution,</div><div class="line">                       std::vector&lt;double&gt; &amp;         jump)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                 n_q = fe_iv.<a class="code" href="classFEInterfaceValues.html#a41f6734be1313f750fa8b3b7ba470f35">n_quadrature_points</a>;</div><div class="line">  std::array&lt;std::vector&lt;double&gt;, 2&gt; face_values;</div><div class="line">  jump.resize(n_q);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 2; ++i)</div><div class="line">    {</div><div class="line">      face_values[i].resize(n_q);</div><div class="line">      fe_iv.<a class="code" href="classFEInterfaceValues.html#a6ac7ddd5ac77cc4a1925ec5f0b100bf2">get_fe_face_values</a>(i).get_function_values(solution,</div><div class="line">                                                      face_values[i]);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q; ++q)</div><div class="line">    jump[q] = face_values[0][q] - face_values[1][q];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> get_function_gradient_jump(<span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv,</div><div class="line">                                <span class="keyword">const</span> Vector&lt;double&gt; &amp;        solution,</div><div class="line">                                std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp; gradient_jump)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          n_q = fe_iv.<a class="code" href="classFEInterfaceValues.html#a41f6734be1313f750fa8b3b7ba470f35">n_quadrature_points</a>;</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; face_gradients[2];</div><div class="line">  gradient_jump.resize(n_q);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 2; ++i)</div><div class="line">    {</div><div class="line">      face_gradients[i].resize(n_q);</div><div class="line">      fe_iv.<a class="code" href="classFEInterfaceValues.html#a6ac7ddd5ac77cc4a1925ec5f0b100bf2">get_fe_face_values</a>(i).get_function_gradients(solution,</div><div class="line">                                                         face_gradients[i]);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q; ++q)</div><div class="line">    gradient_jump[q] = face_gradients[0][q] - face_gradients[1][q];</div><div class="line">}</div></div><!-- fragment --><p>This function computes the penalty \(\sigma\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> get_penalty_factor(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span>       cell_extent_left,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">double</span>       cell_extent_right)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(1U, fe_degree);</div><div class="line">  <span class="keywordflow">return</span> degree * (degree + 1.) * 0.5 *</div><div class="line">         (1. / cell_extent_left + 1. / cell_extent_right);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheCopyData"></a> </p><h3>The CopyData</h3>
<p>In the following, we define "Copy" objects for the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>, which is essentially the same as <a class="el" href="step_12.html">step-12</a>. Note that the "Scratch" object is not defined here because we use MeshWorker::ScratchData&lt;dim&gt; instead. (The use of "Copy" and "Scratch" objects is extensively explained in the <a class="el" href="namespaceWorkStream.html">WorkStream</a> namespace documentation.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CopyDataFace</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; joint_dof_indices;</div><div class="line">  std::array&lt;double, 2&gt;                <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>;</div><div class="line">  std::array&lt;unsigned int, 2&gt;          cell_indices;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyData</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  Vector&lt;double&gt;                       cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  std::vector&lt;CopyDataFace&gt;            face_data;</div><div class="line">  <span class="keywordtype">double</span>                               value;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                         <a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">  {</div><div class="line">    cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">    cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dofs_per_cell);</div><div class="line">    local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheSIPGLaplaceclass"></a> </p><h3>The SIPGLaplace class</h3>
<p>After these preparations, we proceed with the main class of this program, called <code>SIPGLaplace</code>. The overall structure of the class is as in many of the other tutorial programs. Major differences will only come up in the implementation of the assemble functions, since we use <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> to assemble face terms.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SIPGLaplace</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SIPGLaplace(<span class="keyword">const</span> TestCase &amp;test_case);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span>   compute_errors();</div><div class="line">  <span class="keywordtype">void</span>   compute_error_estimate();</div><div class="line">  <span class="keywordtype">double</span> compute_energy_norm_error();</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    degree;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_overintegration;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_overintegration;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>  mapping;</div><div class="line"></div><div class="line">  <span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt; system_matrix;</div><div class="line">  Vector&lt;double&gt;       solution;</div><div class="line">  Vector&lt;double&gt;       system_rhs;</div></div><!-- fragment --><p>The remainder of the class's members are used for the following:</p><ul>
<li>Vectors to store error estimator square and energy norm square per cell.</li>
<li>Print convergence rate and errors on the screen.</li>
<li>The fiffusion coefficient \(\nu\) is set to 1.</li>
<li>Members that store information about the test case to be computed.</li>
</ul>
<div class="fragment"><div class="line">  Vector&lt;double&gt; estimated_error_square_per_cell;</div><div class="line">  Vector&lt;double&gt; energy_norm_square_per_cell;</div><div class="line"></div><div class="line">  <a class="code" href="classConvergenceTable.html">ConvergenceTable</a> convergence_table;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient = 1.;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> TestCase                       test_case;</div><div class="line">  std::unique_ptr&lt;const Function&lt;dim&gt;&gt; exact_solution;</div><div class="line">  std::unique_ptr&lt;const Function&lt;dim&gt;&gt; rhs_function;</div><div class="line">};</div></div><!-- fragment --><p>The constructor here takes the test case as input and then determines the correct solution and right-hand side classes. The remaining member variables are initialized in the obvious way.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SIPGLaplace&lt;dim&gt;::SIPGLaplace(<span class="keyword">const</span> TestCase &amp;test_case)</div><div class="line">  : degree(3)</div><div class="line">  , quadrature(degree + 1)</div><div class="line">  , face_quadrature(degree + 1)</div><div class="line">  , quadrature_overintegration(degree + 2)</div><div class="line">  , face_quadrature_overintegration(degree + 2)</div><div class="line">  , mapping()</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , test_case(test_case)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (test_case == TestCase::convergence_rate)</div><div class="line">    {</div><div class="line">      exact_solution = std::make_unique&lt;const SmoothSolution&lt;dim&gt;&gt;();</div><div class="line">      rhs_function   = std::make_unique&lt;const SmoothRightHandSide&lt;dim&gt;&gt;();</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (test_case == TestCase::l_singularity)</div><div class="line">    {</div><div class="line">      exact_solution =</div><div class="line">        std::make_unique&lt;const Functions::LSingularityFunction&gt;();</div><div class="line">      rhs_function = std::make_unique&lt;const SingularRightHandSide&lt;dim&gt;&gt;();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Theassemble_systemfunction"></a> </p><h3>The assemble_system function</h3>
<p>The assemble function here is similar to that in <a class="el" href="step_12.html">step-12</a> and <a class="el" href="step_47.html">step-47</a>. Different from assembling by hand, we just need to focus on assembling on each cell, each boundary face, and each interior face. The loops over cells and faces are handled automatically by <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>.</p>
<p>The function starts by defining a local (lambda) function that is used to integrate the cell terms:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker =</div><div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell, <span class="keyword">auto</span> &amp;scratch_data, <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v          = scratch_data.reinit(cell);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">      copy_data.reinit(cell, dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points    = scratch_data.get_quadrature_points();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points  = q_points.size();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = scratch_data.get_JxW_values();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; rhs(n_q_points);</div><div class="line">      rhs_function-&gt;value_list(q_points, rhs);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                diffusion_coefficient *     <span class="comment">// nu</span></div><div class="line">                fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, point) * <span class="comment">// grad v_h</span></div><div class="line">                fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, point) * <span class="comment">// grad u_h</span></div><div class="line">                JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                 <span class="comment">// dx</span></div><div class="line"></div><div class="line">            copy_data.cell_rhs(i) += fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, point) * <span class="comment">// v_h</span></div><div class="line">                                     rhs[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] *                 <span class="comment">// f</span></div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                  <span class="comment">// dx</span></div><div class="line">          }</div><div class="line">    };</div></div><!-- fragment --><p>Next, we need a function that assembles face integrals on the boundary:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_fv = scratch_data.reinit(cell, face_no);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points      = scratch_data.get_quadrature_points();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = q_points.size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_fv.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW = scratch_data.get_JxW_values();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals =</div><div class="line">    scratch_data.get_normal_vectors();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; g(n_q_points);</div><div class="line">  exact_solution-&gt;value_list(q_points, g);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(face_no)-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          copy_data.cell_matrix(i, j) +=</div><div class="line">            (-diffusion_coefficient *        <span class="comment">// - nu</span></div><div class="line">               fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, point) * <span class="comment">// v_h</span></div><div class="line">               (fe_fv.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, point) * <span class="comment">// (grad u_h .</span></div><div class="line">                normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>])              <span class="comment">//  n)</span></div><div class="line"></div><div class="line">             - diffusion_coefficient *         <span class="comment">// - nu</span></div><div class="line">                 (fe_fv.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, point) * <span class="comment">// (grad v_h .</span></div><div class="line">                  normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) *            <span class="comment">//  n)</span></div><div class="line">                 fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, point)   <span class="comment">// u_h</span></div><div class="line"></div><div class="line">             + diffusion_coefficient * penalty * <span class="comment">// + nu sigma</span></div><div class="line">                 fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, point) *   <span class="comment">// v_h</span></div><div class="line">                 fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, point)     <span class="comment">// u_h</span></div><div class="line"></div><div class="line">             ) *</div><div class="line">            JxW[point]; <span class="comment">// dx</span></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        copy_data.cell_rhs(i) +=</div><div class="line">          (-diffusion_coefficient *        <span class="comment">// - nu</span></div><div class="line">             (fe_fv.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, point) * <span class="comment">// (grad v_h .</span></div><div class="line">              normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) *            <span class="comment">//  n)</span></div><div class="line">             g[point]                      <span class="comment">// g</span></div><div class="line"></div><div class="line"></div><div class="line">           + diffusion_coefficient * penalty *        <span class="comment">// + nu sigma</span></div><div class="line">               fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, point) * g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] <span class="comment">// v_h g</span></div><div class="line"></div><div class="line">           ) *</div><div class="line">          JxW[point]; <span class="comment">// dx</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>Finally, a function that assembles face integrals on interior faces. To reinitialize <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a>, we need to pass cells, face and subface indices (for adaptive refinement) to the <a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a> function of <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                             <span class="keyword">const</span> <span class="keyword">auto</span> &amp;        ncell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                             <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                             <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv =</div><div class="line">    scratch_data.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points   = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">  copy_data.face_data.emplace_back();</div><div class="line">  CopyDataFace &amp;     copy_data_face = copy_data.face_data.back();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_face    = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>();</div><div class="line">  copy_data_face.joint_dof_indices  = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>();</div><div class="line">  copy_data_face.cell_matrix.reinit(n_dofs_face, n_dofs_face);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(f)-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> extent2 = ncell-&gt;measure() / ncell-&gt;face(nf)-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent2);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs_face; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs_face; ++j)</div><div class="line">          copy_data_face.cell_matrix(i, j) +=</div><div class="line">            (-diffusion_coefficient *              <span class="comment">// - nu</span></div><div class="line">               fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, point) *              <span class="comment">// [v_h]</span></div><div class="line">               (fe_iv.<a class="code" href="classFEInterfaceValues.html#a5614dd141462972c80d8733ba1d823f0">average_gradient</a>(j, point) * <span class="comment">// ({grad u_h} .</span></div><div class="line">                normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>])                    <span class="comment">//  n)</span></div><div class="line"></div><div class="line">             - diffusion_coefficient *               <span class="comment">// - nu</span></div><div class="line">                 (fe_iv.<a class="code" href="classFEInterfaceValues.html#a5614dd141462972c80d8733ba1d823f0">average_gradient</a>(i, point) * <span class="comment">// (grad v_h .</span></div><div class="line">                  normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) *                  <span class="comment">//  n)</span></div><div class="line">                 fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(j, point)                <span class="comment">// [u_h]</span></div><div class="line"></div><div class="line">             + diffusion_coefficient * penalty * <span class="comment">// + nu sigma</span></div><div class="line">                 fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, point) *          <span class="comment">// [v_h]</span></div><div class="line">                 fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(j, point)            <span class="comment">// [u_h]</span></div><div class="line"></div><div class="line">             ) *</div><div class="line">            JxW[point]; <span class="comment">// dx</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The following lambda function will then copy data into the global matrix and right-hand side. Though there are no hanging node constraints in DG discretization, we define an empty <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object that allows us to use the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> functionality.</p>
<div class="fragment"><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c) {</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix,</div><div class="line">                                         c.cell_rhs,</div><div class="line">                                         c.local_dof_indices,</div><div class="line">                                         system_matrix,</div><div class="line">                                         system_rhs);</div></div><!-- fragment --><p>Copy data from interior face assembly to the global matrix.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data)</div><div class="line">    {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix,</div><div class="line">                                             cdf.joint_dof_indices,</div><div class="line">                                             system_matrix);</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>With the assembly functions defined, we can now create ScratchData and CopyData objects, and pass them together with the lambda functions above to <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. In addition, we need to specify that we want to assemble on interior faces exactly once.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> cell_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line"></div><div class="line">  ScratchData scratch_data(</div><div class="line">    mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);</div><div class="line">  CopyData copy_data;</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>,</div><div class="line">                        boundary_worker,</div><div class="line">                        face_worker);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thesolveandoutput_resultsfunction"></a> </p><h3>The solve() and output_results() function</h3>
<p>The following two functions are entirely standard and without difficulty.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">  A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;sol_Q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(degree, 1) +</div><div class="line">                               <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecompute_error_estimatefunction"></a> </p><h3>The compute_error_estimate() function</h3>
<p>The assembly of the error estimator here is quite similar to that of the global matrix and right-had side and can be handled by the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> framework. To understand what each of the local (lambda) functions is doing, recall first that the local cell residual is defined as \(h_K^2 \left\| f + \nu \Delta u_h \right\|_K^2\):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::compute_error_estimate()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker =</div><div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell, <span class="keyword">auto</span> &amp;scratch_data, <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      copy_data.cell_index = cell-&gt;active_cell_index();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;               q_points   = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>         n_q_points = q_points.size();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW        = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;2, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaccf663e018d31c264b769c80bd91db4d">hessians</a>(n_q_points);</div><div class="line">      fe_v.<a class="code" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">get_function_hessians</a>(solution, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaccf663e018d31c264b769c80bd91db4d">hessians</a>);</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; rhs(n_q_points);</div><div class="line">      rhs_function-&gt;value_list(q_points, rhs);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> hk                   = cell-&gt;diameter();</div><div class="line">      <span class="keywordtype">double</span>       residual_norm_square = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">            rhs[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] + diffusion_coefficient * <a class="code" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a>(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaccf663e018d31c264b769c80bd91db4d">hessians</a>[point]);</div><div class="line">          residual_norm_square += residual * residual * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">        }</div><div class="line">      copy_data.value = hk * hk * residual_norm_square;</div><div class="line">    };</div></div><!-- fragment --><p>Next compute boundary terms \(\sum_{f\in \partial K \cap \partial \Omega} \sigma \left\| [ u_h-g_D ] \right\|_f^2 \):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_fv = scratch_data.reinit(cell, face_no);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;   q_points   = fe_fv.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_fv.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; g(n_q_points);</div><div class="line">  exact_solution-&gt;value_list(q_points, g);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; sol_u(n_q_points);</div><div class="line">  fe_fv.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, sol_u);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(face_no)-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent1);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> difference_norm_square = 0.;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> diff = (g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] - sol_u[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">      difference_norm_square += diff * diff * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">    }</div><div class="line">  copy_data.value += penalty * difference_norm_square;</div><div class="line">};</div></div><!-- fragment --><p>And finally interior face terms \(\sum_{f\in \partial K}\lbrace \sigma \left\| [u_h] \right\|_f^2 + h_f \left\| [\nu \nabla u_h \cdot \mathbf n ] \right\|_f^2 \rbrace\):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                             <span class="keyword">const</span> <span class="keyword">auto</span> &amp;        ncell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                             <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                             <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv =</div><div class="line">    scratch_data.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line"></div><div class="line">  copy_data.face_data.emplace_back();</div><div class="line">  CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">  copy_data_face.cell_indices[0] = cell-&gt;active_cell_index();</div><div class="line">  copy_data_face.cell_indices[1] = ncell-&gt;active_cell_index();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points   = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; jump(n_q_points);</div><div class="line">  get_function_jump(fe_iv, solution, jump);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_jump(n_q_points);</div><div class="line">  get_function_gradient_jump(fe_iv, solution, grad_jump);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> h = cell-&gt;face(f)-&gt;diameter();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(f)-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> extent2 = ncell-&gt;measure() / ncell-&gt;face(nf)-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent2);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> flux_jump_square = 0;</div><div class="line">  <span class="keywordtype">double</span> u_jump_square    = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">    {</div><div class="line">      u_jump_square += jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> flux_jump = grad_jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">      flux_jump_square +=</div><div class="line">        diffusion_coefficient * flux_jump * flux_jump * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">    }</div><div class="line">  copy_data_face.values[0] =</div><div class="line">    0.5 * h * (flux_jump_square + penalty * u_jump_square);</div><div class="line">  copy_data_face.values[1] = copy_data_face.values[0];</div><div class="line">};</div></div><!-- fragment --><p>Having computed local contributions for each cell, we still need a way to copy these into the global vector that will hold the error estimators for all cells:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">  <span class="keywordflow">if</span> (copy_data.cell_index != <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</div><div class="line">    estimated_error_square_per_cell[copy_data.cell_index] +=</div><div class="line">      copy_data.value;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : copy_data.face_data)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 2; ++j)</div><div class="line">      estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];</div><div class="line">};</div></div><!-- fragment --><p>After all of this set-up, let's do the actual work: We resize the vector into which the results will be written, and then drive the whole process using the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> function.</p>
<div class="fragment"><div class="line">  estimated_error_square_per_cell.reinit(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> cell_flags =</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>;</div><div class="line"></div><div class="line">  ScratchData scratch_data(</div><div class="line">    mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);</div><div class="line"></div><div class="line">  CopyData copy_data;</div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a>,</div><div class="line">                        boundary_worker,</div><div class="line">                        face_worker);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecompute_energy_norm_errorfunction"></a> </p><h3>The compute_energy_norm_error() function</h3>
<p>Next, we evaluate the accuracy in terms of the energy norm. This function is similar to the assembling of the error estimator above. Here we compute the square of the energy norm defined by </p><p class="formulaDsp">
\[ \|u \|_{1,h}^2 = \sum_{K \in \Gamma_h} \nu\|\nabla u \|_K^2 + \sum_{f \in F_i} \sigma \| [ u ] \|_f^2 + \sum_{f \in F_b} \sigma \|u\|_f^2. \]
</p>
<p> Therefore the corresponding error is </p><p class="formulaDsp">
\[ \|u -u_h \|_{1,h}^2 = \sum_{K \in \Gamma_h} \nu\|\nabla (u_h - u) \|_K^2 + \sum_{f \in F_i} \sigma \|[ u_h ] \|_f^2 + \sum_{f \in F_b}\sigma \|u_h-g_D\|_f^2. \]
</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> SIPGLaplace&lt;dim&gt;::compute_energy_norm_error()</div><div class="line">{</div><div class="line">  energy_norm_square_per_cell.reinit(triangulation.n_active_cells());</div></div><!-- fragment --><p>Assemble \(\sum_{K \in \Gamma_h} \nu\|\nabla (u_h - u) \|_K^2 \).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker =</div><div class="line">  [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell, <span class="keyword">auto</span> &amp;scratch_data, <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    copy_data.cell_index = cell-&gt;active_cell_index();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;               q_points   = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>         n_q_points = q_points.size();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW        = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_u(n_q_points);</div><div class="line">    fe_v.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(solution, grad_u);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_exact(n_q_points);</div><div class="line">    exact_solution-&gt;gradient_list(q_points, grad_exact);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> norm_square = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">      {</div><div class="line">        norm_square +=</div><div class="line">          (grad_u[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] - grad_exact[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]).norm_square() * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">      }</div><div class="line">    copy_data.value = diffusion_coefficient * norm_square;</div><div class="line">  };</div></div><!-- fragment --><p>Assemble \(\sum_{f \in F_b}\sigma \|u_h-g_D\|_f^2\).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_fv = scratch_data.reinit(cell, face_no);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;   q_points   = fe_fv.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_fv.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; g(n_q_points);</div><div class="line">  exact_solution-&gt;value_list(q_points, g);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; sol_u(n_q_points);</div><div class="line">  fe_fv.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, sol_u);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(face_no)-&gt;measure();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent1);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> difference_norm_square = 0.;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> diff = (g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] - sol_u[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">      difference_norm_square += diff * diff * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">    }</div><div class="line">  copy_data.value += penalty * difference_norm_square;</div><div class="line">};</div></div><!-- fragment --><p>Assemble \(\sum_{f \in F_i} \sigma \| [ u_h ] \|_f^2\).</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                               <span class="keyword">const</span> <span class="keyword">auto</span> &amp;        ncell,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                               <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                               <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv =</div><div class="line">      scratch_data.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line"></div><div class="line">    copy_data.face_data.emplace_back();</div><div class="line">    CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">    copy_data_face.cell_indices[0] = cell-&gt;active_cell_index();</div><div class="line">    copy_data_face.cell_indices[1] = ncell-&gt;active_cell_index();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points   = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; jump(n_q_points);</div><div class="line">    get_function_jump(fe_iv, solution, jump);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(f)-&gt;measure();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> extent2 = ncell-&gt;measure() / ncell-&gt;face(nf)-&gt;measure();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent2);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> u_jump_square = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">      {</div><div class="line">        u_jump_square += jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">      }</div><div class="line">    copy_data_face.values[0] = 0.5 * penalty * u_jump_square;</div><div class="line">    copy_data_face.values[1] = copy_data_face.values[0];</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">    <span class="keywordflow">if</span> (copy_data.cell_index != <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</div><div class="line">      energy_norm_square_per_cell[copy_data.cell_index] += copy_data.value;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : copy_data.face_data)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 2; ++j)</div><div class="line">        energy_norm_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> cell_flags =</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_flags =</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ScratchData scratch_data(mapping,</div><div class="line">                                 fe,</div><div class="line">                                 quadrature_overintegration,</div><div class="line">                                 cell_flags,</div><div class="line">                                 face_quadrature_overintegration,</div><div class="line">                                 face_flags);</div><div class="line"></div><div class="line">  CopyData copy_data;</div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a>,</div><div class="line">                        boundary_worker,</div><div class="line">                        face_worker);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> energy_error =</div><div class="line">    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(energy_norm_square_per_cell.l1_norm());</div><div class="line">  <span class="keywordflow">return</span> energy_error;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therefine_gridfunction"></a> </p><h3>The refine_grid() function</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> refinement_fraction = 0.1;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">    triangulation, estimated_error_square_per_cell, refinement_fraction, 0.);</div><div class="line"></div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thecompute_errorsfunction"></a> </p><h3>The compute_errors() function</h3>
<p>We compute three errors in the \(L_2\) norm, \(H_1\) seminorm, and the energy norm, respectively. These are then printed to screen, but also stored in a table that records how these errors decay with mesh refinement and which can be output in one step at the end of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::compute_errors()</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> L2_error, H1_error, energy_error;</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.n_active_cells());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      *(exact_solution.get()),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      quadrature_overintegration,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">    L2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                 difference_per_cell,</div><div class="line">                                                 <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;L2&quot;</span>, L2_error);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.n_active_cells());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      *(exact_solution.get()),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      quadrature_overintegration,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">    H1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                 difference_per_cell,</div><div class="line">                                                 <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;H1&quot;</span>, H1_error);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    energy_error = compute_energy_norm_error();</div><div class="line">    convergence_table.add_value(<span class="stringliteral">&quot;Energy&quot;</span>, energy_error);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Error in the L2 norm         : &quot;</span> &lt;&lt; L2_error &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  Error in the H1 seminorm     : &quot;</span> &lt;&lt; H1_error &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;  Error in the energy norm     : &quot;</span> &lt;&lt; energy_error</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunction"></a> </p><h3>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SIPGLaplace&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cycle =</div><div class="line">    (test_case == TestCase::convergence_rate ? 6 : 20);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; max_cycle; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">switch</span> (test_case)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">case</span> TestCase::convergence_rate:</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">                {</div><div class="line">                  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line"></div><div class="line">                  triangulation.refine_global(2);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                  triangulation.refine_global(1);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">case</span> TestCase::l_singularity:</div><div class="line">            {</div><div class="line">              <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">                {</div><div class="line">                  <a class="code" href="namespaceGridGenerator.html#a3b2a4ad8296c2b72a11d23b5969e8cc0">GridGenerator::hyper_L</a>(triangulation);</div><div class="line">                  triangulation.refine_global(3);</div><div class="line">                }</div><div class="line">              <span class="keywordflow">else</span></div><div class="line">                {</div><div class="line">                  refine_grid();</div><div class="line">                }</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">default</span>:</div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells       : &quot;</span></div><div class="line">                &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line">      setup_system();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom : &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_system();</div><div class="line">      solve();</div><div class="line">      output_results(cycle);</div><div class="line">      {</div><div class="line">        convergence_table.add_value(<span class="stringliteral">&quot;cycle&quot;</span>, cycle);</div><div class="line">        convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, triangulation.n_active_cells());</div><div class="line">        convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      }</div><div class="line">      compute_errors();</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (test_case == TestCase::l_singularity)</div><div class="line">        {</div><div class="line">          compute_error_estimate();</div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;  Estimated error              : &quot;</span></div><div class="line">                    &lt;&lt; <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(estimated_error_square_per_cell.l1_norm())</div><div class="line">                    &lt;&lt; std::endl;</div><div class="line"></div><div class="line">          convergence_table.add_value(</div><div class="line">            <span class="stringliteral">&quot;Estimator&quot;</span>,</div><div class="line">            std::sqrt(estimated_error_square_per_cell.l1_norm()));</div><div class="line">        }</div><div class="line">      std::cout &lt;&lt; std::endl;</div><div class="line">    }</div></div><!-- fragment --><p>Having run all of our computations, let us tell the convergence table how to format its data and output it to screen:</p>
<div class="fragment"><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;L2&quot;</span>, 3);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;H1&quot;</span>, 3);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;Energy&quot;</span>, 3);</div><div class="line"></div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;H1&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;Energy&quot;</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (test_case == TestCase::convergence_rate)</div><div class="line">      {</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;L2&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;H1&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">if</span> (test_case == TestCase::l_singularity)</div><div class="line">      {</div><div class="line">        convergence_table.set_precision(<span class="stringliteral">&quot;Estimator&quot;</span>, 3);</div><div class="line">        convergence_table.set_scientific(<span class="stringliteral">&quot;Estimator&quot;</span>, <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;degree = &quot;</span> &lt;&lt; degree &lt;&lt; std::endl;</div><div class="line">    convergence_table.write_text(</div><div class="line">      std::cout, TableHandler::TextOutputFormat::org_mode_table);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step74</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>The following <code>main</code> function is similar to previous examples as well, and need not be commented on.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step74;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> TestCase test_case = TestCase::l_singularity;</div><div class="line"></div><div class="line">      SIPGLaplace&lt;2&gt; problem(test_case);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-74/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>该程序的输出包括控制台输出和vtu格式的解决方案。</p>
<p>在第一个测试案例中，当你运行程序时，屏幕输出应该如下。</p>
<div class="fragment"><div class="line">Cycle 0</div><div class="line">  Number of active cells       : 16</div><div class="line">  Number of degrees of freedom : 256</div><div class="line">  Error in the <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>         : 0.00193285</div><div class="line">  Error in the H1 seminorm     : 0.106087</div><div class="line">  Error in the energy <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>     : 0.150625</div><div class="line"></div><div class="line"></div><div class="line">Cycle 1</div><div class="line">  Number of active cells       : 64</div><div class="line">  Number of degrees of freedom : 1024</div><div class="line">  Error in the <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>         : 9.60497e-05</div><div class="line">  Error in the H1 seminorm     : 0.0089954</div><div class="line">  Error in the energy <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>     : 0.0113265</div><div class="line"></div><div class="line"></div><div class="line">Cycle 2</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></div><!-- fragment --><p>当使用多项式度数为3的光滑情况时，收敛表会是这样的。 </p><table align="center" class="doxtable">
<tr>
<th>cycle </th><th>n_cellss </th><th>n_dofs </th><th>L2  </th><th>rate </th><th>H1 </th><th>rate </th><th>Energy  </th></tr>
<tr>
<td align="center">0 </td><td align="right">16 </td><td align="right">256 </td><td align="center">1.933e-03 </td><td>&#160; </td><td align="center">1.061e-01 </td><td>&#160; </td><td align="center">1.506e-01  </td></tr>
<tr>
<td align="center">1 </td><td align="right">64 </td><td align="right">1024 </td><td align="center">9.605e-05 </td><td align="center">4.33 </td><td align="center">8.995e-03 </td><td align="center">3.56 </td><td align="center">1.133e-02  </td></tr>
<tr>
<td align="center">2 </td><td align="right">256 </td><td align="right">4096 </td><td align="center">5.606e-06 </td><td align="center">4.10 </td><td align="center">9.018e-04 </td><td align="center">3.32 </td><td align="center">9.736e-04  </td></tr>
<tr>
<td align="center">3 </td><td align="right">1024 </td><td align="right">16384 </td><td align="center">3.484e-07 </td><td align="center">4.01 </td><td align="center">1.071e-04 </td><td align="center">3.07 </td><td align="center">1.088e-04  </td></tr>
<tr>
<td align="center">4 </td><td align="right">4096 </td><td align="right">65536 </td><td align="center">2.179e-08 </td><td align="center">4.00 </td><td align="center">1.327e-05 </td><td align="center">3.01 </td><td align="center">1.331e-05  </td></tr>
<tr>
<td align="center">5 </td><td align="right">16384 </td><td align="right">262144 </td><td align="center">1.363e-09 </td><td align="center">4.00 </td><td align="center">1.656e-06 </td><td align="center">3.00 </td><td align="center">1.657e-06  </td></tr>
</table>
<p>理论上，对于多项式度数 \(p\) ， \(L_2\) 规范和 \(H^1\) 半规范的收敛顺序应该是 \(p+1\) 和 \(p\) ，分别。我们的数值结果与理论有很好的一致性。</p>
<p>在第二个测试案例中，当你运行该程序时，屏幕输出应该如下。</p>
<div class="fragment"><div class="line">Cycle 0</div><div class="line">  Number of active cells       : 192</div><div class="line">  Number of degrees of freedom : 3072</div><div class="line">  Error in the <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>         : 0.000323585</div><div class="line">  Error in the H1 seminorm     : 0.0296202</div><div class="line">  Error in the energy <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>     : 0.0420478</div><div class="line">  Estimated error              : 0.136067</div><div class="line"></div><div class="line"></div><div class="line">Cycle 1</div><div class="line">  Number of active cells       : 249</div><div class="line">  Number of degrees of freedom : 3984</div><div class="line">  Error in the <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">L2</a> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>         : 0.000114739</div><div class="line">  Error in the H1 seminorm     : 0.0186571</div><div class="line">  Error in the energy <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>     : 0.0264879</div><div class="line">  Estimated error              : 0.0857186</div><div class="line"></div><div class="line"></div><div class="line">Cycle 2</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></div><!-- fragment --><p>下图提供了L型域上该测试案例的误差与自由度数的对数图。为了解释它，让 \(n\) 为自由度数，那么在均匀细化的网格上， \(h\) 在二维中为 \(1/\sqrt{n}\) 阶。结合前面的理论结果，我们可以看到，如果解足够光滑，我们可以预期 \(L_2\) 准则的误差为 \(O(n^{-\frac{p+1}{2}})\) 阶， \(H^1\) 半准则的误差为 \(O(n^{-\frac{p}{2}})\) 。先验地，我们并不清楚在像我们用于第二个测试案例的自适应细化网格上是否会得到与 \(n\) 的函数相同的行为，但我们当然可以希望。事实上，从图中我们看到，带有自适应网格细化的SIPG产生了渐进式的希望的结果。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-74.log-log-plot.png" width="600px"/>
</div>
<p>此外，我们观察到误差估计器的下降速度几乎与能量准则和 \(H^1\) 半准则的误差相同，并且比 \(L_2\) 的误差低一阶。这表明它有能力预测具有较大误差的区域。</p>
<p>虽然本教程侧重于实现，但<a class="el" href="step_59.html">step-59</a>教程程序在计算时间上用无矩阵求解技术实现了一个高效的大规模求解器。需要注意的是，<a class="el" href="step_59.html">step-59</a>教程目前不能用于包含悬空节点的网格，因为多网格界面矩阵不那么容易确定，但这仅仅是deal.II中一些界面的缺乏，没有什么根本性的问题。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2020 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at</span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Timo Heister and Jiaqi Zhang, Clemson University, 2020</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__lib_8h.html">deal.II/base/function_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="convergence__table_8h.html">deal.II/base/convergence_table.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step74</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">enum class</span> TestCase</div><div class="line">  {</div><div class="line">    convergence_rate,</div><div class="line">    l_singularity</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SmoothSolution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SmoothSolution()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">    gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; point,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SmoothSolution&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">      values[i] =</div><div class="line">        std::sin(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * points[i][0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * points[i][1]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a></div><div class="line">  SmoothSolution&lt;dim&gt;::gradient(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;point,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> return_value;</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    return_value[0] =</div><div class="line">      2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * point[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * point[1]);</div><div class="line">    return_value[1] =</div><div class="line">      2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * point[0]) * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * point[1]);</div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SmoothRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SmoothRightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  SmoothRightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">using</span> <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">      values[i] = 8. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * std::sin(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * points[i][0]) *</div><div class="line">                  <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2. * <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">PI</a> * points[i][1]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SingularRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SingularRightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1LSingularityFunction.html">Functions::LSingularityFunction</a> ref;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  SingularRightHandSide&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                         std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">      values[i] = -ref.laplacian(points[i]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> get_function_jump(<span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv,</div><div class="line">                         <span class="keyword">const</span> Vector&lt;double&gt; &amp;        solution,</div><div class="line">                         std::vector&lt;double&gt; &amp;         jump)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                 n_q = fe_iv.<a class="code" href="classFEInterfaceValues.html#a41f6734be1313f750fa8b3b7ba470f35">n_quadrature_points</a>;</div><div class="line">    std::array&lt;std::vector&lt;double&gt;, 2&gt; face_values;</div><div class="line">    jump.resize(n_q);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 2; ++i)</div><div class="line">      {</div><div class="line">        face_values[i].resize(n_q);</div><div class="line">        fe_iv.<a class="code" href="classFEInterfaceValues.html#a6ac7ddd5ac77cc4a1925ec5f0b100bf2">get_fe_face_values</a>(i).get_function_values(solution,</div><div class="line">                                                        face_values[i]);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q; ++q)</div><div class="line">      jump[q] = face_values[0][q] - face_values[1][q];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> get_function_gradient_jump(<span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv,</div><div class="line">                                  <span class="keyword">const</span> Vector&lt;double&gt; &amp;        solution,</div><div class="line">                                  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp; gradient_jump)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          n_q = fe_iv.<a class="code" href="classFEInterfaceValues.html#a41f6734be1313f750fa8b3b7ba470f35">n_quadrature_points</a>;</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; face_gradients[2];</div><div class="line">    gradient_jump.resize(n_q);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 2; ++i)</div><div class="line">      {</div><div class="line">        face_gradients[i].resize(n_q);</div><div class="line">        fe_iv.<a class="code" href="classFEInterfaceValues.html#a6ac7ddd5ac77cc4a1925ec5f0b100bf2">get_fe_face_values</a>(i).get_function_gradients(solution,</div><div class="line">                                                           face_gradients[i]);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q; ++q)</div><div class="line">      gradient_jump[q] = face_gradients[0][q] - face_gradients[1][q];</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_penalty_factor(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span>       cell_extent_left,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">double</span>       cell_extent_right)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(1U, fe_degree);</div><div class="line">    <span class="keywordflow">return</span> degree * (degree + 1.) * 0.5 *</div><div class="line">           (1. / cell_extent_left + 1. / cell_extent_right);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyDataFace</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; joint_dof_indices;</div><div class="line">    std::array&lt;double, 2&gt;                <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>;</div><div class="line">    std::array&lt;unsigned int, 2&gt;          cell_indices;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    std::vector&lt;CopyDataFace&gt;            face_data;</div><div class="line">    <span class="keywordtype">double</span>                               value;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                         <a class="code" href="grid__tools_8cc.html#aff11e57deb99b39b7d7d26cf866798f2">cell_index</a>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    {</div><div class="line">      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">      cell_rhs.reinit(dofs_per_cell);</div><div class="line">      local_dof_indices.resize(dofs_per_cell);</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SIPGLaplace</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SIPGLaplace(<span class="keyword">const</span> TestCase &amp;test_case);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span>   compute_errors();</div><div class="line">    <span class="keywordtype">void</span>   compute_error_estimate();</div><div class="line">    <span class="keywordtype">double</span> compute_energy_norm_error();</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    degree;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_overintegration;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_overintegration;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>  mapping;</div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt; system_matrix;</div><div class="line">    Vector&lt;double&gt;       solution;</div><div class="line">    Vector&lt;double&gt;       system_rhs;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; estimated_error_square_per_cell;</div><div class="line">    Vector&lt;double&gt; energy_norm_square_per_cell;</div><div class="line"></div><div class="line">    <a class="code" href="classConvergenceTable.html">ConvergenceTable</a> convergence_table;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient = 1.;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> TestCase                       test_case;</div><div class="line">    std::unique_ptr&lt;const Function&lt;dim&gt;&gt; exact_solution;</div><div class="line">    std::unique_ptr&lt;const Function&lt;dim&gt;&gt; rhs_function;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  SIPGLaplace&lt;dim&gt;::SIPGLaplace(<span class="keyword">const</span> TestCase &amp;test_case)</div><div class="line">    : degree(3)</div><div class="line">    , quadrature(degree + 1)</div><div class="line">    , face_quadrature(degree + 1)</div><div class="line">    , quadrature_overintegration(degree + 2)</div><div class="line">    , face_quadrature_overintegration(degree + 2)</div><div class="line">    , mapping()</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , test_case(test_case)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (test_case == TestCase::convergence_rate)</div><div class="line">      {</div><div class="line">        exact_solution = std::make_unique&lt;const SmoothSolution&lt;dim&gt;&gt;();</div><div class="line">        rhs_function   = std::make_unique&lt;const SmoothRightHandSide&lt;dim&gt;&gt;();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (test_case == TestCase::l_singularity)</div><div class="line">      {</div><div class="line">        exact_solution =</div><div class="line">          std::make_unique&lt;const Functions::LSingularityFunction&gt;();</div><div class="line">        rhs_function = std::make_unique&lt;const SingularRightHandSide&lt;dim&gt;&gt;();</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker =</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell, <span class="keyword">auto</span> &amp;scratch_data, <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v          = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   dofs_per_cell = fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">        copy_data.reinit(cell, dofs_per_cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points    = scratch_data.get_quadrature_points();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points  = q_points.size();</div><div class="line">        <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = scratch_data.get_JxW_values();</div><div class="line"></div><div class="line">        std::vector&lt;double&gt; rhs(n_q_points);</div><div class="line">        rhs_function-&gt;value_list(q_points, rhs);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++i)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; fe_v.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>; ++j)</div><div class="line">                copy_data.cell_matrix(i, j) +=</div><div class="line">                  diffusion_coefficient *     <span class="comment">// nu</span></div><div class="line">                  fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, point) * <span class="comment">// grad v_h</span></div><div class="line">                  fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, point) * <span class="comment">// grad u_h</span></div><div class="line">                  JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                 <span class="comment">// dx</span></div><div class="line"></div><div class="line">              copy_data.cell_rhs(i) += fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, point) * <span class="comment">// v_h</span></div><div class="line">                                       rhs[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] *                 <span class="comment">// f</span></div><div class="line">                                       JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                  <span class="comment">// dx</span></div><div class="line">            }</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                     <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                                     <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_fv = scratch_data.reinit(cell, face_no);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points      = scratch_data.get_quadrature_points();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = q_points.size();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_fv.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW = scratch_data.get_JxW_values();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals =</div><div class="line">        scratch_data.get_normal_vectors();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; g(n_q_points);</div><div class="line">      exact_solution-&gt;value_list(q_points, g);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(face_no)-&gt;measure();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                (-diffusion_coefficient *        <span class="comment">// - nu</span></div><div class="line">                   fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, point) * <span class="comment">// v_h</span></div><div class="line">                   (fe_fv.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, point) * <span class="comment">// (grad u_h .</span></div><div class="line">                    normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>])              <span class="comment">//  n)</span></div><div class="line"></div><div class="line">                 - diffusion_coefficient *         <span class="comment">// - nu</span></div><div class="line">                     (fe_fv.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, point) * <span class="comment">// (grad v_h .</span></div><div class="line">                      normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) *            <span class="comment">//  n)</span></div><div class="line">                     fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, point)   <span class="comment">// u_h</span></div><div class="line"></div><div class="line">                 + diffusion_coefficient * penalty * <span class="comment">// + nu sigma</span></div><div class="line">                     fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, point) *   <span class="comment">// v_h</span></div><div class="line">                     fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, point)     <span class="comment">// u_h</span></div><div class="line"></div><div class="line">                 ) *</div><div class="line">                JxW[point]; <span class="comment">// dx</span></div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            copy_data.cell_rhs(i) +=</div><div class="line">              (-diffusion_coefficient *        <span class="comment">// - nu</span></div><div class="line">                 (fe_fv.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, point) * <span class="comment">// (grad v_h .</span></div><div class="line">                  normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) *            <span class="comment">//  n)</span></div><div class="line">                 g[point]                      <span class="comment">// g</span></div><div class="line"></div><div class="line"></div><div class="line">               + diffusion_coefficient * penalty *        <span class="comment">// + nu sigma</span></div><div class="line">                   fe_fv.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, point) * g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] <span class="comment">// v_h g</span></div><div class="line"></div><div class="line">               ) *</div><div class="line">              JxW[point]; <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                                 <span class="keyword">const</span> <span class="keyword">auto</span> &amp;        ncell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv =</div><div class="line">        scratch_data.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points   = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">      copy_data.face_data.emplace_back();</div><div class="line">      CopyDataFace &amp;     copy_data_face = copy_data.face_data.back();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_face    = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>();</div><div class="line">      copy_data_face.joint_dof_indices  = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>();</div><div class="line">      copy_data_face.cell_matrix.reinit(n_dofs_face, n_dofs_face);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(f)-&gt;measure();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> extent2 = ncell-&gt;measure() / ncell-&gt;face(nf)-&gt;measure();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent2);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs_face; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs_face; ++j)</div><div class="line">              copy_data_face.cell_matrix(i, j) +=</div><div class="line">                (-diffusion_coefficient *              <span class="comment">// - nu</span></div><div class="line">                   fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, point) *              <span class="comment">// [v_h]</span></div><div class="line">                   (fe_iv.<a class="code" href="classFEInterfaceValues.html#a5614dd141462972c80d8733ba1d823f0">average_gradient</a>(j, point) * <span class="comment">// ({grad u_h} .</span></div><div class="line">                    normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>])                    <span class="comment">//  n)</span></div><div class="line"></div><div class="line">                 - diffusion_coefficient *               <span class="comment">// - nu</span></div><div class="line">                     (fe_iv.<a class="code" href="classFEInterfaceValues.html#a5614dd141462972c80d8733ba1d823f0">average_gradient</a>(i, point) * <span class="comment">// (grad v_h .</span></div><div class="line">                      normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) *                  <span class="comment">//  n)</span></div><div class="line">                     fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(j, point)                <span class="comment">// [u_h]</span></div><div class="line"></div><div class="line">                 + diffusion_coefficient * penalty * <span class="comment">// + nu sigma</span></div><div class="line">                     fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, point) *          <span class="comment">// [v_h]</span></div><div class="line">                     fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(j, point)            <span class="comment">// [u_h]</span></div><div class="line"></div><div class="line">                 ) *</div><div class="line">                JxW[point]; <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c) {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix,</div><div class="line">                                             c.cell_rhs,</div><div class="line">                                             c.local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             system_rhs);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data)</div><div class="line">        {</div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix,</div><div class="line">                                                 cdf.joint_dof_indices,</div><div class="line">                                                 system_matrix);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> cell_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line"></div><div class="line">    ScratchData scratch_data(</div><div class="line">      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);</div><div class="line">    CopyData copy_data;</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>,</div><div class="line">                          boundary_worker,</div><div class="line">                          face_worker);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> A_direct;</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(system_matrix);</div><div class="line">    A_direct.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(solution, system_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;sol_Q&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(degree, 1) +</div><div class="line">                                 <span class="stringliteral">&quot;-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(cycle, 2) +</div><div class="line">                                 <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::compute_error_estimate()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker =</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell, <span class="keyword">auto</span> &amp;scratch_data, <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        copy_data.cell_index = cell-&gt;active_cell_index();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;               q_points   = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>         n_q_points = q_points.size();</div><div class="line">        <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW        = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">        std::vector&lt;Tensor&lt;2, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaccf663e018d31c264b769c80bd91db4d">hessians</a>(n_q_points);</div><div class="line">        fe_v.<a class="code" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">get_function_hessians</a>(solution, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaccf663e018d31c264b769c80bd91db4d">hessians</a>);</div><div class="line"></div><div class="line">        std::vector&lt;double&gt; rhs(n_q_points);</div><div class="line">        rhs_function-&gt;value_list(q_points, rhs);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> hk                   = cell-&gt;diameter();</div><div class="line">        <span class="keywordtype">double</span>       residual_norm_square = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">              rhs[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] + diffusion_coefficient * <a class="code" href="symmetric__tensor_8h.html#a4248760c880275bab1f288fc80f27039">trace</a>(<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaccf663e018d31c264b769c80bd91db4d">hessians</a>[point]);</div><div class="line">            residual_norm_square += residual * residual * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">          }</div><div class="line">        copy_data.value = hk * hk * residual_norm_square;</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                     <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                                     <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_fv = scratch_data.reinit(cell, face_no);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;   q_points   = fe_fv.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_fv.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; g(n_q_points);</div><div class="line">      exact_solution-&gt;value_list(q_points, g);</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; sol_u(n_q_points);</div><div class="line">      fe_fv.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, sol_u);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(face_no)-&gt;measure();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent1);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> difference_norm_square = 0.;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> diff = (g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] - sol_u[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">          difference_norm_square += diff * diff * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">        }</div><div class="line">      copy_data.value += penalty * difference_norm_square;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                                 <span class="keyword">const</span> <span class="keyword">auto</span> &amp;        ncell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv =</div><div class="line">        scratch_data.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line"></div><div class="line">      copy_data.face_data.emplace_back();</div><div class="line">      CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">      copy_data_face.cell_indices[0] = cell-&gt;active_cell_index();</div><div class="line">      copy_data_face.cell_indices[1] = ncell-&gt;active_cell_index();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points   = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; jump(n_q_points);</div><div class="line">      get_function_jump(fe_iv, solution, jump);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_jump(n_q_points);</div><div class="line">      get_function_gradient_jump(fe_iv, solution, grad_jump);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> h = cell-&gt;face(f)-&gt;diameter();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(f)-&gt;measure();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> extent2 = ncell-&gt;measure() / ncell-&gt;face(nf)-&gt;measure();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent2);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> flux_jump_square = 0;</div><div class="line">      <span class="keywordtype">double</span> u_jump_square    = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          u_jump_square += jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> flux_jump = grad_jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">          flux_jump_square +=</div><div class="line">            diffusion_coefficient * flux_jump * flux_jump * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">        }</div><div class="line">      copy_data_face.values[0] =</div><div class="line">        0.5 * h * (flux_jump_square + penalty * u_jump_square);</div><div class="line">      copy_data_face.values[1] = copy_data_face.values[0];</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">      <span class="keywordflow">if</span> (copy_data.cell_index != <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</div><div class="line">        estimated_error_square_per_cell[copy_data.cell_index] +=</div><div class="line">          copy_data.value;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : copy_data.face_data)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 2; ++j)</div><div class="line">          estimated_error_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];</div><div class="line">    };</div><div class="line"></div><div class="line">    estimated_error_square_per_cell.reinit(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> cell_flags =</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>;</div><div class="line"></div><div class="line">    ScratchData scratch_data(</div><div class="line">      mapping, fe, quadrature, cell_flags, face_quadrature, face_flags);</div><div class="line"></div><div class="line">    CopyData copy_data;</div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a>,</div><div class="line">                          boundary_worker,</div><div class="line">                          face_worker);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> SIPGLaplace&lt;dim&gt;::compute_energy_norm_error()</div><div class="line">  {</div><div class="line">    energy_norm_square_per_cell.reinit(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker =</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell, <span class="keyword">auto</span> &amp;scratch_data, <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_v = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        copy_data.cell_index = cell-&gt;active_cell_index();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;               q_points   = fe_v.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>         n_q_points = q_points.size();</div><div class="line">        <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW        = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">        std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_u(n_q_points);</div><div class="line">        fe_v.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(solution, grad_u);</div><div class="line"></div><div class="line">        std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_exact(n_q_points);</div><div class="line">        exact_solution-&gt;gradient_list(q_points, grad_exact);</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> norm_square = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">          {</div><div class="line">            norm_square +=</div><div class="line">              (grad_u[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] - grad_exact[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]).norm_square() * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">          }</div><div class="line">        copy_data.value = diffusion_coefficient * norm_square;</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                     <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                                     <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_fv = scratch_data.reinit(cell, face_no);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;   q_points   = fe_fv.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_fv.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; g(n_q_points);</div><div class="line">      exact_solution-&gt;value_list(q_points, g);</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; sol_u(n_q_points);</div><div class="line">      fe_fv.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(solution, sol_u);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(face_no)-&gt;measure();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent1);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> difference_norm_square = 0.;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> diff = (g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] - sol_u[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">          difference_norm_square += diff * diff * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">        }</div><div class="line">      copy_data.value += penalty * difference_norm_square;</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;        cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                                 <span class="keyword">const</span> <span class="keyword">auto</span> &amp;        ncell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              scratch_data,</div><div class="line">                                 <span class="keyword">auto</span> &amp;              copy_data) {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv =</div><div class="line">        scratch_data.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line"></div><div class="line">      copy_data.face_data.emplace_back();</div><div class="line">      CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">      copy_data_face.cell_indices[0] = cell-&gt;active_cell_index();</div><div class="line">      copy_data_face.cell_indices[1] = ncell-&gt;active_cell_index();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       q_points   = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = q_points.size();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; jump(n_q_points);</div><div class="line">      get_function_jump(fe_iv, solution, jump);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> extent1 = cell-&gt;measure() / cell-&gt;face(f)-&gt;measure();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> extent2 = ncell-&gt;measure() / ncell-&gt;face(nf)-&gt;measure();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> penalty = get_penalty_factor(degree, extent1, extent2);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> u_jump_square = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> point = 0; point &lt; n_q_points; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          u_jump_square += jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * jump[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>] * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line">        }</div><div class="line">      copy_data_face.values[0] = 0.5 * penalty * u_jump_square;</div><div class="line">      copy_data_face.values[1] = copy_data_face.values[0];</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;copy_data) {</div><div class="line">      <span class="keywordflow">if</span> (copy_data.cell_index != <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</div><div class="line">        energy_norm_square_per_cell[copy_data.cell_index] += copy_data.value;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : copy_data.face_data)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 2; ++j)</div><div class="line">          energy_norm_square_per_cell[cdf.cell_indices[j]] += cdf.values[j];</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> cell_flags =</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> face_flags =</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData scratch_data(mapping,</div><div class="line">                                   fe,</div><div class="line">                                   quadrature_overintegration,</div><div class="line">                                   cell_flags,</div><div class="line">                                   face_quadrature_overintegration,</div><div class="line">                                   face_flags);</div><div class="line"></div><div class="line">    CopyData copy_data;</div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a>,</div><div class="line">                          boundary_worker,</div><div class="line">                          face_worker);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> energy_error =</div><div class="line">      <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(energy_norm_square_per_cell.l1_norm());</div><div class="line">    <span class="keywordflow">return</span> energy_error;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refinement_fraction = 0.1;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(</div><div class="line">      triangulation, estimated_error_square_per_cell, refinement_fraction, 0.);</div><div class="line"></div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SIPGLaplace&lt;dim&gt;::compute_errors()</div><div class="line">  {</div><div class="line">    <span class="keywordtype">double</span> L2_error, H1_error, energy_error;</div><div class="line"></div><div class="line">    {</div><div class="line">      Vector&lt;float&gt; difference_per_cell(triangulation.n_active_cells());</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        *(exact_solution.get()),</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        quadrature_overintegration,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line"></div><div class="line">      L2_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                   difference_per_cell,</div><div class="line">                                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">      convergence_table.add_value(<span class="stringliteral">&quot;L2&quot;</span>, L2_error);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      Vector&lt;float&gt; difference_per_cell(triangulation.n_active_cells());</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        *(exact_solution.get()),</div><div class="line">                                        difference_per_cell,</div><div class="line">                                        quadrature_overintegration,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line"></div><div class="line">      H1_error = <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                                   difference_per_cell,</div><div class="line">                                                   <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">VectorTools::H1_seminorm</a>);</div><div class="line">      convergence_table.add_value(<span class="stringliteral">&quot;H1&quot;</span>, H1_error);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      energy_error = compute_energy_norm_error();</div><div class="line">      convergence_table.add_value(<span class="stringliteral">&quot;Energy&quot;</span>, energy_error);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Error in the L2 norm         : &quot;</span> &lt;&lt; L2_error &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;  Error in the H1 seminorm     : &quot;</span> &lt;&lt; H1_error &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;  Error in the energy norm     : &quot;</span> &lt;&lt; energy_error</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">SIPGLaplace&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_cycle =</div><div class="line">      (test_case == TestCase::convergence_rate ? 6 : 20);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; max_cycle; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">switch</span> (test_case)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">case</span> TestCase::convergence_rate:</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line"></div><div class="line">                    triangulation.refine_global(2);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    triangulation.refine_global(1);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">case</span> TestCase::l_singularity:</div><div class="line">              {</div><div class="line">                <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">                  {</div><div class="line">                    <a class="code" href="namespaceGridGenerator.html#a3b2a4ad8296c2b72a11d23b5969e8cc0">GridGenerator::hyper_L</a>(triangulation);</div><div class="line">                    triangulation.refine_global(3);</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">else</span></div><div class="line">                  {</div><div class="line">                    refine_grid();</div><div class="line">                  }</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">default</span>:</div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells       : &quot;</span></div><div class="line">                  &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom : &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        {</div><div class="line">          convergence_table.add_value(<span class="stringliteral">&quot;cycle&quot;</span>, cycle);</div><div class="line">          convergence_table.add_value(<span class="stringliteral">&quot;cells&quot;</span>, triangulation.n_active_cells());</div><div class="line">          convergence_table.add_value(<span class="stringliteral">&quot;dofs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">        }</div><div class="line">        compute_errors();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (test_case == TestCase::l_singularity)</div><div class="line">          {</div><div class="line">            compute_error_estimate();</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Estimated error              : &quot;</span></div><div class="line">                      &lt;&lt; <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(estimated_error_square_per_cell.l1_norm())</div><div class="line">                      &lt;&lt; std::endl;</div><div class="line"></div><div class="line">            convergence_table.add_value(</div><div class="line">              <span class="stringliteral">&quot;Estimator&quot;</span>,</div><div class="line">              std::sqrt(estimated_error_square_per_cell.l1_norm()));</div><div class="line">          }</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;L2&quot;</span>, 3);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;H1&quot;</span>, 3);</div><div class="line">    convergence_table.set_precision(<span class="stringliteral">&quot;Energy&quot;</span>, 3);</div><div class="line"></div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;L2&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;H1&quot;</span>, <span class="keyword">true</span>);</div><div class="line">    convergence_table.set_scientific(<span class="stringliteral">&quot;Energy&quot;</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (test_case == TestCase::convergence_rate)</div><div class="line">      {</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;L2&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">        convergence_table.evaluate_convergence_rates(</div><div class="line">          <span class="stringliteral">&quot;H1&quot;</span>, <a class="code" href="classConvergenceTable.html#ae1ef1c23deebd739950f52b0740ecaaba322af8094a35219c384ae2d343905e9c">ConvergenceTable::reduction_rate_log2</a>);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">if</span> (test_case == TestCase::l_singularity)</div><div class="line">      {</div><div class="line">        convergence_table.set_precision(<span class="stringliteral">&quot;Estimator&quot;</span>, 3);</div><div class="line">        convergence_table.set_scientific(<span class="stringliteral">&quot;Estimator&quot;</span>, <span class="keyword">true</span>);</div><div class="line">      }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;degree = &quot;</span> &lt;&lt; degree &lt;&lt; std::endl;</div><div class="line">    convergence_table.write_text(</div><div class="line">      std::cout, TableHandler::TextOutputFormat::org_mode_table);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step74</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step74;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> TestCase test_case = TestCase::l_singularity;</div><div class="line"></div><div class="line">      SIPGLaplace&lt;2&gt; problem(test_case);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
