<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classPersistentTriangulation.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PersistentTriangulation&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPersistentTriangulation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PersistentTriangulation&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="persistent__tria_8h_source.html">deal.II/grid/persistent_tria.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PersistentTriangulation&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPersistentTriangulation__inherit__graph.svg" width="166" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0633dd17e535a59162b79f338c6ff5ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> { <br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec">none</a> = 0x0, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a> = 0x1, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a> = 0x2, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812">patch_level_1</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeae94a75f4383724ef8f58639aef2eb6c0">coarsest_level_1</a> = 0x8, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa44d17458e16327fb4b674745b883910">allow_anisotropic_smoothing</a> = 0x10, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> = 0x100, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea75171630dec90d241c811d2732410303">do_not_produce_unrefined_islands</a> = 0x400, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea3fb6b9153821aefc45661f67f22e232a">smoothing_on_refinement</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea8d8dbaaa62136a7e51c7bf5c02d6e1e7">smoothing_on_coarsening</a>, 
<a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf64b535fd0fad99b6032412d2cccac36">maximum_smoothing</a> = 0xffff ^ allow_anisotropic_smoothing
<br />
 }</td></tr>
<tr class="separator:a0633dd17e535a59162b79f338c6ff5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997d61ac77777cdc2be3ae934b1f7cdb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga997d61ac77777cdc2be3ae934b1f7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> = <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a></td></tr>
<tr class="separator:ad12cedb5139eeea73fb2a3eec16636f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c836c1e503743e8073eb615603aab9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga08c836c1e503743e8073eb615603aab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga4015f9d1dc9115fbdf74d74960bec074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gad77aace3a5c6c96b985cbf22a28c83f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23052ad0b446137324ccf9ea0fd386e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:gac23052ad0b446137324ccf9ea0fd386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> = <a class="el" href="classTriaActiveIterator.html">TriaActiveIterator</a>&lt;::<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;</td></tr>
<tr class="separator:ga8738294ebb9d165e6b431589b0bbc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863d37379dceb11324e72a44039ac495"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga863d37379dceb11324e72a44039ac495">line_iterator</a> = typename IteratorSelector::line_iterator</td></tr>
<tr class="separator:ga863d37379dceb11324e72a44039ac495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfba44e3df01252843f37ee1f8e6df58"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#gabfba44e3df01252843f37ee1f8e6df58">active_line_iterator</a> = typename IteratorSelector::active_line_iterator</td></tr>
<tr class="separator:gabfba44e3df01252843f37ee1f8e6df58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga672c99b1c8da16227cae6f0cf66cc109">quad_iterator</a> = typename IteratorSelector::quad_iterator</td></tr>
<tr class="separator:ga672c99b1c8da16227cae6f0cf66cc109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b331baff3d6bfb841950b10845fc5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga31b331baff3d6bfb841950b10845fc5f">active_quad_iterator</a> = typename IteratorSelector::active_quad_iterator</td></tr>
<tr class="separator:ga31b331baff3d6bfb841950b10845fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0500bbdefc5ea6a1306892b933896875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga0500bbdefc5ea6a1306892b933896875">hex_iterator</a> = typename IteratorSelector::hex_iterator</td></tr>
<tr class="separator:ga0500bbdefc5ea6a1306892b933896875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Iterators.html#ga4fed0f1753adab5eb220b1bec03ae571">active_hex_iterator</a> = typename IteratorSelector::active_hex_iterator</td></tr>
<tr class="separator:ga4fed0f1753adab5eb220b1bec03ae571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa3e603cc1093240eb218d3ff34598a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#afa3e603cc1093240eb218d3ff34598a5">PersistentTriangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classPersistentTriangulation.html#ab46ea92d41782bce5e144a4d3a3a5e4d">coarse_grid</a>)</td></tr>
<tr class="separator:afa3e603cc1093240eb218d3ff34598a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11870f737c7c01d26037139cd3fb71c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a11870f737c7c01d26037139cd3fb71c5">PersistentTriangulation</a> (const <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt; &amp;old_tria)</td></tr>
<tr class="separator:a11870f737c7c01d26037139cd3fb71c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7a32000c89e02cc219d81fa37a7838"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a3a7a32000c89e02cc219d81fa37a7838">~PersistentTriangulation</a> () override=default</td></tr>
<tr class="separator:a3a7a32000c89e02cc219d81fa37a7838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db24bddb2e9013086c7a33a4fc506d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">execute_coarsening_and_refinement</a> () override</td></tr>
<tr class="separator:a3db24bddb2e9013086c7a33a4fc506d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ac6c5bc96ff989ac3649602a8dbc84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a81ac6c5bc96ff989ac3649602a8dbc84">restore</a> ()</td></tr>
<tr class="separator:a81ac6c5bc96ff989ac3649602a8dbc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b58ff62c5d3900cbe5295e100df691"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a90b58ff62c5d3900cbe5295e100df691">restore</a> (const unsigned <a class="el" href="classint.html">int</a> step_no)</td></tr>
<tr class="separator:a90b58ff62c5d3900cbe5295e100df691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ec1e44b40efccc65aafbdc242a7e8f"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#ae6ec1e44b40efccc65aafbdc242a7e8f">n_refinement_steps</a> () const</td></tr>
<tr class="separator:ae6ec1e44b40efccc65aafbdc242a7e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d8ee4421ec25e3408f15613a7a9b3f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a62d8ee4421ec25e3408f15613a7a9b3f">copy_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria) override</td></tr>
<tr class="separator:a62d8ee4421ec25e3408f15613a7a9b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac411e19b10ae782223450271c249358b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#ac411e19b10ae782223450271c249358b">create_triangulation</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata) override</td></tr>
<tr class="separator:ac411e19b10ae782223450271c249358b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac497f405da11cf43ab7e7256aba7fff4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#ac497f405da11cf43ab7e7256aba7fff4">create_triangulation</a> (const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;construction_data) override</td></tr>
<tr class="separator:ac497f405da11cf43ab7e7256aba7fff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6215eb2339ec45320d5858ccae5aab6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#ad6215eb2339ec45320d5858ccae5aab6">create_triangulation_compatibility</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;<a class="el" href="classTriangulation.html#a51469854babb27752dc9f26ed9d5ee30">vertices</a>, const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;cells, const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;subcelldata) override</td></tr>
<tr class="separator:ad6215eb2339ec45320d5858ccae5aab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c63e56783c3c8d74d508d6dc9a51fcc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a0c63e56783c3c8d74d508d6dc9a51fcc">write_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a0c63e56783c3c8d74d508d6dc9a51fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2a6e2c8a65e5c6df1877dd128a0958"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a0e2a6e2c8a65e5c6df1877dd128a0958">read_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a0e2a6e2c8a65e5c6df1877dd128a0958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3890ccc438c4ea70f5c947e7f2306c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a1a3890ccc438c4ea70f5c947e7f2306c">clear_flags</a> ()</td></tr>
<tr class="separator:a1a3890ccc438c4ea70f5c947e7f2306c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b9533b25ed580656f17c823bad0cf9"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a17b9533b25ed580656f17c823bad0cf9">memory_consumption</a> () const override</td></tr>
<tr class="separator:a17b9533b25ed580656f17c823bad0cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878d98c53ac8fb2fda0e378998aa8c57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a878d98c53ac8fb2fda0e378998aa8c57">DeclException0</a> (ExcTriaNotEmpty)</td></tr>
<tr class="separator:a878d98c53ac8fb2fda0e378998aa8c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310b8eb8036e6841f99e6be426a15254"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a310b8eb8036e6841f99e6be426a15254">DeclException0</a> (ExcFlagsNotCleared)</td></tr>
<tr class="separator:a310b8eb8036e6841f99e6be426a15254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d54b7dae635d867bf8d2c4b3605817"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">clear</a> ()</td></tr>
<tr class="separator:a12d54b7dae635d867bf8d2c4b3605817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1005ad6002b51c5bc4592da7246b6a49"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1005ad6002b51c5bc4592da7246b6a49">get_communicator</a> () const</td></tr>
<tr class="separator:a1005ad6002b51c5bc4592da7246b6a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a302f66ccc9bd281cf850fdc4f76e50">set_mesh_smoothing</a> (const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> mesh_smoothing)</td></tr>
<tr class="separator:a4a302f66ccc9bd281cf850fdc4f76e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df95bfd43216e389a132786f87474f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a06df95bfd43216e389a132786f87474f">get_mesh_smoothing</a> () const</td></tr>
<tr class="separator:a06df95bfd43216e389a132786f87474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number, const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;manifold_object)</td></tr>
<tr class="separator:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644a2152b8f5a6902afdc503d163d950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> manifold_number)</td></tr>
<tr class="separator:ga644a2152b8f5a6902afdc503d163d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a> ()</td></tr>
<tr class="separator:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2acfbef517fd03855c4b371f3e182f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gae2acfbef517fd03855c4b371f3e182f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa4e0af28512cb5f9cc8cb3b95a38c669">set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id, const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa5d4bed3d2ac6148e969a331bde49f63">get_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number) const</td></tr>
<tr class="separator:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05662a55166596efb520479b495275f8"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a05662a55166596efb520479b495275f8">get_boundary_ids</a> () const</td></tr>
<tr class="separator:a05662a55166596efb520479b495275f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee729ae049af6f1495d0059d6086e52"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga0ee729ae049af6f1495d0059d6086e52">get_manifold_ids</a> () const</td></tr>
<tr class="separator:ga0ee729ae049af6f1495d0059d6086e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc34248a9ba0c38fd0020256a8def5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afdc34248a9ba0c38fd0020256a8def5c">flip_all_direction_flags</a> ()</td></tr>
<tr class="separator:afdc34248a9ba0c38fd0020256a8def5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mesh refinement</div></td></tr>
<tr class="memitem:aed8e461d4b2b23a0e1730afdef36e694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags</a> ()</td></tr>
<tr class="separator:aed8e461d4b2b23a0e1730afdef36e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad0b3fb24aae17f4668427a433dea19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6ad0b3fb24aae17f4668427a433dea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552fa04ee753657bd9f92571d76cf09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6552fa04ee753657bd9f92571d76cf09">coarsen_global</a> (const unsigned <a class="el" href="classint.html">int</a> times=1)</td></tr>
<tr class="separator:a6552fa04ee753657bd9f92571d76cf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf55199c30b0330cf9bf98e2582078e1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">prepare_coarsening_and_refinement</a> ()</td></tr>
<tr class="separator:abf55199c30b0330cf9bf98e2582078e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">History of a triangulation</div></td></tr>
<tr class="memitem:aca5cfa9068a5d3ad32dfca87e2901a87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aca5cfa9068a5d3ad32dfca87e2901a87">save_refine_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aca5cfa9068a5d3ad32dfca87e2901a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affce5fca29acccbb2dc1294ebe404a03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#affce5fca29acccbb2dc1294ebe404a03">save_refine_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:affce5fca29acccbb2dc1294ebe404a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fc07c3f9e1f02658ca556f41087c85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a43fc07c3f9e1f02658ca556f41087c85">load_refine_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a43fc07c3f9e1f02658ca556f41087c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac924a05e66d5e76458ad088a2b7b5583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac924a05e66d5e76458ad088a2b7b5583">load_refine_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac924a05e66d5e76458ad088a2b7b5583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64b6155fd89f8f29d4c02795c1a10d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af64b6155fd89f8f29d4c02795c1a10d9">save_coarsen_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:af64b6155fd89f8f29d4c02795c1a10d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaaecbe89311fdaa8a9b999209ff9155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abaaecbe89311fdaa8a9b999209ff9155">save_coarsen_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:abaaecbe89311fdaa8a9b999209ff9155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4029122ffe741f843f2f3a7deeceea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa4029122ffe741f843f2f3a7deeceea9">load_coarsen_flags</a> (std::istream &amp;out)</td></tr>
<tr class="separator:aa4029122ffe741f843f2f3a7deeceea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a48a9463dcf9aeb3a69831e5e1a321053">load_coarsen_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a48a9463dcf9aeb3a69831e5e1a321053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178e9ce017916f190ddf7a734ef15902"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a178e9ce017916f190ddf7a734ef15902">get_anisotropic_refinement_flag</a> () const</td></tr>
<tr class="separator:a178e9ce017916f190ddf7a734ef15902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr class="memitem:aaa726b33b52f694cfca48fae8e761661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa726b33b52f694cfca48fae8e761661">clear_user_flags</a> ()</td></tr>
<tr class="separator:aaa726b33b52f694cfca48fae8e761661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9971ee882f15fe521afc4e079383b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6a9971ee882f15fe521afc4e079383b5">save_user_flags</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a6a9971ee882f15fe521afc4e079383b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad25280beb6c2607418a0d3e903819a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aad25280beb6c2607418a0d3e903819a3">save_user_flags</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:aad25280beb6c2607418a0d3e903819a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af3612ed3c7f7f9cccd3003d85b6f7350">load_user_flags</a> (std::istream &amp;in)</td></tr>
<tr class="separator:af3612ed3c7f7f9cccd3003d85b6f7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17946286639b12a03804ebc400eab51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac17946286639b12a03804ebc400eab51">load_user_flags</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:ac17946286639b12a03804ebc400eab51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af8896f8e838dd34ed5b7c1aa351f76f5">clear_user_flags_line</a> ()</td></tr>
<tr class="separator:af8896f8e838dd34ed5b7c1aa351f76f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7d8e059d6f8f903879eea858215fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2b7d8e059d6f8f903879eea858215fb8">save_user_flags_line</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a2b7d8e059d6f8f903879eea858215fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02adea7b298cd5047ee5a5755f87ae36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a02adea7b298cd5047ee5a5755f87ae36">save_user_flags_line</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a02adea7b298cd5047ee5a5755f87ae36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a25190c31d16cde2a01fa0f2318aa0b74">load_user_flags_line</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a25190c31d16cde2a01fa0f2318aa0b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87294511c2f203a57531aaaf2bd2ce39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a87294511c2f203a57531aaaf2bd2ce39">load_user_flags_line</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a87294511c2f203a57531aaaf2bd2ce39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd263157214206ceb637c402552f0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1dd263157214206ceb637c402552f0eb">clear_user_flags_quad</a> ()</td></tr>
<tr class="separator:a1dd263157214206ceb637c402552f0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4a2db0492d38971366bfcd159cbbc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acf4a2db0492d38971366bfcd159cbbc1">save_user_flags_quad</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:acf4a2db0492d38971366bfcd159cbbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431026974872f49e59f6a799ee0a19d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a431026974872f49e59f6a799ee0a19d6">save_user_flags_quad</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a431026974872f49e59f6a799ee0a19d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5e868cde85c04bcc8cec82ba09f24e7b">load_user_flags_quad</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a5e868cde85c04bcc8cec82ba09f24e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8651e0def48d61e3f8f0aa8051ae5985">load_user_flags_quad</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a8651e0def48d61e3f8f0aa8051ae5985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbe198bb49c3135378bb680582afd46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7cbe198bb49c3135378bb680582afd46">clear_user_flags_hex</a> ()</td></tr>
<tr class="separator:a7cbe198bb49c3135378bb680582afd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5512376f914359303ce7d4666d550b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1d5512376f914359303ce7d4666d550b">save_user_flags_hex</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a1d5512376f914359303ce7d4666d550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57c92493d66995cf29bef79f0e8e09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae57c92493d66995cf29bef79f0e8e09b">save_user_flags_hex</a> (std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v) const</td></tr>
<tr class="separator:ae57c92493d66995cf29bef79f0e8e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a6e15f4d848adbe6c8bf1af374e467a31">load_user_flags_hex</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a6e15f4d848adbe6c8bf1af374e467a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e827086d26927d08129c8489fdcd45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a77e827086d26927d08129c8489fdcd45">load_user_flags_hex</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v)</td></tr>
<tr class="separator:a77e827086d26927d08129c8489fdcd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26562806fd764afdffb973dce92554e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a> ()</td></tr>
<tr class="separator:a26562806fd764afdffb973dce92554e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3794cd2d7f80bd81f69fcb828535412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:ae3794cd2d7f80bd81f69fcb828535412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a2359968a027a8b14ae381c8886d30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a12a2359968a027a8b14ae381c8886d30">load_user_indices</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a12a2359968a027a8b14ae381c8886d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a41f6c10b5db7d540a9df15742ebf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a03a41f6c10b5db7d540a9df15742ebf0">save_user_pointers</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:a03a41f6c10b5db7d540a9df15742ebf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8891e8277a047b9dd4fe86943d1321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f8891e8277a047b9dd4fe86943d1321">load_user_pointers</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a2f8891e8277a047b9dd4fe86943d1321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451b2af8e62783f4780552088fd9ad88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a451b2af8e62783f4780552088fd9ad88">save_user_indices_line</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a451b2af8e62783f4780552088fd9ad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2160dd04545294d138ca00deb4af42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7b2160dd04545294d138ca00deb4af42">load_user_indices_line</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a7b2160dd04545294d138ca00deb4af42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d65cc99c33ea13361700a58ff9d6686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8d65cc99c33ea13361700a58ff9d6686">save_user_indices_quad</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a8d65cc99c33ea13361700a58ff9d6686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1020c09b32fbb78156b00b833271e21d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1020c09b32fbb78156b00b833271e21d">load_user_indices_quad</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:a1020c09b32fbb78156b00b833271e21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a18d1c25ca9c0b7cef07c6e92fdd28f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a8a18d1c25ca9c0b7cef07c6e92fdd28f">save_user_indices_hex</a> (std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v) const</td></tr>
<tr class="separator:a8a18d1c25ca9c0b7cef07c6e92fdd28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad8869b9c8234d6c81c24c69dd97d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abad8869b9c8234d6c81c24c69dd97d39">load_user_indices_hex</a> (const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;v)</td></tr>
<tr class="separator:abad8869b9c8234d6c81c24c69dd97d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699d7c1b73eccc41bc53009003ab3d28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a699d7c1b73eccc41bc53009003ab3d28">save_user_pointers_line</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:a699d7c1b73eccc41bc53009003ab3d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879d77427982a2d69d2dd9512d4ba6c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a879d77427982a2d69d2dd9512d4ba6c9">load_user_pointers_line</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a879d77427982a2d69d2dd9512d4ba6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d27b23e1d873b38817d08b7bb6884f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7d27b23e1d873b38817d08b7bb6884f8">save_user_pointers_quad</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:a7d27b23e1d873b38817d08b7bb6884f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f771811ec221a4ca0c49f3a09164fec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4f771811ec221a4ca0c49f3a09164fec">load_user_pointers_quad</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a4f771811ec221a4ca0c49f3a09164fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42ad416119dff0589b8b67dd3de02e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac42ad416119dff0589b8b67dd3de02e8">save_user_pointers_hex</a> (std::vector&lt; void *&gt; &amp;v) const</td></tr>
<tr class="separator:ac42ad416119dff0589b8b67dd3de02e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dad0c49d2423e8c4410efcc773ad82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a03dad0c49d2423e8c4410efcc773ad82">load_user_pointers_hex</a> (const std::vector&lt; void *&gt; &amp;v)</td></tr>
<tr class="separator:a03dad0c49d2423e8c4410efcc773ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell iterator functions</div></td></tr>
<tr class="memitem:a36fb6b15f119483143c433dd10df9b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a36fb6b15f119483143c433dd10df9b26">begin</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:a36fb6b15f119483143c433dd10df9b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6c58805fe436a94b141c1585606c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active</a> (const unsigned <a class="el" href="classint.html">int</a> level=0) const</td></tr>
<tr class="separator:afe6c58805fe436a94b141c1585606c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c41c89a9cf1e020050985822196dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end</a> () const</td></tr>
<tr class="separator:a92c41c89a9cf1e020050985822196dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9597b118c84fce0addf7f4db3b067659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9597b118c84fce0addf7f4db3b067659">end</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a9597b118c84fce0addf7f4db3b067659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0967cc6653ea9a08e94fe9da4d11793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab0967cc6653ea9a08e94fe9da4d11793">end_active</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:ab0967cc6653ea9a08e94fe9da4d11793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51f6fbd9bcd9e41757039a7b4954d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab51f6fbd9bcd9e41757039a7b4954d2a">last</a> () const</td></tr>
<tr class="separator:ab51f6fbd9bcd9e41757039a7b4954d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb00096abe5ef91413440e1e1b66c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2eb00096abe5ef91413440e1e1b66c00">last_active</a> () const</td></tr>
<tr class="separator:a2eb00096abe5ef91413440e1e1b66c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c0bd718b0ae9316f3b6f52d0ff4c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a367c0bd718b0ae9316f3b6f52d0ff4c6">create_cell_iterator</a> (const <a class="el" href="classCellId.html">CellId</a> &amp;cell_id) const</td></tr>
<tr class="separator:a367c0bd718b0ae9316f3b6f52d0ff4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell iterator functions returning ranges of iterators</div></td></tr>
<tr class="memitem:gae2dc0cda6c74461c0bbc22a41b5525c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gae2dc0cda6c74461c0bbc22a41b5525c4">cell_iterators</a> () const</td></tr>
<tr class="separator:gae2dc0cda6c74461c0bbc22a41b5525c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e860c5192f6501650dda8bb3e2b497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators</a> () const</td></tr>
<tr class="separator:ga23e860c5192f6501650dda8bb3e2b497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae69f18aa4845bfe513fd51a39755b9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gae69f18aa4845bfe513fd51a39755b9d6">cell_iterators_on_level</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:gae69f18aa4845bfe513fd51a39755b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45356a49aeb1130d244abb313afdc24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#gad45356a49aeb1130d244abb313afdc24">active_cell_iterators_on_level</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:gad45356a49aeb1130d244abb313afdc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Face iterator functions</div></td></tr>
<tr class="memitem:abd8e77917e8512bd1e70bf180929f407"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abd8e77917e8512bd1e70bf180929f407">begin_face</a> () const</td></tr>
<tr class="separator:abd8e77917e8512bd1e70bf180929f407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8d4115aad4a2a5c97a7f7c06d34d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af7e8d4115aad4a2a5c97a7f7c06d34d5">begin_active_face</a> () const</td></tr>
<tr class="separator:af7e8d4115aad4a2a5c97a7f7c06d34d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359dfdc82f2269b68b1d30c8a2286c6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a359dfdc82f2269b68b1d30c8a2286c6f">end_face</a> () const</td></tr>
<tr class="separator:a359dfdc82f2269b68b1d30c8a2286c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; <a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CPP11.html#ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6">active_face_iterators</a> () const</td></tr>
<tr class="separator:ga95c4ae1d1e8d3e7d179fdd6bcbbae7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex iterator functions</div></td></tr>
<tr class="memitem:aa76498325599ace7304627cb64e5fcd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa76498325599ace7304627cb64e5fcd2">begin_vertex</a> () const</td></tr>
<tr class="separator:aa76498325599ace7304627cb64e5fcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8705fe160c08af9a2372c605525ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a0e8705fe160c08af9a2372c605525ef0">begin_active_vertex</a> () const</td></tr>
<tr class="separator:a0e8705fe160c08af9a2372c605525ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad93f466afba9b3f003d09a685a615f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaad93f466afba9b3f003d09a685a615f">end_vertex</a> () const</td></tr>
<tr class="separator:aaad93f466afba9b3f003d09a685a615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about the triangulation</div></td></tr>
<tr class="memitem:a46edbe1027405ca9545e3c2289eb3938"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines</a> () const</td></tr>
<tr class="separator:a46edbe1027405ca9545e3c2289eb3938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5ba9d51dfdd307da590e31c9262c28"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee5ba9d51dfdd307da590e31c9262c28">n_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:aee5ba9d51dfdd307da590e31c9262c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines</a> () const</td></tr>
<tr class="separator:a76c9d6f7b2068f5afa429020086b6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a21d30203bdeaa3b9e2b416f24b7e9d6d">n_active_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a21d30203bdeaa3b9e2b416f24b7e9d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105d0305d8c801076bea2404087f29a7"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads</a> () const</td></tr>
<tr class="separator:a105d0305d8c801076bea2404087f29a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0817fceed7429359f89928eec87d381"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af0817fceed7429359f89928eec87d381">n_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:af0817fceed7429359f89928eec87d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads</a> () const</td></tr>
<tr class="separator:ab7a0837c6dabdda21930bf3d49e9852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf97ad6187b553b2980043dd1c8d75db"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abf97ad6187b553b2980043dd1c8d75db">n_active_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:abf97ad6187b553b2980043dd1c8d75db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa75fe811e9d1707ce798f874aa2e117"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aaa75fe811e9d1707ce798f874aa2e117">n_hexs</a> () const</td></tr>
<tr class="separator:aaa75fe811e9d1707ce798f874aa2e117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a015bc7a2fecb2cba52050a8f2bfbafe1">n_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a015bc7a2fecb2cba52050a8f2bfbafe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee621a8e59e259c252ccc64f19e37301"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aee621a8e59e259c252ccc64f19e37301">n_active_hexs</a> () const</td></tr>
<tr class="separator:aee621a8e59e259c252ccc64f19e37301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ade8bbb4c8ffd9f8adb683b39a82a9b1e">n_active_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:ade8bbb4c8ffd9f8adb683b39a82a9b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea687f123f3f5a8b09d7485cf03be72"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a> () const</td></tr>
<tr class="separator:abea687f123f3f5a8b09d7485cf03be72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a40c5623c62d2e43aa63f1eb4904eeec8">n_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a40c5623c62d2e43aa63f1eb4904eeec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a> () const</td></tr>
<tr class="separator:a5ea5c9957dbb566a562bbe2c0f3971e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3d106ed8c9a29d6bb7d2bfb636f8df62">n_active_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a3d106ed8c9a29d6bb7d2bfb636f8df62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05502400e5b4bdd3bb7e0fd410fdf0fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a05502400e5b4bdd3bb7e0fd410fdf0fb">n_global_active_cells</a> () const</td></tr>
<tr class="separator:a05502400e5b4bdd3bb7e0fd410fdf0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bff048d1ed54471bbd2dcfc76a46523"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1bff048d1ed54471bbd2dcfc76a46523">n_global_coarse_cells</a> () const</td></tr>
<tr class="separator:a1bff048d1ed54471bbd2dcfc76a46523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e297d311818e3a79bcede5804f51065"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1e297d311818e3a79bcede5804f51065">n_faces</a> () const</td></tr>
<tr class="separator:a1e297d311818e3a79bcede5804f51065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5ae907d55b3b12c5c75e58174c1781ff">n_active_faces</a> () const</td></tr>
<tr class="separator:a5ae907d55b3b12c5c75e58174c1781ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777f035a17e91a4d822971516ca11db5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a> () const</td></tr>
<tr class="separator:a777f035a17e91a4d822971516ca11db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd960d483675c4eb2c538529350e56b"><td class="memItemLeft" align="right" valign="top">virtual unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels</a> () const</td></tr>
<tr class="separator:aafd960d483675c4eb2c538529350e56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935cc3b953d71fe4081fa8f88820f034"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a935cc3b953d71fe4081fa8f88820f034">has_hanging_nodes</a> () const</td></tr>
<tr class="separator:a935cc3b953d71fe4081fa8f88820f034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae1aadc2300ef9a6f2368fe7bc5926fe8">n_vertices</a> () const</td></tr>
<tr class="separator:ae1aadc2300ef9a6f2368fe7bc5926fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3059d54432e0d739534e5330bb7b3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#afb3059d54432e0d739534e5330bb7b3a">get_vertices</a> () const</td></tr>
<tr class="separator:afb3059d54432e0d739534e5330bb7b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a76937acd9dfc3ade1fb885c7ab1ae776">n_used_vertices</a> () const</td></tr>
<tr class="separator:a76937acd9dfc3ade1fb885c7ab1ae776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aab2295fdb4bfc8ab41f51cdbc34de449">vertex_used</a> (const unsigned <a class="el" href="classint.html">int</a> index) const</td></tr>
<tr class="separator:aab2295fdb4bfc8ab41f51cdbc34de449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices</a> () const</td></tr>
<tr class="separator:a07690a619d2817f4c8ef3bb74c43b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6313a19a8cc20e07249978218b5ca6a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aa6313a19a8cc20e07249978218b5ca6a">max_adjacent_cells</a> () const</td></tr>
<tr class="separator:aa6313a19a8cc20e07249978218b5ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5827cdfafd5fef99803cde97b70e86bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5827cdfafd5fef99803cde97b70e86bc">locally_owned_subdomain</a> () const</td></tr>
<tr class="separator:a5827cdfafd5fef99803cde97b70e86bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcac8668993d582f192d3c85b642dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#acbcac8668993d582f192d3c85b642dd3">get_triangulation</a> ()</td></tr>
<tr class="separator:acbcac8668993d582f192d3c85b642dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae427477f592d34c1bf3367e408f90c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aae427477f592d34c1bf3367e408f90c3">get_triangulation</a> () const</td></tr>
<tr class="separator:aae427477f592d34c1bf3367e408f90c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Internal information about the number of objects</div></td></tr>
<tr class="memitem:a4a466c6b1755b353d43ce8827b1518e3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines</a> () const</td></tr>
<tr class="separator:a4a466c6b1755b353d43ce8827b1518e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615e8e8877a420fede76cea831f6ca52"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a615e8e8877a420fede76cea831f6ca52">n_raw_lines</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a615e8e8877a420fede76cea831f6ca52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdcdaea38195ba043370ddc6202224"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads</a> () const</td></tr>
<tr class="separator:abbcdcdaea38195ba043370ddc6202224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f590c6799cf3bb79c3c810f972a117e"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a9f590c6799cf3bb79c3c810f972a117e">n_raw_quads</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a9f590c6799cf3bb79c3c810f972a117e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a359c972a4679b5ff1be96b68efc1"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#aed5a359c972a4679b5ff1be96b68efc1">n_raw_hexs</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:aed5a359c972a4679b5ff1be96b68efc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a947c26f9d04c1b4a4fb190334ebd1542">n_raw_cells</a> (const unsigned <a class="el" href="classint.html">int</a> level) const</td></tr>
<tr class="separator:a947c26f9d04c1b4a4fb190334ebd1542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7926c72a24cc478de8217c1f6988e0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a5a7926c72a24cc478de8217c1f6988e0">n_raw_faces</a> () const</td></tr>
<tr class="separator:a5a7926c72a24cc478de8217c1f6988e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0c10f7a8cd32d961e9367173685047"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a2f0c10f7a8cd32d961e9367173685047"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a2f0c10f7a8cd32d961e9367173685047">save</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a2f0c10f7a8cd32d961e9367173685047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ae2f72d5fbb277ec65dbe0382ae72a929">load</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ae2f72d5fbb277ec65dbe0382ae72a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7117ea716b516ef11a205a5d0020fe40"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a7117ea716b516ef11a205a5d0020fe40">add_periodicity</a> (const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&gt; &amp;)</td></tr>
<tr class="separator:a7117ea716b516ef11a205a5d0020fe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::pair&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::pair&lt; std::pair&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, std::bitset&lt; 3 &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac34318b9fb11fa49f10ba7c5155960c6">get_periodic_face_map</a> () const</td></tr>
<tr class="separator:ac34318b9fb11fa49f10ba7c5155960c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#af4f08d0df83f6455dbdac86c1a0736b8">get_reference_cells</a> () const</td></tr>
<tr class="separator:af4f08d0df83f6455dbdac86c1a0736b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c84e9fa932ccd35820fe68abfe1348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a24c84e9fa932ccd35820fe68abfe1348">all_reference_cells_are_hyper_cube</a> () const</td></tr>
<tr class="separator:a24c84e9fa932ccd35820fe68abfe1348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ac70afc9a4f52455c18183ab31dd6789f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ac70afc9a4f52455c18183ab31dd6789f">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ac70afc9a4f52455c18183ab31dd6789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a441a15483a49afc7422e578f9ff00277"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a441a15483a49afc7422e578f9ff00277">dimension</a> = dim</td></tr>
<tr class="separator:a441a15483a49afc7422e578f9ff00277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9591fbe1bf861f4333f1b2e3de0fc287"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#a9591fbe1bf861f4333f1b2e3de0fc287">spacedimension</a> = spacedim</td></tr>
<tr class="separator:a9591fbe1bf861f4333f1b2e3de0fc287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414a986e63a95d54e961b9b35d756fb"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a3414a986e63a95d54e961b9b35d756fb">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a3414a986e63a95d54e961b9b35d756fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ab46ea92d41782bce5e144a4d3a3a5e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;, <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#ab46ea92d41782bce5e144a4d3a3a5e4d">coarse_grid</a></td></tr>
<tr class="separator:ab46ea92d41782bce5e144a4d3a3a5e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bdbd79c06d70eebcd6ad0ba8e34592"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#af2bdbd79c06d70eebcd6ad0ba8e34592">refine_flags</a></td></tr>
<tr class="separator:af2bdbd79c06d70eebcd6ad0ba8e34592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f216df52f07f21749154ad5a0f9968"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPersistentTriangulation.html#ab9f216df52f07f21749154ad5a0f9968">coarsen_flags</a></td></tr>
<tr class="separator:ab9f216df52f07f21749154ad5a0f9968"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Keeping up with what happens to a triangulation</h2></td></tr>
<tr class="memitem:a1f047c753e5299ed179b042b1d014ee2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">CellStatus</a> { <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2a94cffc65673af17059d03284f1f4528a">CELL_PERSIST</a>, 
<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2a499cef1e66d839e3344b256fd5feb117">CELL_REFINE</a>, 
<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2a37a57cd1b9fd76f736f5e9e810011824">CELL_COARSEN</a>, 
<a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2a77e3cf6150ed62cd551424de92cc880b">CELL_INVALID</a>
 }</td></tr>
<tr class="separator:a1f047c753e5299ed179b042b1d014ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a></td></tr>
<tr class="separator:ad136f601f63a6d1bd8e205edd93cbae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Exceptions</h2></td></tr>
<tr class="memitem:gafc78a1322a1040b8601290e52f2cc532"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gafc78a1322a1040b8601290e52f2cc532">DeclException2</a> (ExcInvalidLevel, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are requesting information from refinement level &quot;&lt;&lt; arg1&lt;&lt; &quot; of a triangulation, but this triangulation only has &quot;&lt;&lt; arg2&lt;&lt; &quot; refinement levels. The given level &quot;&lt;&lt; arg1&lt;&lt; &quot; must be *less* than &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gafc78a1322a1040b8601290e52f2cc532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c118c9eb467d05ebe068651b74002ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8c118c9eb467d05ebe068651b74002ab">DeclException2</a> (ExcTriangulationNotEmpty, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are trying to perform an operation on a triangulation &quot;&lt;&lt; &quot;that is only allowed if the triangulation is currently empty. &quot;&lt;&lt; &quot;However, it currently stores &quot;&lt;&lt; arg1&lt;&lt; &quot; vertices and has &quot;&lt;&lt; &quot;cells on &quot;&lt;&lt; arg2&lt;&lt; &quot; levels.&quot;)</td></tr>
<tr class="separator:ga8c118c9eb467d05ebe068651b74002ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966384346b2c7308b814ab09065d0470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga966384346b2c7308b814ab09065d0470">DeclException0</a> (ExcGridReadError)</td></tr>
<tr class="separator:ga966384346b2c7308b814ab09065d0470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaafa031bdac9392e3cdaa7ecf87171335">DeclException0</a> (ExcFacesHaveNoLevel)</td></tr>
<tr class="separator:gaafa031bdac9392e3cdaa7ecf87171335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7cec3f85f90fe0e3d9e9ec626a0dbfc3">DeclException0</a> (ExcNonOrientableTriangulation)</td></tr>
<tr class="separator:ga7cec3f85f90fe0e3d9e9ec626a0dbfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga391a9a406c14d6830d2ccbf0c59b429b">DeclException1</a> (ExcEmptyLevel, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do something on level &quot;&lt;&lt; arg1&lt;&lt; &quot;, but this level is empty.&quot;)</td></tr>
<tr class="separator:ga391a9a406c14d6830d2ccbf0c59b429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9880263a1f12cd1dfecf45ac55c75c8b">DeclException1</a> (ExcBoundaryIdNotFound, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>,&lt;&lt; &quot;The given boundary_id &quot;&lt;&lt; arg1&lt;&lt; &quot; is not defined in this Triangulation!&quot;)</td></tr>
<tr class="separator:ga9880263a1f12cd1dfecf45ac55c75c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95a456ec8242cdf9109491510534f13d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga95a456ec8242cdf9109491510534f13d">DeclExceptionMsg</a> (ExcInconsistentCoarseningFlags, &quot;A cell is flagged for coarsening, but either not all of its siblings &quot; &quot;are active or flagged for coarsening as well. Please clean up all &quot; &quot;coarsen flags on your triangulation via &quot; &quot;<a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement</a>() beforehand!&quot;)</td></tr>
<tr class="separator:ga95a456ec8242cdf9109491510534f13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9474a14d0e8429412c82450013bde67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac9474a14d0e8429412c82450013bde67">smooth_grid</a></td></tr>
<tr class="separator:gac9474a14d0e8429412c82450013bde67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f47aa64420502db8ebeffd531572779"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classReferenceCell.html">ReferenceCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f47aa64420502db8ebeffd531572779">reference_cells</a></td></tr>
<tr class="separator:ga5f47aa64420502db8ebeffd531572779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9e3e5c077024f40355432c771ccf541"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9e3e5c077024f40355432c771ccf541">write_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::ostream &amp;out)</td></tr>
<tr class="separator:gaf9e3e5c077024f40355432c771ccf541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c92032e652bdafdfd7624a55aa2866"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20c92032e652bdafdfd7624a55aa2866">read_bool_vector</a> (const unsigned <a class="el" href="classint.html">int</a> magic_number1, std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;v, const unsigned <a class="el" href="classint.html">int</a> magic_number2, std::istream &amp;in)</td></tr>
<tr class="separator:ga20c92032e652bdafdfd7624a55aa2866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga609fee9e79ae50f4c348a39838c7eb0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga609fee9e79ae50f4c348a39838c7eb0c">update_periodic_face_map</a> ()</td></tr>
<tr class="separator:ga609fee9e79ae50f4c348a39838c7eb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ecff6fdc386de47c156781fb4217bcc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5ecff6fdc386de47c156781fb4217bcc">update_reference_cells</a> ()</td></tr>
<tr class="separator:ga5ecff6fdc386de47c156781fb4217bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class PersistentTriangulation&lt; dim, spacedim &gt;</h3>

<p>This class handles the history of a triangulation and can rebuild it after it was deleted some time before. Its main purpose is support for time- dependent problems where one frequently deletes a triangulation due to memory pressure and later wants to rebuild it; this class has all the information to rebuild it exactly as it was before including the mapping of cell numbers to the geometrical cells.</p>
<p>Basically, this is a drop-in replacement for the triangulation. Since it is derived from the <a class="el" href="classTriangulation.html">Triangulation</a> class, it shares all the functionality, but it overrides some virtual functions and adds some functions, too. The main change to the base class is that it overrides the <code>execute_coarsening_and_refinement</code> function, where the new version first stores all refinement and coarsening flags and only then calls the respective function of the base class. The stored flags may later be used to restore the grid just as it was before. Some other functions have been extended slightly as well, see their documentation for more information.</p>
<p>We note that since the triangulation is created in exactly the same state as it was before, other objects working on it should result in the same state as well. This holds in particular for the <a class="el" href="classDoFHandler.html">DoFHandler</a> object, which will assign the same degrees of freedom to the original cells and the ones after reconstruction of the triangulation. You can therefore safely use data vectors computed on the original grid on the reconstructed grid as well.</p>
<h3>Usage</h3>
<p>You can use objects of this class almost in the same way as objects of the <a class="el" href="classTriangulation.html">Triangulation</a> class. One of the few differences is that you can only construct such an object by giving a coarse grid to the constructor. The coarse grid will be used to base the triangulation on, and therefore the lifetime of the coarse grid has to be longer than the lifetime of the object of this class.</p>
<p>Basically, usage looks like this: </p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="classPersistentTriangulation.html#ab46ea92d41782bce5e144a4d3a3a5e4d">coarse_grid</a>;</div><div class="line">...                     <span class="comment">// initialize coarse grid</span></div><div class="line"></div><div class="line"><a class="code" href="classPersistentTriangulation.html">PersistentTriangulation&lt;dim&gt;</a> grid (coarse_grid);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (...)</div><div class="line">  {</div><div class="line">                        <span class="comment">// restore grid from coarse grid</span></div><div class="line">                        <span class="comment">// and stored refinement flags</span></div><div class="line">    grid.restore ();</div><div class="line">    ...                 <span class="comment">// do something with the grid</span></div><div class="line"></div><div class="line">    ...                 <span class="comment">// flag some cells for refinement</span></div><div class="line">                        <span class="comment">// or coarsening</span></div><div class="line">    grid.execute_coarsening_and_refinement ();</div><div class="line">                        <span class="comment">// actually refine grid and store</span></div><div class="line">                        <span class="comment">// the flags</span></div><div class="line"></div><div class="line">    ...                 <span class="comment">// so something more with the grid</span></div><div class="line"></div><div class="line">    grid.clear ();      <span class="comment">// delete the grid, but keep the</span></div><div class="line">                        <span class="comment">// refinement flags for later use</span></div><div class="line">                        <span class="comment">// in grid.restore() above</span></div><div class="line"></div><div class="line">    ...                 <span class="comment">// do something where the grid</span></div><div class="line">                        <span class="comment">// is not needed anymore, e.g.</span></div><div class="line">                        <span class="comment">// working with another grid</span></div><div class="line">  };</div></div><!-- fragment --><p>Note that initially, the <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a> object does not constitute a triangulation; it only becomes one after <code>restore</code> is first called. Note also that the <code>execute_coarsening_and_refinement</code> stores all necessary flags for later reconstruction using the <code>restore</code> function. <a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">Triangulation::clear()</a> resets the underlying triangulation to a virgin state, but does not affect the stored refinement flags needed for later reconstruction and does also not touch the coarse grid which is used within <a class="el" href="classPersistentTriangulation.html#a81ac6c5bc96ff989ac3649602a8dbc84">restore()</a>. </p>

<p class="definition">Definition at line <a class="el" href="persistent__tria_8h_source.html#l00108">108</a> of file <a class="el" href="persistent__tria_8h_source.html">persistent_tria.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad12cedb5139eeea73fb2a3eec16636f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12cedb5139eeea73fb2a3eec16636f8">&#9670;&nbsp;</a></span>level_cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriangulation.html#ad12cedb5139eeea73fb2a3eec16636f8">level_cell_iterator</a> =  <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above to allow the usage of the "MeshType concept" also on the refinement levels. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01361">1361</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a0633dd17e535a59162b79f338c6ff5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0633dd17e535a59162b79f338c6ff5ae">&#9670;&nbsp;</a></span>MeshSmoothing</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">Triangulation::MeshSmoothing</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare some symbolic names for mesh smoothing algorithms. The meaning of these flags is documented in the <a class="el" href="classTriangulation.html">Triangulation</a> class. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea9828da1d84133b33b112afd4a0ac15ec"></a>none&#160;</td><td class="fielddoc"><p>No mesh smoothing at all, except that meshes have to remain one- irregular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc"></a>limit_level_difference_at_vertices&#160;</td><td class="fielddoc"><p>It can be shown, that degradation of approximation occurs if the triangulation contains vertices which are member of cells with levels differing by more than one. One such example is the following:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p> It would seem that in two space dimensions, the maximum jump in levels between cells sharing a common vertex is two (as in the example above). However, this is not true if more than four cells meet at a vertex. It is not uncommon that a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse (initial) mesh</a> contains vertices at which six or even eight cells meet, when small features of the domain have to be resolved even on the coarsest mesh. In that case, the maximum difference in levels is three or four, respectively. The problem gets even worse in three space dimensions.</p>
<p>Looking at an interpolation of the second derivative of the finite element solution (assuming bilinear finite elements), one sees that the numerical solution is almost totally wrong, compared with the true second derivative. Indeed, on regular meshes, there exist sharp estimations that the H<sup>2</sup>-error is only of order one, so we should not be surprised; however, the numerical solution may show a value for the second derivative which may be a factor of ten away from the true value. These problems are located on the small cell adjacent to the center vertex, where cells of non-subsequent levels meet, as well as on the upper and right neighbor of this cell (but with a less degree of deviation from the true value).</p>
<p>If the smoothing indicator given to the constructor contains the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a>, situations as the above one are eliminated by also marking the upper right cell for refinement.</p>
<p>In case of anisotropic refinement, the level of a cell is not linked to the refinement of a cell as directly as in case of isotropic refinement. Furthermore, a cell can be strongly refined in one direction and not or at least much less refined in another. Therefore, it is very difficult to decide, which cases should be excluded from the refinement process. As a consequence, when using anisotropic refinement, the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">limit_level_difference_at_vertices</a> flag must not be set. On the other hand, the implementation of multigrid methods in deal.II requires that this bit be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f"></a>eliminate_unrefined_islands&#160;</td><td class="fielddoc"><p>Single cells which are not refined and are surrounded by cells which are refined usually also lead to a sharp decline in approximation properties locally. The reason is that the nodes on the faces between unrefined and refined cells are not real degrees of freedom but carry constraints. The patch without additional degrees of freedom is thus significantly larger then the unrefined cell itself. If in the parameter passed to the constructor the bit for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a> is set, all cells which are not flagged for refinement but which are surrounded by more refined cells than unrefined cells are flagged for refinement. Cells which are not yet refined but flagged for that are accounted for the number of refined neighbors. Cells on the boundary are not accounted for at all. An unrefined island is, by this definition also a cell which (in 2D) is surrounded by three refined cells and one unrefined one, or one surrounded by two refined cells, one unrefined one and is at the boundary on one side. It is thus not a true island, as the name of the flag may indicate. However, no better name came to mind to the author by now. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812"></a>patch_level_1&#160;</td><td class="fielddoc"><p>A triangulation of patch level 1 consists of patches, i.e. of cells that are refined once. This flag ensures that a mesh of patch level 1 is still of patch level 1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh is of patch level 1 before calling <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a> the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that if at least one of the children of a cell is or will be refined than all children need to be refined. If the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea37c283b96070dc09dde81f51d3ce1812">patch_level_1</a> flag is set, than the flags <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a>, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a> will be ignored as they will be fulfilled automatically. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeae94a75f4383724ef8f58639aef2eb6c0"></a>coarsest_level_1&#160;</td><td class="fielddoc"><p>Each <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse grid</a> cell is refined at least once, i.e., the triangulation might have active cells on level 1 but not on level 0. This flag ensures that a mesh which has coarsest_level_1 has still coarsest_level_1 after coarsening and refinement. It is, however, the user's responsibility to ensure that the mesh has coarsest_level_1 before calling execute_coarsening_and_refinement the first time. The easiest way to achieve this is by calling global_refine(1) straight after creation of the triangulation. It follows that active cells on level 1 may not be coarsened.</p>
<p>The main use of this flag is to ensure that each cell has at least one neighbor in each coordinate direction (i.e. each cell has at least a left or right, and at least an upper or lower neighbor in 2d). This is a necessary precondition for some algorithms that compute finite differences between cells. The <a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a> class is one of these algorithms that require that a triangulation is coarsest_level_1 unless all cells already have at least one neighbor in each coordinate direction on the coarsest level. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaa44d17458e16327fb4b674745b883910"></a>allow_anisotropic_smoothing&#160;</td><td class="fielddoc"><p>This flag is not included in <code>maximum_smoothing</code>. The flag is concerned with the following case: consider the case that an unrefined and a refined cell share a common face and that one of the children of the refined cell along the common face is flagged for further refinement. In that case, the resulting mesh would have more than one hanging node along one or more of the edges of the triangulation, a situation that is not allowed. Consequently, in order to perform the refinement, the coarser of the two original cells is also going to be refined.</p>
<p>However, in many cases it is sufficient to refine the coarser of the two original cells in an anisotropic way to avoid the case of multiple hanging vertices on a single edge. Doing only the minimal anisotropic refinement can save cells and degrees of freedom. By specifying this flag, the library can produce these anisotropic refinements.</p>
<p>The flag is not included by default since it may lead to anisotropically refined meshes even though no cell has ever been refined anisotropically explicitly by a user command. This surprising fact may lead to programs that do the wrong thing since they are not written for the additional cases that can happen with anisotropic meshes, see the discussion in the introduction to step-30. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e"></a>eliminate_refined_inner_islands&#160;</td><td class="fielddoc"><p>This algorithm seeks for isolated cells which are refined or flagged for refinement. This definition is unlike that for <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf065376600b9b08c1c65d00505225e2f">eliminate_unrefined_islands</a>, which would mean that an island is defined as a cell which is refined but more of its neighbors are not refined than are refined. For example, in 2D, a cell's refinement would be reverted if at most one of its neighbors is also refined (or refined but flagged for coarsening).</p>
<p>The reason for the change in definition of an island is, that this option would be a bit dangerous, since if you consider a chain of refined cells (e.g. along a kink in the solution), the cells at the two ends would be coarsened, after which the next outermost cells would need to be coarsened. Therefore, only one loop of flagging cells like this could be done to avoid eating up the whole chain of refined cells (`chain reaction'...).</p>
<p>This algorithm also takes into account cells which are not actually refined but are flagged for refinement. If necessary, it takes away the refinement flag.</p>
<p>Actually there are two versions of this flag, <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a> and <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58">eliminate_refined_boundary_islands</a>. The first eliminates islands defined by the definition above which are in the interior of the domain, while the second eliminates only those islands if the cell is at the boundary. The reason for this split of flags is that one often wants to eliminate such islands in the interior while those at the boundary may well be wanted, for example if one refines the mesh according to a criterion associated with a boundary integral or if one has rough boundary data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea5eaba327f7131b70f58aa6d0837dfa58"></a>eliminate_refined_boundary_islands&#160;</td><td class="fielddoc"><p>The result of this flag is very similar to <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaf3f26812258d56f4306f9b4a4858ee1e">eliminate_refined_inner_islands</a>. See the documentation there. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea75171630dec90d241c811d2732410303"></a>do_not_produce_unrefined_islands&#160;</td><td class="fielddoc"><p>This flag prevents the occurrence of unrefined islands. In more detail: It prohibits the coarsening of a cell if 'most of the neighbors' will be refined after the step. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea3fb6b9153821aefc45661f67f22e232a"></a>smoothing_on_refinement&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon refinement by flagging some more cells for refinement. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aea8d8dbaaa62136a7e51c7bf5c02d6e1e7"></a>smoothing_on_coarsening&#160;</td><td class="fielddoc"><p>This flag sums up all smoothing algorithms which may be performed upon coarsening by flagging some more cells for coarsening. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0633dd17e535a59162b79f338c6ff5aeaf64b535fd0fad99b6032412d2cccac36"></a>maximum_smoothing&#160;</td><td class="fielddoc"><p>This flag includes all the above ones (therefore combines all smoothing algorithms implemented), with the exception of anisotropic smoothing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01136">1136</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="a1f047c753e5299ed179b042b1d014ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f047c753e5299ed179b042b1d014ee2">&#9670;&nbsp;</a></span>CellStatus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTriangulation.html#a1f047c753e5299ed179b042b1d014ee2">Triangulation::CellStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to inform functions in derived classes how the cell with the given cell_iterator is going to change. Note that this may me different than the refine_flag() and coarsen_flag() in the cell_iterator in parallel calculations because of refinement constraints that this machine does not see. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1f047c753e5299ed179b042b1d014ee2a94cffc65673af17059d03284f1f4528a"></a>CELL_PERSIST&#160;</td><td class="fielddoc"><p>The cell will not be refined or coarsened and might or might not move to a different processor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1f047c753e5299ed179b042b1d014ee2a499cef1e66d839e3344b256fd5feb117"></a>CELL_REFINE&#160;</td><td class="fielddoc"><p>The cell will be or was refined. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1f047c753e5299ed179b042b1d014ee2a37a57cd1b9fd76f736f5e9e810011824"></a>CELL_COARSEN&#160;</td><td class="fielddoc"><p>The children of this cell will be or were coarsened into this cell. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1f047c753e5299ed179b042b1d014ee2a77e3cf6150ed62cd551424de92cc880b"></a>CELL_INVALID&#160;</td><td class="fielddoc"><p>Invalid status. Will not occur for the user. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l02025">2025</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afa3e603cc1093240eb218d3ff34598a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3e603cc1093240eb218d3ff34598a5">&#9670;&nbsp;</a></span>PersistentTriangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coarse_grid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build up the triangulation from the coarse grid in future. Copy smoothing flags, etc from that grid as well. Note that the initial state of the triangulation is empty, until <code>restore_grid</code> is called for the first time.</p>
<p>The coarse grid must persist until the end of this object, since it will be used upon reconstruction of the grid. </p>

</div>
</div>
<a id="a11870f737c7c01d26037139cd3fb71c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11870f737c7c01d26037139cd3fb71c5">&#9670;&nbsp;</a></span>PersistentTriangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::<a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>old_tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. This operation is only allowed, if the triangulation underlying the object to be copied is presently empty. Refinement flags as well as the pointer to the coarse grid are copied, however. </p>

</div>
</div>
<a id="a3a7a32000c89e02cc219d81fa37a7838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7a32000c89e02cc219d81fa37a7838">&#9670;&nbsp;</a></span>~PersistentTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::~<a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3db24bddb2e9013086c7a33a4fc506d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db24bddb2e9013086c7a33a4fc506d5">&#9670;&nbsp;</a></span>execute_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::execute_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overloaded version of the same function in the base class which stores the refinement and coarsening flags for later reconstruction of the triangulation and after that calls the respective function of the base class. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a81ac6c5bc96ff989ac3649602a8dbc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81ac6c5bc96ff989ac3649602a8dbc84">&#9670;&nbsp;</a></span>restore() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::restore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restore the grid according to the saved data. For this, the coarse grid is copied and the grid is stepwise rebuilt using the saved flags.</p>
<p>Note that this function will result in an error if the underlying triangulation is not empty, i.e. it will only succeed if this object is newly created or the <code><a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">clear()</a></code> function of the base class was called on it before.</p>
<p>Repeatedly calls the <code><a class="el" href="classPersistentTriangulation.html#a90b58ff62c5d3900cbe5295e100df691">restore(unsigned int)</a></code> function in a loop over all refinement steps. </p>

</div>
</div>
<a id="a90b58ff62c5d3900cbe5295e100df691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b58ff62c5d3900cbe5295e100df691">&#9670;&nbsp;</a></span>restore() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::restore </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>step_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Differential restore. Performs the <code>step_noth</code> local refinement and coarsening step. Step 0 stands for the copying of the coarse grid.</p>
<p>This function will only succeed if the triangulation is in just the state it were if restore would have been called from <code>step=0...step_no-1</code> before. </p>

</div>
</div>
<a id="ae6ec1e44b40efccc65aafbdc242a7e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ec1e44b40efccc65aafbdc242a7e8f">&#9670;&nbsp;</a></span>n_refinement_steps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::n_refinement_steps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of refinement and coarsening steps. This is given by the size of the <code>refine_flags</code> vector. </p>

</div>
</div>
<a id="a62d8ee4421ec25e3408f15613a7a9b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d8ee4421ec25e3408f15613a7a9b3f">&#9670;&nbsp;</a></span>copy_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::copy_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overload this function to use <code>tria</code> as a new coarse grid. The present triangulation and all refinement and coarsening flags storing its history are deleted, and the state of the underlying triangulation is reset to be empty, until <code>restore_grid</code> is called the next time.</p>
<p>The coarse grid must persist until the end of this object, since it will be used upon reconstruction of the grid. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a1bca327fa47f88b58086dacc20028064">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ac411e19b10ae782223450271c249358b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac411e19b10ae782223450271c249358b">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Throw an error, since this function is not useful in the context of this class. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a1b191fa3249c9c3641492b6eedebf456">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ac497f405da11cf43ab7e7256aba7fff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac497f405da11cf43ab7e7256aba7fff4">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTriangulationDescription_1_1Description.html">TriangulationDescription::Description</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>construction_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>Create a triangulation from a list of vertices and a list of cells, each of the latter being a list of <code>1&lt;&lt;dim</code> vertex indices. The triangulation must be empty upon calling this function and the cell list should be useful (connected domain, etc.). The result of calling this function is a <a class="el" href="DEALGlossary.html#GlossCoarseMesh">coarse mesh</a>.</p>
<p>Material data for the cells is given within the <code>cells</code> array, while boundary information is given in the <code>subcelldata</code> field.</p>
<p>The numbering of vertices within the <code>cells</code> array is subject to some constraints; see the general class documentation for this.</p>
<p>For conditions when this function can generate a valid triangulation, see the documentation of this class, and the <a class="el" href="classGridIn.html">GridIn</a> and <a class="el" href="classGridReordering.html">GridReordering</a> class.</p>
<p>If the <code>check_for_distorted_cells</code> flag was specified upon creation of this object, at the very end of its operation, the current function walks over all cells and verifies that none of the cells is deformed (see the entry on <a class="el" href="DEALGlossary.html#GlossDistorted">distorted cells</a> in the glossary), where we call a cell deformed if the determinant of the Jacobian of the mapping from reference cell to real cell is negative at least at one of the vertices (this computation is done using the GeometryInfo::jacobian_determinants_at_vertices function). If there are deformed cells, this function throws an exception of kind DistortedCellList. Since this happens after all data structures have been set up, you can catch and ignore this exception if you know what you do &ndash; for example, it may be that the determinant is zero (indicating that you have collapsed edges in a cell) but that this is ok because you didn't intend to integrate on this cell anyway. On the other hand, deformed cells are often a sign of a mesh that is too coarse to resolve the geometry of the domain, and in this case ignoring the exception is probably unwise.</p>
<dl class="section note"><dt>Note</dt><dd>This function is used in step-14 and step-19.</dd>
<dd>
This function triggers the "create" signal after doing its work. See the section on signals in the general documentation of this class. For example as a consequence of this, all <a class="el" href="classDoFHandler.html">DoFHandler</a> objects connected to this triangulation will be reinitialized via <a class="el" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">DoFHandler::reinit()</a>.</dd>
<dd>
The check for distorted cells is only done if dim==spacedim, as otherwise cells can legitimately be twisted if the manifold they describe is twisted.</dd>
<dd>
Not implemented yet. </dd></dl>

<p>Reimplemented from <a class="el" href="classTriangulation.html#aa80c37d5d647831736e40e4ffb0e0ee2">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ad6215eb2339ec45320d5858ccae5aab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6215eb2339ec45320d5858ccae5aab6">&#9670;&nbsp;</a></span>create_triangulation_compatibility()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::create_triangulation_compatibility </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structCellData.html">CellData</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSubCellData.html">SubCellData</a> &amp;&#160;</td>
          <td class="paramname"><em>subcelldata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An overload of the respective function of the base class.</p>
<p>Throw an error, since this function is not useful in the context of this class. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#abbbee6e665998c3e4a745cd7836df364">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a0c63e56783c3c8d74d508d6dc9a51fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c63e56783c3c8d74d508d6dc9a51fcc">&#9670;&nbsp;</a></span>write_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::write_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write all refine and coarsen flags to the ostream <code>out</code>. </p>

</div>
</div>
<a id="a0e2a6e2c8a65e5c6df1877dd128a0958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2a6e2c8a65e5c6df1877dd128a0958">&#9670;&nbsp;</a></span>read_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::read_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads all refine and coarsen flags that previously were written by <code>write_flags(...)</code>. This is especially useful for rebuilding the triangulation after the end or breakdown of a program and its restart. </p>

</div>
</div>
<a id="a1a3890ccc438c4ea70f5c947e7f2306c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3890ccc438c4ea70f5c947e7f2306c">&#9670;&nbsp;</a></span>clear_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::clear_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all flags. Retains the same coarse grid. </p>

</div>
</div>
<a id="a17b9533b25ed580656f17c823bad0cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b9533b25ed580656f17c823bad0cf9">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

<p>Reimplemented from <a class="el" href="classTriangulation.html#a4a63bdde5124e79a1370f29499128518">Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a878d98c53ac8fb2fda0e378998aa8c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878d98c53ac8fb2fda0e378998aa8c57">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcTriaNotEmpty&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception. </p>

</div>
</div>
<a id="a310b8eb8036e6841f99e6be426a15254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310b8eb8036e6841f99e6be426a15254">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcFlagsNotCleared&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception. </p>

</div>
</div>
<a id="a12d54b7dae635d867bf8d2c4b3605817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d54b7dae635d867bf8d2c4b3605817">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset this triangulation into a virgin state by deleting all data.</p>
<p>Note that this operation is only allowed if no subscriptions to this object exist any more, such as <a class="el" href="classDoFHandler.html">DoFHandler</a> objects using it. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#af8b346b087dd89464415ecb7d2775a61">parallel::DistributedTriangulationBase&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#af8b346b087dd89464415ecb7d2775a61">parallel::DistributedTriangulationBase&lt; 1, spacedim &gt;</a>, <a class="el" href="classparallel_1_1DistributedTriangulationBase.html#af8b346b087dd89464415ecb7d2775a61">parallel::DistributedTriangulationBase&lt; dim, dim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#af19cebc16207fc60f8b0ab1eb1c4540f">parallel::distributed::Triangulation&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a1005ad6002b51c5bc4592da7246b6a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1005ad6002b51c5bc4592da7246b6a49">&#9670;&nbsp;</a></span>get_communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return MPI communicator used by this triangulation. In the case of a serial <a class="el" href="classTriangulation.html">Triangulation</a> object, MPI_COMM_SELF is returned. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#a77b606a3f26f71603f7759dc16d33db9">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a4a302f66ccc9bd281cf850fdc4f76e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a302f66ccc9bd281cf850fdc4f76e50">&#9670;&nbsp;</a></span>set_mesh_smoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_mesh_smoothing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&#160;</td>
          <td class="paramname"><em>mesh_smoothing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the mesh smoothing to <code>mesh_smoothing</code>. This overrides the MeshSmoothing given to the constructor. It is allowed to call this function only if the triangulation is empty. </p>

</div>
</div>
<a id="a06df95bfd43216e389a132786f87474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06df95bfd43216e389a132786f87474f">&#9670;&nbsp;</a></span>get_mesh_smoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5ae">MeshSmoothing</a>&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_mesh_smoothing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mesh smoothing requirements that are obeyed. </p>

</div>
</div>
<a id="a05662a55166596efb520479b495275f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05662a55166596efb520479b495275f8">&#9670;&nbsp;</a></span>get_boundary_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_boundary_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector containing all boundary indicators assigned to boundary faces of active cells of this <a class="el" href="classTriangulation.html">Triangulation</a> object. Note, that each boundary indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#a1e1acf0c97fceec538c4552ee300213c">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="afdc34248a9ba0c38fd0020256a8def5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc34248a9ba0c38fd0020256a8def5c">&#9670;&nbsp;</a></span>flip_all_direction_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::flip_all_direction_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Revert or flip the direction_flags of a dim&lt;spacedim triangulation, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a>.</p>
<p>This function throws an exception if dim equals spacedim. </p>

</div>
</div>
<a id="aed8e461d4b2b23a0e1730afdef36e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8e461d4b2b23a0e1730afdef36e694">&#9670;&nbsp;</a></span>set_all_refine_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_refine_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flag all active cells for refinement. This will refine all cells of all levels which are not already refined (i.e. only cells are refined which do not yet have children). The cells are only flagged, not refined, thus you have the chance to save the refinement flags. </p>

</div>
</div>
<a id="a6ad0b3fb24aae17f4668427a433dea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad0b3fb24aae17f4668427a433dea19">&#9670;&nbsp;</a></span>refine_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::refine_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Refine all cells <code>times</code> times. In other words, in each one of the <code>times</code> iterations, loop over all cells and refine each cell uniformly into \(2^\text{dim}\) children. In practice, this function repeats the following operations <code>times</code> times: call <a class="el" href="classTriangulation.html#aed8e461d4b2b23a0e1730afdef36e694">set_all_refine_flags()</a> followed by <a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">execute_coarsening_and_refinement()</a>. The end result is that the number of cells increases by a factor of \((2^\text{dim})^\text{times}=2^{\text{dim} \times \text{times}}\).</p>
<p>The <a class="el" href="classPersistentTriangulation.html#a3db24bddb2e9013086c7a33a4fc506d5">execute_coarsening_and_refinement()</a> function called in this loop may throw an exception if it creates cells that are distorted (see its documentation for an explanation). This exception will be propagated through this function if that happens, and you may not get the actual number of refinement steps in that case.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual refinement cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="a6552fa04ee753657bd9f92571d76cf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552fa04ee753657bd9f92571d76cf09">&#9670;&nbsp;</a></span>coarsen_global()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::coarsen_global </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coarsen all cells the given number of times.</p>
<p>In each of one of the <code>times</code> iterations, all cells will be marked for coarsening. If an active cell is already on the coarsest level, it will be ignored.</p>
<dl class="section note"><dt>Note</dt><dd>This function triggers the pre- and post-refinement signals before and after doing each individual coarsening cycle (i.e. more than once if <code>times &gt; 1</code>) . See the section on signals in the general documentation of this class. </dd></dl>

</div>
</div>
<a id="abf55199c30b0330cf9bf98e2582078e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf55199c30b0330cf9bf98e2582078e1">&#9670;&nbsp;</a></span>prepare_coarsening_and_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::prepare_coarsening_and_refinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do both preparation for refinement and coarsening as well as mesh smoothing.</p>
<p>Regarding the refinement process it fixes the closure of the refinement in <code>dim&gt;=2</code> (make sure that no two cells are adjacent with a refinement level differing with more than one), etc. It performs some mesh smoothing if the according flag was given to the constructor of this class. The function returns whether additional cells have been flagged for refinement.</p>
<p>See the general doc of this class for more information on smoothing upon refinement.</p>
<p>Regarding the coarsening part, flagging and deflagging cells in preparation of the actual coarsening step are done. This includes deleting coarsen flags from cells which may not be deleted (e.g. because one neighbor is more refined than the cell), doing some smoothing, etc.</p>
<p>The effect is that only those cells are flagged for coarsening which will actually be coarsened. This includes the fact that all flagged cells belong to parent cells of which all children are flagged.</p>
<p>The function returns whether some cells' flagging has been changed in the process.</p>
<p>This function uses the user flags, so store them if you still need them afterwards. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0ad472f89b0dde244ecc13989806e78d">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#a72f1055d0943aa43610c131091159cbe">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aca5cfa9068a5d3ad32dfca87e2901a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5cfa9068a5d3ad32dfca87e2901a87">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the addresses of the cells which are flagged for refinement to <code>out</code>. For usage, read the general documentation for this class. </p>

</div>
</div>
<a id="affce5fca29acccbb2dc1294ebe404a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affce5fca29acccbb2dc1294ebe404a03">&#9670;&nbsp;</a></span>save_refine_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="a43fc07c3f9e1f02658ca556f41087c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fc07c3f9e1f02658ca556f41087c85">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="ac924a05e66d5e76458ad088a2b7b5583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac924a05e66d5e76458ad088a2b7b5583">&#9670;&nbsp;</a></span>load_refine_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_refine_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="af64b6155fd89f8f29d4c02795c1a10d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64b6155fd89f8f29d4c02795c1a10d9">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>save_refine_flags</code>. </p>

</div>
</div>
<a id="abaaecbe89311fdaa8a9b999209ff9155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaaecbe89311fdaa8a9b999209ff9155">&#9670;&nbsp;</a></span>save_coarsen_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. </p>

</div>
</div>
<a id="aa4029122ffe741f843f2f3a7deeceea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4029122ffe741f843f2f3a7deeceea9">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a48a9463dcf9aeb3a69831e5e1a321053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a9463dcf9aeb3a69831e5e1a321053">&#9670;&nbsp;</a></span>load_coarsen_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_coarsen_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Analogue to <code>load_refine_flags</code>. </p>

</div>
</div>
<a id="a178e9ce017916f190ddf7a734ef15902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178e9ce017916f190ddf7a734ef15902">&#9670;&nbsp;</a></span>get_anisotropic_refinement_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_anisotropic_refinement_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether this triangulation has ever undergone anisotropic (as opposed to only isotropic) refinement. </p>

</div>
</div>
<a id="aaa726b33b52f694cfca48fae8e761661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa726b33b52f694cfca48fae8e761661">&#9670;&nbsp;</a></span>clear_user_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6a9971ee882f15fe521afc4e079383b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9971ee882f15fe521afc4e079383b5">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user flags. See the general documentation for this class and the documentation for the <code>save_refine_flags</code> for more details. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="aad25280beb6c2607418a0d3e903819a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad25280beb6c2607418a0d3e903819a3">&#9670;&nbsp;</a></span>save_user_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af3612ed3c7f7f9cccd3003d85b6f7350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3612ed3c7f7f9cccd3003d85b6f7350">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ac17946286639b12a03804ebc400eab51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17946286639b12a03804ebc400eab51">&#9670;&nbsp;</a></span>load_user_flags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <code>save_user_flags</code>. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="af8896f8e838dd34ed5b7c1aa351f76f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8896f8e838dd34ed5b7c1aa351f76f5">&#9670;&nbsp;</a></span>clear_user_flags_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a2b7d8e059d6f8f903879eea858215fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7d8e059d6f8f903879eea858215fb8">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a02adea7b298cd5047ee5a5755f87ae36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02adea7b298cd5047ee5a5755f87ae36">&#9670;&nbsp;</a></span>save_user_flags_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a25190c31d16cde2a01fa0f2318aa0b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25190c31d16cde2a01fa0f2318aa0b74">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a87294511c2f203a57531aaaf2bd2ce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87294511c2f203a57531aaaf2bd2ce39">&#9670;&nbsp;</a></span>load_user_flags_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1dd263157214206ceb637c402552f0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd263157214206ceb637c402552f0eb">&#9670;&nbsp;</a></span>clear_user_flags_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_quad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="acf4a2db0492d38971366bfcd159cbbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4a2db0492d38971366bfcd159cbbc1">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a431026974872f49e59f6a799ee0a19d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431026974872f49e59f6a799ee0a19d6">&#9670;&nbsp;</a></span>save_user_flags_quad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a5e868cde85c04bcc8cec82ba09f24e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e868cde85c04bcc8cec82ba09f24e7b">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a8651e0def48d61e3f8f0aa8051ae5985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8651e0def48d61e3f8f0aa8051ae5985">&#9670;&nbsp;</a></span>load_user_flags_quad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a7cbe198bb49c3135378bb680582afd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbe198bb49c3135378bb680582afd46">&#9670;&nbsp;</a></span>clear_user_flags_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_flags_hex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user flags on quads. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a1d5512376f914359303ce7d4666d550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5512376f914359303ce7d4666d550b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user flags on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="ae57c92493d66995cf29bef79f0e8e09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57c92493d66995cf29bef79f0e8e09b">&#9670;&nbsp;</a></span>save_user_flags_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as above, but store the flags to a bitvector rather than to a file. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a6e15f4d848adbe6c8bf1af374e467a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e15f4d848adbe6c8bf1af374e467a31">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a77e827086d26927d08129c8489fdcd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e827086d26927d08129c8489fdcd45">&#9670;&nbsp;</a></span>load_user_flags_hex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_flags_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user flags located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a>. </p>

</div>
</div>
<a id="a26562806fd764afdffb973dce92554e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26562806fd764afdffb973dce92554e8">&#9670;&nbsp;</a></span>clear_user_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all user pointers and indices and allow the use of both for next access. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="ae3794cd2d7f80bd81f69fcb828535412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3794cd2d7f80bd81f69fcb828535412">&#9670;&nbsp;</a></span>save_user_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user indices. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a12a2359968a027a8b14ae381c8886d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a2359968a027a8b14ae381c8886d30">&#9670;&nbsp;</a></span>load_user_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#ae3794cd2d7f80bd81f69fcb828535412">save_user_indices()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a03a41f6c10b5db7d540a9df15742ebf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a41f6c10b5db7d540a9df15742ebf0">&#9670;&nbsp;</a></span>save_user_pointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save all user pointers. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a2f8891e8277a047b9dd4fe86943d1321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8891e8277a047b9dd4fe86943d1321">&#9670;&nbsp;</a></span>load_user_pointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the information stored by <a class="el" href="classTriangulation.html#a03a41f6c10b5db7d540a9df15742ebf0">save_user_pointers()</a>. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a451b2af8e62783f4780552088fd9ad88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b2af8e62783f4780552088fd9ad88">&#9670;&nbsp;</a></span>save_user_indices_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7b2160dd04545294d138ca00deb4af42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2160dd04545294d138ca00deb4af42">&#9670;&nbsp;</a></span>load_user_indices_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8d65cc99c33ea13361700a58ff9d6686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d65cc99c33ea13361700a58ff9d6686">&#9670;&nbsp;</a></span>save_user_indices_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a1020c09b32fbb78156b00b833271e21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1020c09b32fbb78156b00b833271e21d">&#9670;&nbsp;</a></span>load_user_indices_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a8a18d1c25ca9c0b7cef07c6e92fdd28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18d1c25ca9c0b7cef07c6e92fdd28f">&#9670;&nbsp;</a></span>save_user_indices_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="abad8869b9c8234d6c81c24c69dd97d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8869b9c8234d6c81c24c69dd97d39">&#9670;&nbsp;</a></span>load_user_indices_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_indices_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user indices located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a699d7c1b73eccc41bc53009003ab3d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699d7c1b73eccc41bc53009003ab3d28">&#9670;&nbsp;</a></span>save_user_pointers_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user indices on lines. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a879d77427982a2d69d2dd9512d4ba6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879d77427982a2d69d2dd9512d4ba6c9">&#9670;&nbsp;</a></span>load_user_pointers_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_line </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on lines. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a7d27b23e1d873b38817d08b7bb6884f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d27b23e1d873b38817d08b7bb6884f8">&#9670;&nbsp;</a></span>save_user_pointers_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on quads. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a4f771811ec221a4ca0c49f3a09164fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f771811ec221a4ca0c49f3a09164fec">&#9670;&nbsp;</a></span>load_user_pointers_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_quad </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on quads. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="ac42ad416119dff0589b8b67dd3de02e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42ad416119dff0589b8b67dd3de02e8">&#9670;&nbsp;</a></span>save_user_pointers_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save the user pointers on hexes. The output vector is resized if necessary. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a03dad0c49d2423e8c4410efcc773ad82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dad0c49d2423e8c4410efcc773ad82">&#9670;&nbsp;</a></span>load_user_pointers_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load_user_pointers_hex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; void *&gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load the user pointers located on hexs. See also <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a>. </p>

</div>
</div>
<a id="a36fb6b15f119483143c433dd10df9b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb6b15f119483143c433dd10df9b26">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used cell on level <code>level</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="afe6c58805fe436a94b141c1585606c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6c58805fe436a94b141c1585606c7f">&#9670;&nbsp;</a></span>begin_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active cell on level <code>level</code>. If the given level does not contain any active cells (i.e., all cells on this level are further refined, then this function returns <code>end_active(level)</code> so that loops of the kind </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> cell=tria.begin_active(level);</div><div class="line">     cell!=tria.end_active(level);</div><div class="line">     ++cell)</div><div class="line">  {</div><div class="line">    ...</div><div class="line">  }</div></div><!-- fragment --><p> have zero iterations, as may be expected if there are no active cells on this level.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="a92c41c89a9cf1e020050985822196dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c41c89a9cf1e020050985822196dff">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="a9597b118c84fce0addf7f4db3b067659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9597b118c84fce0addf7f4db3b067659">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator which is the first iterator not on level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab0967cc6653ea9a08e94fe9da4d11793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0967cc6653ea9a08e94fe9da4d11793">&#9670;&nbsp;</a></span>end_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an active iterator which is the first active iterator not on the given level. If <code>level</code> is the last level, then this returns <code><a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>The given <code>level</code> argument needs to correspond to a level of the triangulation, i.e., should be less than the value returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. On the other hand, for parallel computations using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object, it is often convenient to write loops over the cells of all levels of the global mesh, even if the <em>local</em> portion of the triangulation does not actually have cells at one of the higher levels. In those cases, the <code>level</code> argument is accepted if it is less than what the <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a> function returns. If the given <code>level</code> is between the values returned by <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> and <a class="el" href="classTriangulation.html#aafd960d483675c4eb2c538529350e56b">n_global_levels()</a>, then no cells exist in the local portion of the triangulation at this level, and the function simply returns what <a class="el" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end()</a> would return. </dd></dl>

</div>
</div>
<a id="ab51f6fbd9bcd9e41757039a7b4954d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51f6fbd9bcd9e41757039a7b4954d2a">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last used cell. </p>

</div>
</div>
<a id="a2eb00096abe5ef91413440e1e1b66c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb00096abe5ef91413440e1e1b66c00">&#9670;&nbsp;</a></span>last_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga08c836c1e503743e8073eb615603aab9">active_cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::last_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the last active cell. </p>

</div>
</div>
<a id="a367c0bd718b0ae9316f3b6f52d0ff4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367c0bd718b0ae9316f3b6f52d0ff4c6">&#9670;&nbsp;</a></span>create_cell_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::create_cell_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellId.html">CellId</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to a cell of this <a class="el" href="classTriangulation.html">Triangulation</a> object constructed from an independent <a class="el" href="classCellId.html">CellId</a> object.</p>
<p>If the given argument corresponds to a valid cell in this triangulation, this operation will always succeed for sequential triangulations where the current processor stores all cells that are part of the triangulation. On the other hand, if this is a parallel triangulation, then the current processor may not actually know about this cell. In this case, this operation will succeed for locally relevant cells, but may not for artificial cells that are less refined on the current processor. </p>

</div>
</div>
<a id="abd8e77917e8512bd1e70bf180929f407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8e77917e8512bd1e70bf180929f407">&#9670;&nbsp;</a></span>begin_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used face. </p>

</div>
</div>
<a id="af7e8d4115aad4a2a5c97a7f7c06d34d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8d4115aad4a2a5c97a7f7c06d34d5">&#9670;&nbsp;</a></span>begin_active_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gad77aace3a5c6c96b985cbf22a28c83f2">active_face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active face. </p>

</div>
</div>
<a id="a359dfdc82f2269b68b1d30c8a2286c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359dfdc82f2269b68b1d30c8a2286c6f">&#9670;&nbsp;</a></span>end_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga4015f9d1dc9115fbdf74d74960bec074">face_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. </p>

</div>
</div>
<a id="aa76498325599ace7304627cb64e5fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76498325599ace7304627cb64e5fcd2">&#9670;&nbsp;</a></span>begin_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first used vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a0e8705fe160c08af9a2372c605525ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8705fe160c08af9a2372c605525ef0">&#9670;&nbsp;</a></span>begin_active_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#ga8738294ebb9d165e6b431589b0bbc7f7">active_vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::begin_active_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator to the first active vertex. Because all vertices are active, <a class="el" href="classTriangulation.html#aa76498325599ace7304627cb64e5fcd2">begin_vertex()</a> and <a class="el" href="classTriangulation.html#a0e8705fe160c08af9a2372c605525ef0">begin_active_vertex()</a> return the same vertex. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="aaad93f466afba9b3f003d09a685a615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad93f466afba9b3f003d09a685a615f">&#9670;&nbsp;</a></span>end_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Iterators.html#gac23052ad0b446137324ccf9ea0fd386e">vertex_iterator</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::end_vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator past the end; this iterator serves for comparisons of iterators with past-the-end or before-the-beginning states. This function can only be used if dim is not one. </p>

</div>
</div>
<a id="a46edbe1027405ca9545e3c2289eb3938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46edbe1027405ca9545e3c2289eb3938">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In the following, most functions are provided in two versions, with and without an argument describing the level. The versions with this argument are only applicable for objects describing the cells of the present triangulation. For example: in 2D <code>n_lines(level)</code> cannot be called, only <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code>, as lines are faces in 2D and therefore have no level. Return the total number of used lines, active or not. </p>

</div>
</div>
<a id="aee5ba9d51dfdd307da590e31c9262c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5ba9d51dfdd307da590e31c9262c28">&#9670;&nbsp;</a></span>n_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used lines, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="a76c9d6f7b2068f5afa429020086b6b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c9d6f7b2068f5afa429020086b6b8c">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines. </p>

</div>
</div>
<a id="a21d30203bdeaa3b9e2b416f24b7e9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d30203bdeaa3b9e2b416f24b7e9d6d">&#9670;&nbsp;</a></span>n_active_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active lines, on level <code>level</code>. </p>

</div>
</div>
<a id="a105d0305d8c801076bea2404087f29a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d0305d8c801076bea2404087f29a7">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not. </p>

</div>
</div>
<a id="af0817fceed7429359f89928eec87d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0817fceed7429359f89928eec87d381">&#9670;&nbsp;</a></span>n_quads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="ab7a0837c6dabdda21930bf3d49e9852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a0837c6dabdda21930bf3d49e9852d">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not. </p>

</div>
</div>
<a id="abf97ad6187b553b2980043dd1c8d75db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf97ad6187b553b2980043dd1c8d75db">&#9670;&nbsp;</a></span>n_active_quads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active quads, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="aaa75fe811e9d1707ce798f874aa2e117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa75fe811e9d1707ce798f874aa2e117">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not. </p>

</div>
</div>
<a id="a015bc7a2fecb2cba52050a8f2bfbafe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015bc7a2fecb2cba52050a8f2bfbafe1">&#9670;&nbsp;</a></span>n_hexs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="aee621a8e59e259c252ccc64f19e37301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee621a8e59e259c252ccc64f19e37301">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not. </p>

</div>
</div>
<a id="ade8bbb4c8ffd9f8adb683b39a82a9b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8bbb4c8ffd9f8adb683b39a82a9b1e">&#9670;&nbsp;</a></span>n_active_hexs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active hexahedra, active or not on level <code>level</code>. </p>

</div>
</div>
<a id="abea687f123f3f5a8b09d7485cf03be72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea687f123f3f5a8b09d7485cf03be72">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not. Maps to <code><a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a40c5623c62d2e43aa63f1eb4904eeec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c5623c62d2e43aa63f1eb4904eeec8">&#9670;&nbsp;</a></span>n_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used cells, active or not, on level <code>level</code>. Maps to <code>n_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a5ea5c9957dbb566a562bbe2c0f3971e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea5c9957dbb566a562bbe2c0f3971e9">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells. Maps to <code><a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a></code> in one space dimension and so on. </p>

</div>
</div>
<a id="a3d106ed8c9a29d6bb7d2bfb636f8df62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d106ed8c9a29d6bb7d2bfb636f8df62">&#9670;&nbsp;</a></span>n_active_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells on level <code>level</code>. Maps to <code>n_active_lines(level)</code> in one space dimension and so on. </p>

</div>
</div>
<a id="a05502400e5b4bdd3bb7e0fd410fdf0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05502400e5b4bdd3bb7e0fd410fdf0fb">&#9670;&nbsp;</a></span>n_global_active_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_global_active_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active cells. For the current class, this is the same as <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells()</a>. However, the function may be overloaded in derived classes (e.g., in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>) where it may return a value greater than the number of active cells reported by the triangulation object on the current processor. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#a46548d5ed479030dbc75d8fbb2b68d11">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1bff048d1ed54471bbd2dcfc76a46523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bff048d1ed54471bbd2dcfc76a46523">&#9670;&nbsp;</a></span>n_global_coarse_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a36be5a74b99dd3f4ab38a2c183250adf">types::coarse_cell_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_global_coarse_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of coarse cells. If the coarse mesh is replicated on each process, this simply returns <code>n_cells(0)</code>. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#ae5d830897853a1098344e718dd878147">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1e297d311818e3a79bcede5804f51065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e297d311818e3a79bcede5804f51065">&#9670;&nbsp;</a></span>n_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of used faces, active or not. In 2D, the result equals <a class="el" href="classTriangulation.html#a46edbe1027405ca9545e3c2289eb3938">n_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#a105d0305d8c801076bea2404087f29a7">n_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a5ae907d55b3b12c5c75e58174c1781ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae907d55b3b12c5c75e58174c1781ff">&#9670;&nbsp;</a></span>n_active_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_active_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of active faces. In 2D, the result equals <a class="el" href="classTriangulation.html#a76c9d6f7b2068f5afa429020086b6b8c">n_active_lines()</a>, in 3D it equals <a class="el" href="classTriangulation.html#ab7a0837c6dabdda21930bf3d49e9852d">n_active_quads()</a>, while in 1D it equals the number of used vertices. </p>

</div>
</div>
<a id="a777f035a17e91a4d822971516ca11db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777f035a17e91a4d822971516ca11db5">&#9670;&nbsp;</a></span>n_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in this triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, triangulations store data in levels, and there may be more levels in this data structure than one may think &ndash; for example, imagine a triangulation that we just got by coarsening the highest level so that it was completely depopulated. That level is not removed, since it will most likely be repopulated soon by the next refinement process. As a consequence, if you happened to run through raw cell iterators (which you can't do as a user of this class, but can internally), then the number of objects in the levels hierarchy is larger than the level of the most refined cell plus one. On the other hand, since this is rarely what a user of this class cares about, the function really just returns the level of the most refined active cell plus one. (The plus one is because in a coarse, unrefined mesh, all cells have level zero &ndash; making the number of levels equal to one.) </dd></dl>

</div>
</div>
<a id="aafd960d483675c4eb2c538529350e56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd960d483675c4eb2c538529350e56b">&#9670;&nbsp;</a></span>n_global_levels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_global_levels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of levels in use. This function is equivalent to <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> for a serial <a class="el" href="classTriangulation.html">Triangulation</a>, but gives the maximum of <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a> over all processors for a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> and therefore can be larger than <a class="el" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels()</a>. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#ab94c22b8116e1b5f4284ae01b221a2e2">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a935cc3b953d71fe4081fa8f88820f034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935cc3b953d71fe4081fa8f88820f034">&#9670;&nbsp;</a></span>has_hanging_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::has_hanging_nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the triangulation has hanging nodes.</p>
<p>The function is made virtual since the result can be interpreted in different ways, depending on whether the triangulation lives only on a single processor, or may be distributed as done in the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> class (see there for a description of what the function is supposed to do in the parallel context). </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim, spacedim &gt;</a>, <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a569306c9c8e694e3006f8fafa035f0ce">parallel::distributed::Triangulation&lt; dim &gt;</a>, and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html#ad8f243bcd205946abc5c9bea8ad323af">parallel::fullydistributed::Triangulation&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ae1aadc2300ef9a6f2368fe7bc5926fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1aadc2300ef9a6f2368fe7bc5926fe8">&#9670;&nbsp;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of vertices. Some of them may not be used, which usually happens upon coarsening of a triangulation when some vertices are discarded, but we do not want to renumber the remaining ones, leading to holes in the numbers of used vertices. You can get the number of used vertices using <code>n_used_vertices</code> function. </p>

</div>
</div>
<a id="afb3059d54432e0d739534e5330bb7b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3059d54432e0d739534e5330bb7b3a">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to all the vertices present in this triangulation. Note that not necessarily all vertices in this array are actually used; for example, if you coarsen a mesh, then some vertices are deleted, but their positions in this array are unchanged as the indices of vertices are only allocated once. You can find out about which vertices are actually used by the function <a class="el" href="classTriangulation.html#a07690a619d2817f4c8ef3bb74c43b80a">get_used_vertices()</a>. </p>

</div>
</div>
<a id="a76937acd9dfc3ade1fb885c7ab1ae776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76937acd9dfc3ade1fb885c7ab1ae776">&#9670;&nbsp;</a></span>n_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of vertices that are presently in use, i.e. belong to at least one used element. </p>

</div>
</div>
<a id="aab2295fdb4bfc8ab41f51cdbc34de449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2295fdb4bfc8ab41f51cdbc34de449">&#9670;&nbsp;</a></span>vertex_used()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::vertex_used </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vertex with this <code>index</code> is used. </p>

</div>
</div>
<a id="a07690a619d2817f4c8ef3bb74c43b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690a619d2817f4c8ef3bb74c43b80a">&#9670;&nbsp;</a></span>get_used_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_used_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to the array of <code>bools</code> indicating whether an entry in the vertex array is used or not. </p>

</div>
</div>
<a id="aa6313a19a8cc20e07249978218b5ca6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6313a19a8cc20e07249978218b5ca6a">&#9670;&nbsp;</a></span>max_adjacent_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::max_adjacent_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum number of cells meeting at a common vertex. Since this number is an invariant under refinement, only the cells on the coarsest level are considered. The operation is thus reasonably fast. The invariance is only true for sufficiently many cells in the coarsest triangulation (e.g. for a single cell one would be returned), so a minimum of four is returned in two dimensions, 8 in three dimensions, etc, which is how many cells meet if the triangulation is refined.</p>
<p>In one space dimension, two is returned. </p>

</div>
</div>
<a id="a5827cdfafd5fef99803cde97b70e86bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5827cdfafd5fef99803cde97b70e86bc">&#9670;&nbsp;</a></span>locally_owned_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::locally_owned_subdomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function always returns <code>invalid_subdomain_id</code> but is there for compatibility with the derived <code><a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a></code> class. For distributed parallel triangulations this function returns the subdomain id of those cells that are owned by the current processor. </p>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="acbcac8668993d582f192d3c85b642dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbcac8668993d582f192d3c85b642dd3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object.</p>
<p>This doesn't seem to be very useful but allows to write code that can access the underlying triangulation for anything that satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> (which may not only be a triangulation, but also a <a class="el" href="classDoFHandler.html">DoFHandler</a>, for example). </p>

</div>
</div>
<a id="aae427477f592d34c1bf3367e408f90c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae427477f592d34c1bf3367e408f90c3">&#9670;&nbsp;</a></span>get_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the current object. This is the const-version of the previous function. </p>

</div>
</div>
<a id="a4a466c6b1755b353d43ce8827b1518e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a466c6b1755b353d43ce8827b1518e3">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of lines, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a615e8e8877a420fede76cea831f6ca52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615e8e8877a420fede76cea831f6ca52">&#9670;&nbsp;</a></span>n_raw_lines() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_lines </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of lines, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="abbcdcdaea38195ba043370ddc6202224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcdcdaea38195ba043370ddc6202224">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of quads, used or unused.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a9f590c6799cf3bb79c3c810f972a117e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f590c6799cf3bb79c3c810f972a117e">&#9670;&nbsp;</a></span>n_raw_quads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_quads </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of quads, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="aed5a359c972a4679b5ff1be96b68efc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a359c972a4679b5ff1be96b68efc1">&#9670;&nbsp;</a></span>n_raw_hexs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_hexs </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of hexs, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a947c26f9d04c1b4a4fb190334ebd1542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947c26f9d04c1b4a4fb190334ebd1542">&#9670;&nbsp;</a></span>n_raw_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_cells </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of cells, used or unused, on the given level.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a5a7926c72a24cc478de8217c1f6988e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7926c72a24cc478de8217c1f6988e0">&#9670;&nbsp;</a></span>n_raw_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::n_raw_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of faces, used or not. In 2d, the result equals <a class="el" href="classTriangulation.html#a4a466c6b1755b353d43ce8827b1518e3">n_raw_lines()</a>, in 3d it equals <a class="el" href="classTriangulation.html#abbcdcdaea38195ba043370ddc6202224">n_raw_quads()</a>, while in 1D it equals the number of vertices.</p>
<dl class="section note"><dt>Note</dt><dd>This function really exports internal information about the triangulation. It shouldn't be used in applications. The function is only part of the public interface of this class because it is used in some of the other classes that build very closely on it (in particular, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class). </dd></dl>

</div>
</div>
<a id="a2f0c10f7a8cd32d961e9367173685047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0c10f7a8cd32d961e9367173685047">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not save <em>all</em> member variables of the current triangulation. Rather, only certain kinds of information are stored. For more information see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="ae2f72d5fbb277ec65dbe0382ae72a929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f72d5fbb277ec65dbe0382ae72a929">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. Throw away the previous content.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not reset <em>all</em> member variables of the current triangulation to the ones of the triangulation that was previously stored to an archive. Rather, only certain kinds of information are loaded. For more information see the general documentation of this class.</dd>
<dd>
This function calls the <a class="el" href="classTriangulation.html#a12d54b7dae635d867bf8d2c4b3605817">Triangulation::clear()</a> function and consequently triggers the "clear" signal. After loading all data from the archive, it then triggers the "create" signal. For more information on signals, see the general documentation of this class. </dd></dl>

</div>
</div>
<a id="a7117ea716b516ef11a205a5d0020fe40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7117ea716b516ef11a205a5d0020fe40">&#9670;&nbsp;</a></span>add_periodicity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::add_periodicity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structGridTools_1_1PeriodicFacePair.html">GridTools::PeriodicFacePair</a>&lt; <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare the (coarse) face pairs given in the argument of this function as periodic. This way it is possible to obtain neighbors across periodic boundaries.</p>
<p>The vector can be filled by the function <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>.</p>
<p>For more information on periodic boundary conditions see <a class="el" href="namespaceGridTools.html#aee88c4dce5066a41183b5dd70289b9df">GridTools::collect_periodic_faces</a>, <a class="el" href="namespaceDoFTools.html#a929249499b1e5624728d212e90a8e037">DoFTools::make_periodicity_constraints</a> and step-45.</p>
<dl class="section note"><dt>Note</dt><dd>Before this function can be used the <a class="el" href="classTriangulation.html">Triangulation</a> has to be initialized and must not be refined. </dd></dl>

</div>
</div>
<a id="ac34318b9fb11fa49f10ba7c5155960c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34318b9fb11fa49f10ba7c5155960c6">&#9670;&nbsp;</a></span>get_periodic_face_map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::pair&lt;<a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::pair&lt;std::pair&lt;<a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a>&gt;, std::bitset&lt;3&gt; &gt; &gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_periodic_face_map </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the periodic_face_map. </p>

</div>
</div>
<a id="af4f08d0df83f6455dbdac86c1a0736b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f08d0df83f6455dbdac86c1a0736b8">&#9670;&nbsp;</a></span>get_reference_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classReferenceCell.html">ReferenceCell</a>&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_reference_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return vector filled with the used reference-cell types of this triangulation. </p>

</div>
</div>
<a id="a24c84e9fa932ccd35820fe68abfe1348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c84e9fa932ccd35820fe68abfe1348">&#9670;&nbsp;</a></span>all_reference_cells_are_hyper_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::all_reference_cells_are_hyper_cube </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicate if the triangulation only consists of hypercube-like cells, i.e., lines, quadrilaterals, or hexahedra. </p>

</div>
</div>
<a id="ac70afc9a4f52455c18183ab31dd6789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70afc9a4f52455c18183ab31dd6789f">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization. using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a441a15483a49afc7422e578f9ff00277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441a15483a49afc7422e578f9ff00277">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="persistent__tria_8h_source.html#l00114">114</a> of file <a class="el" href="persistent__tria_8h_source.html">persistent_tria.h</a>.</p>

</div>
</div>
<a id="a9591fbe1bf861f4333f1b2e3de0fc287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9591fbe1bf861f4333f1b2e3de0fc287">&#9670;&nbsp;</a></span>spacedimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::spacedimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="persistent__tria_8h_source.html#l00115">115</a> of file <a class="el" href="persistent__tria_8h_source.html">persistent_tria.h</a>.</p>

</div>
</div>
<a id="ab46ea92d41782bce5e144a4d3a3a5e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46ea92d41782bce5e144a4d3a3a5e4d">&#9670;&nbsp;</a></span>coarse_grid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;, <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::coarse_grid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This grid shall be used as coarse grid. </p>

<p class="definition">Definition at line <a class="el" href="persistent__tria_8h_source.html#l00269">269</a> of file <a class="el" href="persistent__tria_8h_source.html">persistent_tria.h</a>.</p>

</div>
</div>
<a id="af2bdbd79c06d70eebcd6ad0ba8e34592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bdbd79c06d70eebcd6ad0ba8e34592">&#9670;&nbsp;</a></span>refine_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; &gt; <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::refine_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vectors holding the refinement and coarsening flags of the different sweeps on this time level. The vectors therefore hold the history of the grid. </p>

<p class="definition">Definition at line <a class="el" href="persistent__tria_8h_source.html#l00276">276</a> of file <a class="el" href="persistent__tria_8h_source.html">persistent_tria.h</a>.</p>

</div>
</div>
<a id="ab9f216df52f07f21749154ad5a0f9968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f216df52f07f21749154ad5a0f9968">&#9670;&nbsp;</a></span>coarsen_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; &gt; <a class="el" href="classPersistentTriangulation.html">PersistentTriangulation</a>&lt; dim, spacedim &gt;::coarsen_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classPersistentTriangulation.html#af2bdbd79c06d70eebcd6ad0ba8e34592">refine_flags</a> </p>

<p class="definition">Definition at line <a class="el" href="persistent__tria_8h_source.html#l00281">281</a> of file <a class="el" href="persistent__tria_8h_source.html">persistent_tria.h</a>.</p>

</div>
</div>
<a id="a3414a986e63a95d54e961b9b35d756fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3414a986e63a95d54e961b9b35d756fb">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make the space-dimension available in function templates. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l01547">1547</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<a id="ad136f601f63a6d1bd8e205edd93cbae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad136f601f63a6d1bd8e205edd93cbae3">&#9670;&nbsp;</a></span>signals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTriangulation_1_1Signals.html">Signals</a> <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::signals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signals for the various actions that a triangulation can do to itself. </p>

<p class="definition">Definition at line <a class="el" href="grid_2tria_8h_source.html#l02289">2289</a> of file <a class="el" href="grid_2tria_8h_source.html">tria.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/grid/<a class="el" href="persistent__tria_8h_source.html">persistent_tria.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
