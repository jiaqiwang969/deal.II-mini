<a name="Intro"></a>


<h1> About the tutorial </h1>
deal.II 文档包含丰富的学习文档，但对于刚刚接触C++的初学者来说，要想深入理解和改写底层框架着实难度巨大。其一个重要的原因是，deal.II 的底层是基于范型编程的思想。deal.II目前所提供的所有教程并未对数据结构的细节进行解读，这块工作显得神秘且不可触及。

该教程取名step-0。仅仅是个人学习STL、boost和deal.II的读书笔记，目的是尽快加强自身编程能力，也希望能够帮助到更多热爱deal.II的小伙伴。如有任何好的想法和建议，欢迎随时联系交流。

基本构想包含几大块，随着学习的深入，在今后将逐步完善:
- STL源码剖析: 包括配置器、迭代器、仿函数、容器、算法、配接器，这六大组建的核心代码学习。 
  参考：侯捷的STL源码解析和Alinshans/MyTinySTL，C++Primer Plus 第6版以及Nicolai M. Josuttis的The C++ Standard Library。
- Boost程序库探秘: 
  参考Björn Karlsson的An Introduction to Boost。(这本书似乎写的不太好，继续寻找合适的教材)
- Deal.II程序库探秘: 
  参考deal.II documentation。
- 对应的测试库及案例库，在tests/mystl中可以找到，均包括cc和output两个文件。
- member function或者algorithm的解析，将以代码注解的形式出现，最终被doxygen转化到对应的Classes中。


在某种程度上，范型编程的概念与面向对象编程的原始想法相矛盾。范型编程分离了数据和算法，而不是将它们结合起来。然而，这样做的原因是非常重要的。原则上，你可以将每一种容器与每一种算法结合起来，所以结果是一个非常灵活但仍然相当小的框架。
范型编程的一个基本方面是，所有的组件都能与任意类型一起工作。正如 "标准模板库 "这个名字所表明的，所有组件都是任何类型的模板，只要该类型能够执行所需的操作。因此，STL是范型编程概念的一个好例子。容器和算法分别对任意类型和类是通用的。

<p align="center">
   <div class="img" align="center">
      <img src="https://cdn.mathpix.com/snip/images/h3mftGdwXF4wlt3p8uFJlO9wD_5M2akhGkJI9ARei9M.original.fullsize.png"
           alt = ""
           width="500">
    </div>
</p>




相比这些参考的参考书，这里的教程更加关注STL、boost和deal.II之间的联系，我们可以通过剥离算法，探究并挖掘三者数据结构之间的共性。当然，数据结构和算法的组合也并非随意的，具有非常紧密的匹配关系。无论怎么样，deal.II的很多代码的书写逻辑，借鉴了很多STL、boost的编程思想，当然也包括很多对STL和boost库的调用。

我一直在思考如何更高效地学习deal.II的底层代码。通过对比STL、boost和deal.II不同但结构相近的代码块，似乎是一种有效的手段。





<h1>Introduction</h1>

<h2> STL源码剖析 </h2>
从程序员的角度来看，STL提供了一堆满足各种需求的集合类，同时还有一些对它们进行操作的算法。STL的所有组件都是模板，所以它们可以被用于任意的元素类型。但是STL做的更多。它提供了一个框架，用于提供其他集合类或现有集合类和算法的工作。总而言之，STL给了C++一个新的抽象层次。忘掉动态数组、链表、二叉树或哈希表的编程；忘掉不同搜索算法的编程。要使用适当的集合种类，你只需定义适当的容器并调用相应的成员函数和算法来处理数据。

<p align="center">
   <div class="img" align="center">
      <img src="https://cdn.mathpix.com/snip/images/Gxq-T236sC7KWf2iFP_ISYj-f4URRwusZX8eSsOTUE4.original.fullsize.png"
           alt = ""
           width="500">
    </div>
</p>




<h3> 分配器 </h3>
C++标准库使用特殊的对象来处理内存的分配和取消分配。包括了 allocator 和 constructor，分别定义在 allocator.h 和 construct.h 中。allocator 负责空间的配置与回收，定义了一个类 mystl::alloc 用于管理内存，定义在 alloc.h 。
constructor 负责对象的构造与析构，对应两个全局函数： construct 和 destroy。它们代表一种特殊的内存模型，并被用作一种抽象，将使用内存的需求转化为对内存的原始调用。同时使用不同的分配器对象允许你在程序中使用不同的内存模型。





<h3> 容器 </h3>
容器是用来管理某类对象的集合的。每种容器都有自己的优点和缺点，所以拥有不同的容器类型反映了程序中对集合的不同要求。容器可以被实现为数组或链接列表，也可以为每个元素设置一个特殊的键。

容器分为序列容器、关联容器和无序容器三大类。

序列容器是有序的集合，其中每个元素都有一定的位置。这个位置取决于插入的时间和地点，但它与元素的价值无关。例如，如果你把六个元素放到一个有序的集合中，把每个元素附在集合的末尾，那么这些元素就处于你所放的确切顺序中。STL包含五个预定义的序列容器类：数组、向量、deque、列表和forward_list。

关联容器是排序的集合，其中一个元素的位置由于某种排序标准的存在取决于它的值（或键，如果它是一个键的话）。如果你把六个元素放入一个集合，它们的值决定了它们的顺序。插入的顺序并不重要。STL包含四个预定义的关联容器类：set、multiset、map和multimap。

 无序（关联）容器是无序的集合，其中一个元素的位置并不重要。唯一重要的问题是一个特定的元素是否在这样一个集合中。插入的顺序和插入元素的值都不会对元素的位置产生影响，而且位置可能会在容器的生命周期内发生变化。因此，如果你把六个元素放到一个集合中，它们的顺序是未定义的，并且可能随着时间的推移而改变。STL包含四个预定义的无序容器类：unordered_set, unordered_multiset, unordered_map, 和unordered_multimap。

序列式容器通常被实现为数组或链表。关联的容器通常被实现为二进制树。无序的容器通常被实现为哈希表。

<p align="center">
   <div class="img" align="center">
      <img src="https://cdn.mathpix.com/snip/images/VWnS4G3Buu7-aBCwOZaxoTbCSQzMkpxnY6fOhoNyo28.original.fullsize.png"
           alt = ""
           width="500">
    </div>
</p>

- vector（向量）
- list（双向链表）
- deque（双端队列）
- map/multimap（映射）
- set/multiset（集合）
- unordered_map/unordered_multimap（无序映射）
- unordered_set/unordered_multiset（无序集合）
- basic_string （字符序列）

无序的容器通常被实现为一个哈希表。因此，在内部，该容器是一个链接列表的数组。使用一个哈希函数，一个元素在数组中的位置被处理。目的是让每个元素都有自己的位置，这样你就可以快速访问每个元素，只要哈希函数是快速的。但是由于这样快速的完美哈希函数并不总是可能的，或者可能需要数组消耗大量的内存，所以多个元素可能有相同的位置。出于这个原因，数组中的元素是链接列表，这样就可以在每个数组位置存储多个元素。

无序容器的主要优点是，找到一个具有特定值的元素比关联容器更快。事实上，只要你有一个好的哈希函数，使用无序容器就可以提供摊销的恒定复杂度。然而，提供一个好的哈希函数并不容易，而且你可能需要大量的内存来存放桶。


<p align="center">
   <div class="img" align="center">
      <img src="https://cdn.mathpix.com/snip/images/Mg4Tedy7kScS4Njtv1WSnjKT9jX5FJMJrX0Fd7HLqUg.original.fullsize.png"
           alt = ""
           width="500">
    </div>
</p>






<h3> 迭代器 </h3>
迭代器被用来遍历对象集合中的元素。这些集合可以是容器或容器的子集。迭代器的主要优点是，它们为任何任意的容器类型提供了一个小而通用的接口。例如，这个接口的一个操作让迭代器步入到集合中的下一个元素。这与集合的内部结构无关。不管这个集合是一个数组、一棵树还是一个哈希表，它都可以工作。这是因为每个容器类都提供了自己的迭代器类型，它只是 "做正确的事情"，因为它知道其容器的内部结构。

迭代器的接口与普通指针的接口几乎相同。要增加一个迭代器，你可以调用操作符++。要访问一个迭代器的值，你要使用操作符*。因此，你可以认为迭代器是一种智能指针，它将 "转到下一个元素 "的调用转化为任何适当的内容。

iterator，连接着容器与算法，定义在 iterator.h 中。每个容器都附带专属的迭代器，是一种重载了 operator*，operator->，operator++，operator-- 等操作的模板类。

<h4> 迭代器用于for-loop </h4>

<p align="center">
   <div class="img" align="center">
      <img src="https://cdn.mathpix.com/snip/images/Y9HfA8GCq7DoSNmAm5Zt_AGWW97aswKhdgOWuXvi3tk.original.fullsize.png"
           alt = ""
           width="500">
    </div>
</p>


迭代器是一种范化的指针，类似指针做for循环的操作。
@code
      Contatiner<T> c;
      ...
      Container<T>::interator ite = c.begin();
      for (; ite != c.end(); ++ite)
        ...
@endcode

对应，这是老版本的deal.II 8.3.0, 所用到的迭代器的for-loop。
@code
  for (unsigned int step=0; step<5; ++step)
    {
      Triangulation<2>::active_cell_iterator
      cell = triangulation.begin_active(),
      endc = triangulation.end();
      for (; cell!=endc; ++cell)
        {
          for (unsigned int v=0;
               v < GeometryInfo<2>::vertices_per_cell;
               ++v)
            {
              const double distance_from_center
                = center.distance (cell->vertex(v));
              if (std::fabs(distance_from_center - inner_radius) < 1e-10)
                {
                  cell->set_refine_flag ();
                  break;
                }
            }
        }
      triangulation.execute_coarsening_and_refinement ();
    }

@endcode


C++-11后，增加了一种叫range-base statement的写法，引入了  `auto`。
@code
      Contatiner<T> c;
      ...
      Container<T>::interator ite = c.begin();
      for (auto element : c)
        ...
@endcode
对应，新版本的deal.II里面的操作：
@code
  for (unsigned int step=0; step<5; ++step)
    {
      for (auto cell: triangulation.active_cell_iterators())
        {
          for (unsigned int v=0;
               v < GeometryInfo<2>::vertices_per_cell;
               ++v)
            {
              const double distance_from_center
                = center.distance (cell->vertex(v));
              if (std::fabs(distance_from_center - inner_radius) < 1e-10)
                {
                  cell->set_refine_flag ();
                  break;
                }
            }
        }
      triangulation.execute_coarsening_and_refinement ();
    }
@endcode


<h4> 迭代器用于set </h4>
@code
IntSet::const_iterator pos; 
for (pos = coll.begin(); pos != coll.end(); ++pos) 
{ 
  cout << *pos << ' ' ; 
}
@endcode

迭代器会按照一定的机制，即“算法”运行，依次输出1 2 3 4 5 6.
<p align="center">
   <div class="img" align="center">
      <img src="https://cdn.mathpix.com/snip/images/ivQuR--wYKd08FQRCnEGK5csx7ElLqNw42hDLd1bevY.original.fullsize.png"
           alt = ""
           width="300">
    </div>
</p>

multiset允许重复。

<h4> 迭代器用于hash表 </h4>
可以看到，hash表也是有规律可循的，它遵从一定的算法。我之前有一个搞计算机系搞基因编码的老师，他经常提起hash表。当时，我是一脸蒙蔽的。现在想想，基因序列可能也是按照一定的规则进行存储。
<p align="center">
   <div class="img" align="center">
      <img src="https://cdn.mathpix.com/snip/images/Ds-SMZmZpqs_Z0G5UOUd6k6FoiLLhiiMDPUqYUpCAvk.original.fullsize.png"
           alt = ""
           width="300">
    </div>
</p>



<h3> 算法 </h3>
算法是用来处理集合的元素的。例如，算法可以搜索、排序、修改，或简单地将元素用于各种目的。算法使用迭代器。因此，由于迭代器的迭代器接口对所有的容器类型都是通用的，一个算法只需要写一次就可以与任意的容器一起工作。

算法不是容器类的成员函数，而是用迭代器操作的全局函数。这有一个重要的好处：每个算法不是为每个容器类型实现的，而是对任何容器类型都只实现一次。该算法甚至可以对不同容器类型的元素进行操作。你也可以为用户定义的容器类型使用这些算法。总而言之，这个概念减少了代码量，增加了库的力量和灵活性。

为了赋予算法更多的灵活性，你可以提供某些由算法调用的辅助函数。因此，你可以使用一个一般的算法来满足你的需要，即使这种需要非常特殊或复杂。例如，你可以提供你自己的搜索标准或一个特殊的操作来组合元素。特别是自C++11以来，随着lambdas的引入，你可以很容易地指定几乎任何种类的功能，同时在一个容器的元素上运行。



- 基本算法（14个） 定义在 algobase.h
- 数值算法（5个） 定义在 numeric.h
- set 算法（4个） 定义在 set_algo.h
- heap 算法（4个） 定义在 heap_algo.h
- 其它算法（54个） 定义在 algo.h

<h4> 算法的复杂度测试 </h4>

目前常见的 Big-oh 有下列几种情形：
1. $\mathrm{O}(1)$ 或 $\mathrm{O}(\mathrm{c}):$ 称为常数时间(constant time)
2. $\mathrm{O}(\mathrm{n}):$ 称为线性时间(linear time)
3. $\mathrm{O}\left(\log _{2} \mathrm{n}\right):$ 称为次线性时间(sub-linear time)
4. $\mathrm{O}\left(\mathrm{n}^{2}\right):$ 称为平方时间(quadratic time)
5. $\mathrm{O}\left(\mathrm{n}^{3}\right):$ 称为立方时间(cubic time)
6. $\mathrm{O}\left(2^{\mathrm{n}}\right):$ 称为指数时间( exponential time)
7. $\mathrm{O}\left(\mathrm{n} \log _{2} \mathrm{n}\right):$ 介于线性及二次方成长的中间之行为模式

<h3> 配接器 </h3>
<h4> container adapters </h4>
 - stack (栈) ： 后进先出（LIFO）
 - queue (队列) ： 后进先出（LIFO）
 - priority_queue (优先队列) ： 优先级是基于程序员可能提供的排序标准（默认情况下，使用运算符<）。

<h4> iterator adapters </h4>

 迭代器是纯粹的抽象概念。任何表现得像迭代器的东西都是迭代器。由于这个原因，你可以编写具有迭代器接口的类，但做一些完全不同的事情。C++标准库提供了几个预定义的特殊迭代器：迭代器适配器。
 - insert iterators: 插入迭代器，或称插入器，是用来让算法在插入模式而不是覆盖模式下运行的。特别是，插入器解决了向没有足够空间的目标写入的算法的问题。他们让目的地相应地增长。主要包括Back inserters、Front inserters 和 General inserters。
 - stream iterators: 流迭代器从流中读取或写入。因此，它们提供了一个抽象，让来自键盘的输入表现为一个集合，你可以从中读取。同样地，你可以将一个算法的输出直接重定向到一个文件或屏幕上。
 - reverse_iterators: reverse_iterator 是一种反向迭代器，重载了 operator*，operator->，operator++，operator--，operator+，operator-，operator+=，operatpr-=，operator[] 等操作，变前进为后退，后退为前进。
 - move iterators: 移动迭代器从C++11开始提供，它们将对底层元素的任何访问转换成移动操作。

<h4> function adapters </h4>
- binders


<h3> 函数对象  </h3>
函数对象是泛型编程的力量和纯抽象概念的另一个例子。你可以说，任何表现得像一个函数的东西都是一个函数。所以，如果你定义了一个行为像函数的对象，它就可以像函数一样被使用。 算法的功能参数不一定是函数。正如在lambdas中看到的那样，功能参数可以是行为类似于函数的对象。这样的对象被称为函数对象，或者说是functor，定义在 functional.h 中。。

函数对象是以函数方式与（）结合使用的任意对象。其包含函数名、指向函数的指针和重载了（）运算符的类对象，即定义类函数operator()()的类。


- Predicates: 谓词是一种特殊的辅助函数。谓词返回一个布尔值，通常用于指定一个排序或搜索标准。根据其目的，谓词是单数或二数。
- Lambdas函数: 从C++11引入的Lambdas定义了一种在表达式或语句中指定功能行为的方法。因此，你可以定义代表功能行为的对象，并将这些对象作为内联参数传递给算法，作为谓词或用于其他目的。

举一个例子：
@code
// transform all elements to the power of 3 
std::transform (coll.begin(), coll.end(),  // source
                coll.begin(),              // destination
                [](double d){              // lambda as function object
                  return d*d*d
                });
@endcode
另外一个条件搜索的例子：
@code 
// find element > x and < y
vector (pos = coll.begin() ; pos != coll.end(); ++pos){
  if (*pos > x && *pos < y)
    break; // the loop
}
@endcode
利用predicate的写法:
@code 
bool pred (int i)
{
  return i > x && i < y;
}
...
pos = find_if (coll.begin(), coll.end(),  //range
               pred);                     // search criterion
@endcode
利用lambda函数后的写法：
@code
auto pos = find_if (coll.cbegin(), coll.cend(),
                    [=](int i){            // [=]表示传递值到lambda主体
                      return i > x && i < y;
                    });
@endcode



由于函数对象的概念比较重要，我们再举一个The C++ Standard Library书上的例子：

原始输出int函数的写法:
@code
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

// function that prints the passed argument
void print (int elem)
{
    cout << elem << ' ';
}

int main()
{
    vector<int> coll;

    // insert elements from 1 to 9
    for (int i=1; i<=9; ++i) {
        coll.push_back(i);
    }

    // print all elements
    for_each (coll.cbegin(), coll.cend(),  // range
              print);                      // operation
    cout << endl;
}
@endcode


如果你想让对象有这样的行为，你就必须通过使用括号和传递参数来使 "调用 "它们成为可能。
具体代码形式有：
@code
class X {
  public:
    // define "function call" operator:
    return-value operator() (arguments) const; // 括号被重载
    ...
}
@endcode
定义完函数对象以后，就可以通过类来调用它：
@code
X fo；
...
fo(arg1, arg2);                     // call operator () for function object fo
fo.opeartor()(arg1, arg2);          // which is equivalent to the above
@endcode

因此，利用函数对象后的写法:
@code
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

// PrintInt类定义了可以用int参数调用运算符（）的对象
class PrintInt {
  public:
    void operator() (int elem) const {
        cout << elem << ' ';
    }
};

int main()
{
    vector<int> coll;

    // insert elements from 1 to 9
    for (int i=1; i<=9; ++i) {
        coll.push_back(i);
    }

    // print all elements
    for_each (coll.cbegin(), coll.cend(),  // range
              PrintInt());                 // operation
    cout << endl;
}
@endcode

这里的for_each 算法出自:
@code
namespace std{
  template <typename Iterator, typename Operation>
  Operation for_each (Iterator act, Iterator end, Operation op)
  {
    while (act != end){  // as long as not reached the end
      op(*act);          // - call op() for actual element
      ++act;             // - move iterator to the next element
    }
    return op;
  }

}
@endcode


这个例子后，可以发现，其实前面所谓的Predicates，lambda函数背后都表示一个函数对象。

TODO: 这块知识点，今后需要进一步扩展到boost和deal.II案例。参考书为：The C++ Standard Library的第六章节。这个案例最好放在cc文件中重点解析。

<h4> 总结函数对象的优点 </h4>
- 函数对象是 "有状态的函数"。行为像指针的对象是智能指针。对于行为像函数的对象来说，这也是同样的道理。它们可以是 "智能函数"，因为它们可能具有超越运算符（）的能力。函数对象可以有其他成员函数和属性。这意味着，函数对象有一个状态。事实上，由同一类型的两个不同的函数对象所代表的同一个函数特性，可能在同一时间有不同的状态。这对普通函数来说是不可能的。函数对象的另一个优点是，你可以在运行时初始化它们，然后再使用。

- 每个函数对象都有自己的类型。普通函数只有在其签名不同时才有不同的类型。然而，函数对象可以有不同的类型，即使它们的签名是相同的。事实上，每个由函数对象定义的功能行为都有自己的类型。这对于使用模板的通用编程来说是一个重大的改进，因为你可以将功能行为作为模板参数来传递。这样做使不同类型的容器能够使用同一种函数对象作为排序标准，确保你不会对具有不同排序标准的集合进行as-sign、组合或比较。你甚至可以设计函数对象的层次结构，这样你就可以，例如，对一个一般标准有不同的、特殊的种类。

- 函数对象通常比普通函数更快。模板的概念通常允许更好的优化，因为更多的细节在编译时被定义。因此，传递函数对象而不是普通函数往往能带来更好的性能。同时，也往智能化迈进了一步。














<h1>  三者联系 </h1>
为何学习deal.II会扯上学习STL和boost? 首先，让我们来看看他们之间的联系：




<h3>  异常处理 </h3>

几乎所有的异常类都可以由C++标准库抛出。特别是bad_alloc异常，只要分配存储空间就可以抛出。
此外，由于库的功能可能会使用应用程序员提供的代码，函数可能会间接地抛出任何异常。
任何标准库的实现都可能提供额外的异常类，无论是作为兄弟姐妹还是作为派生类。然而，使用这些非标准类使得代码不可移植，因为你不能在不破坏你的代码的情况下使用标准库的另一种实现。所以，你应该始终只使用标准的异常类。

<p align="center">
   <div class="img" align="center">
      <img src="https://cdn.mathpix.com/snip/images/1BHDXMx8RBep5mEKfo2JiexYoqDF3DFJgmzHjviCqOY.original.fullsize.png"
           alt = "标准异常处理的层次结构"
           width="500">
    </div>
</p>


<h3>  智能指针 </h3>
从C语言开始，我们知道指针很重要，但也是麻烦的来源。使用指针的一个原因是为了在通常的范围边界之外拥有引用语义。然而，要确保它们的寿命和它们所引用的对象的寿命相匹配是非常棘手的，特别是当多个指针引用同一个对象的时候。例如，要在多个集合中拥有同一个对象（见第7章），你必须在每个集合中传递一个指针，而且理想情况下，当其中一个指针被销毁时（没有 "悬空指针 "或被引用对象的多次删除），以及最后一个对象的引用被销毁时（没有 "资源泄漏"），应该没有问题。

避免这类问题的通常方法是使用 "智能指针"。它们的 "聪明 "之处在于，它们支持程序员避免出现刚才描述的那些问题。例如，一个智能指针可以非常聪明，以至于它 "知道 "自己是否是一个对象的最后一个指针，并且只有在它作为一个对象的 "最后所有者 "被销毁时，才使用这种知识来删除一个相关的对象。

从C++11开始由C++标准库提供的unique_ptr类型是一种智能指针，它有助于在抛出异常时避免资源泄漏。一般来说，这种智能指针实现了排他性所有权的概念，这意味着它确保一个对象和它的相关资源在同一时间只被一个指针 "拥有"。当这个所有者被销毁或变成空的或开始拥有另一个对象时，之前拥有的对象也会被销毁，任何相关的资源也会被释放。




DEALII中， 貌似做了相应的简化。
当所指向的对象被销毁或被移出时，Smartpointer就会被废止。


http://deal-ii.com/dealii-translator/doxygen/deal.II/classSmartPointer.html

TODO：解析智能指针的代码
http://deal-ii.com/dealii-translator/doxygen/deal.II/smartpointer_8h_source.html 